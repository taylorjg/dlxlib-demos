{"version":3,"file":"static/js/907.ffc0d788.chunk.js","mappings":"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","sources":["dlxlib/dataObject.ts","dlxlib/columnObject.ts","dlxlib/dlx.ts","utils.ts","types.ts","worker/stop-token.ts","worker/time-it.ts","demos/pentominoes/orientation.ts","demos/sudoku/demo.ts","demos/pentominoes/pattern.ts","demos/draughtboard-puzzle/colour.ts","demos/draughtboard-puzzle/orientation.ts","demos/pentominoes/pieces.ts","demos/pentominoes/pieces-with-variations.ts","demos/pentominoes/demo.ts","demos/draughtboard-puzzle/pattern.ts","demos/tetrasticks/orientation.ts","demos/draughtboard-puzzle/pieces.ts","demos/draughtboard-puzzle/pieces-with-variations.ts","demos/draughtboard-puzzle/demo.ts","demos/n-queens/demo.ts","demos/aztec-diamond/orientation.ts","demos/tetrasticks/pieces.ts","demos/tetrasticks/variation.ts","demos/tetrasticks/pieces-with-variations.ts","demos/tetrasticks/demo.ts","demos/aztec-diamond/locations.ts","demos/kakuro/run-type.ts","demos/aztec-diamond/pieces.ts","demos/aztec-diamond/variation.ts","demos/aztec-diamond/pieces-with-variations.ts","demos/aztec-diamond/thumbnail.tsx","demos/aztec-diamond/drawing.tsx","demos/aztec-diamond/demo.ts","demos/ripple-effect/demo.ts","demos/flow-free/path-finder.ts","demos/flow-free/demo.ts","demos/kakuro/run.ts","demos/kakuro/permutations.ts","demos/nonogram/run-group-type.ts","demos/kakuro/demo.ts","demos/nonogram/demo.ts","demos/crossword/clue-type.ts","demos/crossword/demo.ts","worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { ColumnObject } from \"./columnObject\"\n\nexport class DataObject {\n\n  public up: DataObject\n  public down: DataObject\n  public left: DataObject\n  public right: DataObject\n\n  public constructor(public listHeader?: ColumnObject, public rowIndex?: number) {\n    this.up = this\n    this.down = this\n    this.left = this\n    this.right = this\n    listHeader?.addDataObject(this)\n  }\n\n  public appendToRow(dataObject: DataObject) {\n    this.left.right = dataObject\n    dataObject.right = this\n    dataObject.left = this.left\n    this.left = dataObject\n  }\n\n  public appendToColumn(dataObject: DataObject) {\n    this.up.down = dataObject\n    dataObject.down = this\n    dataObject.up = this.up\n    this.up = dataObject\n  }\n\n  public unlinkFromColumn() {\n    this.down.up = this.up\n    this.up.down = this.down\n  }\n\n  public relinkIntoColumn() {\n    this.down.up = this\n    this.up.down = this\n  }\n\n  public loopUp(fn: (dataObject: DataObject) => void) { this.loop(fn, \"up\") }\n  public loopDown(fn: (dataObject: DataObject) => void) { this.loop(fn, \"down\") }\n  public loopLeft(fn: (dataObject: DataObject) => void) { this.loop(fn, \"left\") }\n  public loopRight(fn: (dataObject: DataObject) => void) { this.loop(fn, \"right\") }\n\n  private loop(\n    fn: (dataObject: DataObject) => void,\n    propName: \"up\" | \"down\" | \"left\" | \"right\"\n  ) {\n    for (let next = this[propName]; next !== this; next = next[propName]) {\n      fn(next)\n    }\n  }\n}\n","import { DataObject } from \"./dataObject\"\n\nexport class ColumnObject extends DataObject {\n\n  public previousColumnObject: ColumnObject\n  public nextColumnObject: ColumnObject\n  public numberOfRows: number\n\n  public constructor() {\n    super()\n    this.previousColumnObject = this\n    this.nextColumnObject = this\n    this.numberOfRows = 0\n  }\n\n  public appendColumnHeader(columnObject: ColumnObject) {\n    this.previousColumnObject.nextColumnObject = columnObject\n    columnObject.nextColumnObject = this\n    columnObject.previousColumnObject = this.previousColumnObject\n    this.previousColumnObject = columnObject\n  }\n\n  public unlinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this.previousColumnObject\n    this.previousColumnObject.nextColumnObject = this.nextColumnObject\n  }\n\n  public relinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this\n    this.previousColumnObject.nextColumnObject = this\n  }\n\n  public addDataObject(dataObject: DataObject) {\n    this.appendToColumn(dataObject)\n    this.numberOfRows++\n  }\n\n  public unlinkDataObject(dataObject: DataObject) {\n    dataObject.unlinkFromColumn()\n    this.numberOfRows--\n  }\n\n  public relinkDataObject(dataObject: DataObject) {\n    dataObject.relinkIntoColumn()\n    this.numberOfRows++\n  }\n\n  public loopNext(fn: (columnObject: ColumnObject) => void) {\n    for (let next = this.nextColumnObject; next !== this; next = next.nextColumnObject) {\n      fn(next)\n    }\n  }\n}\n","import EventEmitter from \"events\"\nimport { DataObject } from \"./dataObject\"\nimport { ColumnObject } from \"./columnObject\"\n\nexport type Matrix = Uint8Array[]\nexport type Solution = number[]\nexport type PartialSolution = number[]\n\nexport type Options = {\n  numSolutions?: number\n  numPrimaryColumns?: number,\n  checkForCancellation?: () => boolean\n  checkForCancellationFrequency?: number\n}\n\nexport function solve(matrix: Matrix, options: Options) {\n  return new Dlx().solve(matrix, options)\n}\n\nexport class Dlx extends EventEmitter {\n\n  public solve(matrix: Matrix, options?: Options): Solution[] {\n    this.checkOptions(options)\n    const numSolutions = options?.numSolutions ?? Number.MAX_SAFE_INTEGER\n    const solutions = []\n    const iterator = this.solutionGenerator(matrix, options)\n    for (let index = 0; index < numSolutions; index++) {\n      const iteratorResult = iterator.next()\n      if (iteratorResult.done) break\n      solutions.push(iteratorResult.value)\n    }\n    return solutions\n  }\n\n  public * solutionGenerator(matrix: Matrix, options?: Options): Generator<Solution> {\n    this.checkOptions(options)\n    const root = buildInternalStructure(matrix, options)\n    const searchState = new SearchState(this, root)\n    yield* search(searchState, options)\n  }\n\n  private checkOptions = (options?: Options): void => {\n    if (options?.numSolutions !== undefined) {\n      if (!Number.isInteger(options.numSolutions)) {\n        throw new Error(\"options.numSolutions must be an integer\")\n      }\n      if (options.numSolutions < 0) {\n        throw new Error(\"options.numSolutions can't be negative - don't be silly\")\n      }\n    }\n\n    if (options?.numPrimaryColumns !== undefined) {\n      if (!Number.isInteger(options.numPrimaryColumns)) {\n        throw new Error(\"options.numPrimaryColumns must be an integer\")\n      }\n      if (options.numPrimaryColumns < 0) {\n        throw new Error(\"options.numPrimaryColumns can't be negative - don't be silly\")\n      }\n    }\n  }\n}\n\nconst buildInternalStructure = (matrix: Matrix, options?: Options) => {\n\n  const numPrimaryColumns = options?.numPrimaryColumns ?? matrix[0].length\n\n  const root = new ColumnObject()\n  const colIndexToListHeader = new Map()\n  let cancelled = false\n\n  matrix.forEach((row: Uint8Array, rowIndex: number) => {\n    if (rowIndex % 1000 === 0) {\n      if (options?.checkForCancellation?.()) {\n        cancelled = true\n      }\n    }\n    if (cancelled) return\n    let firstDataObjectInThisRow: DataObject | undefined = undefined\n    row.forEach((col, colIndex: number) => {\n      if (rowIndex === 0) {\n        const listHeader = new ColumnObject()\n        if (colIndex < numPrimaryColumns) {\n          root.appendColumnHeader(listHeader)\n        }\n        colIndexToListHeader.set(colIndex, listHeader)\n      }\n      if (col) {\n        const listHeader = colIndexToListHeader.get(colIndex)\n        const dataObject = new DataObject(listHeader, rowIndex)\n        if (firstDataObjectInThisRow)\n          firstDataObjectInThisRow.appendToRow(dataObject)\n        else\n          firstDataObjectInThisRow = dataObject\n      }\n    })\n  })\n\n  return root\n}\n\nconst byAscendingRowIndices = (rowIndex1: number, rowIndex2: number) =>\n  rowIndex1 - rowIndex2\n\nfunction* search(searchState: SearchState, options?: Options): Generator<Solution> {\n\n  const checkForCancellationFrequency = options?.checkForCancellationFrequency ?? 100\n  if (searchState.getStepIndex() % checkForCancellationFrequency === 0) {\n    if (options?.checkForCancellation?.()) {\n      return\n    }\n  }\n\n  searchState.raiseSearchStepEvent()\n\n  if (searchState.isEmpty()) {\n    if (searchState.currentSolution.length) {\n      searchState.raiseSolutionFoundEvent()\n      yield searchState.currentSolution.slice().sort(byAscendingRowIndices)\n    }\n    return\n  }\n\n  const c = chooseColumnWithFewestRows(searchState)\n  coverColumn(c)\n  for (let r = c.down; r !== c; r = r.down) {\n    searchState.pushRowIndex(r.rowIndex!)\n    r.loopRight(j => coverColumn(j.listHeader!))\n    yield* search(searchState, options)\n    r.loopLeft(j => uncoverColumn(j.listHeader!))\n    searchState.popRowIndex()\n  }\n  uncoverColumn(c)\n}\n\nconst chooseColumnWithFewestRows = (searchState: SearchState) => {\n  let chosenColumn: ColumnObject | undefined = undefined\n  searchState.root.loopNext(column => {\n    if (!chosenColumn || column.numberOfRows < chosenColumn.numberOfRows) {\n      chosenColumn = column\n    }\n  })\n  return chosenColumn!\n}\n\nconst coverColumn = (c: ColumnObject) => {\n  c.unlinkColumnHeader()\n  c.loopDown(i => i.loopRight(j => j.listHeader!.unlinkDataObject(j)))\n}\n\nconst uncoverColumn = (c: ColumnObject) => {\n  c.loopUp(i => i.loopLeft(j => j.listHeader!.relinkDataObject(j)))\n  c.relinkColumnHeader()\n}\n\nclass SearchState {\n\n  public currentSolution: number[] = []\n  private stepIndex: number = 0\n  private solutionIndex: number = 0\n\n  public constructor(private dlx: Dlx, public root: ColumnObject) {\n  }\n\n  public getStepIndex(): number {\n    return this.stepIndex\n  }\n\n  public isEmpty() {\n    return this.root.nextColumnObject === this.root\n  }\n\n  public pushRowIndex(rowIndex: number) {\n    this.currentSolution.push(rowIndex)\n  }\n\n  public popRowIndex() {\n    this.currentSolution.pop()\n  }\n\n  public raiseSearchStepEvent() {\n    if (this.dlx.listenerCount(\"step\") > 0 && this.currentSolution.length) {\n      const partialSolution: PartialSolution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices)\n      const e = {\n        partialSolution,\n        stepIndex: this.stepIndex++\n      }\n      this.dlx.emit(\"step\", e)\n    }\n  }\n\n  public raiseSolutionFoundEvent() {\n    if (this.dlx.listenerCount(\"solution\") > 0) {\n      const solution: Solution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices)\n      const e = {\n        solution,\n        solutionIndex: this.solutionIndex++\n      }\n      this.dlx.emit(\"solution\", e)\n    }\n  }\n}\n","export const range = (n: number): number[] => Array.from(Array(n).keys())\nexport const sum = (ns: number[]): number => ns.reduce((acc, n) => acc + n, 0)\nexport const min = (ns: number[]): number => Math.min(...ns)\nexport const max = (ns: number[]): number => Math.max(...ns)\nexport function minBy<T>(xs: T[], selector: (x: T) => number): number { return min(xs.map(selector)) }\nexport function maxBy<T>(xs: T[], selector: (x: T) => number): number { return max(xs.map(selector)) }\nexport function first<T>(xs: T[]): T { return xs[0] }\nexport function last<T>(xs: T[]): T { return xs[xs.length - 1] }\nexport function distinct<T>(xs: T[]): T[] { return Array.from(new Set(xs)) }\n\nfunction defaultSameness<T>(x1: T, x2: T): boolean { return x1 === x2 }\n\nexport function except<T>(xs1: T[], xs2: T[], isSame: (x1: T, x2: T) => boolean = defaultSameness): T[] {\n  return xs1.filter(x1 => !xs2.some(x2 => isSame(x1, x2)))\n}\n\nexport function union<T>(xs1: T[], xs2: T[], isSame: (x1: T, x2: T) => boolean = defaultSameness): T[] {\n  return [...xs1].concat(xs2.filter(x2 => !xs1.some(x1 => isSame(x1, x2))))\n}\n\nexport function intersect<T>(xs1: T[], xs2: T[], isSame: (x1: T, x2: T) => boolean = defaultSameness): T[] {\n  const firstsInSecond = xs1.filter(x1 => xs2.some(x2 => isSame(x1, x2)))\n  const secondsInFirst = xs2.filter(x2 => xs1.some(x1 => isSame(x1, x2)))\n  return union(firstsInSecond, secondsInFirst, isSame)\n}\n\nexport const reverseString = (s: string): string => Array.from(s).reverse().join(\"\")\n","import { range } from \"utils\"\n\nexport type AvailableDemo = {\n  name: string,\n  shortName: string,\n  Thumbnail: React.FC,\n  hideBorder: boolean,\n  readmeSource?: string\n}\n\nexport type DrawingProps<TPuzzle, TInternalRow, TDrawingOptions = {}> = {\n  puzzle: TPuzzle,\n  solutionInternalRows: TInternalRow[],\n  drawingOptions: TDrawingOptions\n}\n\nexport type DemoControlsProps<TPuzzle, TDrawingOptions = {}> = {\n  selectedPuzzle: TPuzzle,\n  drawingOptions: TDrawingOptions,\n  onSelectedPuzzleChanged: (puzzle: TPuzzle) => void,\n  onDrawingOptionsChanged: (drawingOptions: TDrawingOptions) => void\n}\n\nexport interface IDemo<TPuzzle, TInternalRow> {\n  buildInternalRows(puzzle: TPuzzle, checkForCancellation: () => boolean): TInternalRow[]\n  internalRowToMatrixRow(internalRow: TInternalRow): number[]\n  getNumPrimaryColumns(puzzle: TPuzzle): number | undefined\n}\n\nexport type Point = {\n  x: number,\n  y: number\n}\n\nexport type Coords = {\n  row: number,\n  col: number\n}\n\nexport const goUp = (coords: Coords): Coords => ({ row: coords.row - 1, col: coords.col })\nexport const goDown = (coords: Coords): Coords => ({ row: coords.row + 1, col: coords.col })\nexport const goLeft = (coords: Coords): Coords => ({ row: coords.row, col: coords.col - 1 })\nexport const goRight = (coords: Coords): Coords => ({ row: coords.row, col: coords.col + 1 })\n\nexport const sameCoords = (coords1: Coords, coords2: Coords): boolean =>\n  coords1.row === coords2.row && coords1.col === coords2.col\n\nexport const addCoords = (coords1: Coords, coords2: Coords): Coords =>\n  ({ row: coords1.row + coords2.row, col: coords1.col + coords2.col })\n\nexport const sameCoordsList = (coordsList1: Coords[], coordsList2: Coords[]): boolean => {\n  if (coordsList1.length !== coordsList2.length) return false\n  for (const index of range(coordsList1.length)) {\n    const coords1 = coordsList1[index]\n    const coords2 = coordsList2[index]\n    if (!sameCoords(coords1, coords2)) return false\n  }\n  return true\n}\n\nexport const coordsComparer = (coords1: Coords, coords2: Coords): number => {\n  const rowDiff = coords1.row - coords2.row\n  const colDiff = coords1.col - coords2.col\n  return rowDiff !== 0 ? rowDiff : colDiff\n}\n\nexport enum CurrentState {\n  Clean,\n  Solving,\n  Dirty\n}\n\nexport enum Mode {\n  FirstSolution,\n  SearchSteps\n}\n","// https://github.com/panstromek/zebra-rs/blob/82d616225930b3ad423a2c6d883c79b94ee08ba6/webzebra/src/stopToken.ts\n\nexport function createStopToken(): string {\n  return URL.createObjectURL(new Blob())\n}\n\nexport function stop(stopToken: string): void {\n  return URL.revokeObjectURL(stopToken)\n}\n\nexport function checkStopToken(stopToken: string): boolean {\n  const xhr = new XMLHttpRequest()\n  xhr.open(\"GET\", stopToken, false)\n  try {\n    xhr.send(null)\n  } catch {\n    return true\n  }\n  return false\n}\n","export function timeIt<T>(label: string, fn: () => T): T {\n  const startTime = performance.now()\n  const result: T = fn()\n  const endTime = performance.now()\n  const elapsedTimeMs = endTime - startTime\n  const elapsedTimeS = elapsedTimeMs / 1000\n  console.log(`[${label}] elapsed time: ${elapsedTimeS.toLocaleString()}s`)\n  return result\n}\n","export enum Orientation { North, South, East, West }\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { InitialValue } from \"./initial-value\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    const allCoords = range(9).flatMap(row => range(9).map(col => ({ row, col })))\n    return allCoords.flatMap(coords => {\n      const initialValue = puzzle.initialValues.find(iv => sameCoords(iv.coords, coords))\n      return initialValue\n        ? this._buildInternalRowsForInitialValue(initialValue)\n        : this._buildInternalRowsForCoords(coords)\n    })\n  }\n\n  _buildInternalRowsForInitialValue(initialValue: InitialValue): InternalRow[] {\n    return [{ ...initialValue, isInitialValue: true }]\n  }\n\n  _buildInternalRowsForCoords(coords: Coords): InternalRow[] {\n    return range(9).map(n => n + 1).map(value => ({\n      coords,\n      value,\n      isInitialValue: false\n    }))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords\n    const box = this._rowColToBox(row, col);\n    const zeroBasedValue = internalRow.value - 1\n    const posColumns = this._oneHot(row, col);\n    const rowColumns = this._oneHot(row, zeroBasedValue);\n    const colColumns = this._oneHot(col, zeroBasedValue);\n    const boxColumns = this._oneHot(box, zeroBasedValue);\n    return posColumns\n      .concat(rowColumns)\n      .concat(colColumns)\n      .concat(boxColumns)\n  }\n\n  _oneHot(major: number, minor: number): number[] {\n    const columns = Array(81).fill(0)\n    columns[major * 9 + minor] = 1\n    return columns\n  }\n\n  _rowColToBox(row: number, col: number): number {\n    return Math.floor(row - (row % 3) + (col / 3))\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n}\n","import { Coords } from \"types\"\nimport { range, reverseString } from \"utils\"\n\nexport const rotateCW = (pattern: string[]): string[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const rowIndices = range(rowCount)\n  const colIndices = range(colCount)\n  const transposed = colIndices.map(col => rowIndices.map(row => pattern[row][col]).join(\"\"))\n  return reflect(transposed)\n}\n\nexport const reflect = (pattern: string[]): string[] => {\n  return pattern.map(reverseString)\n}\n\nexport const toCoordsList = (pattern: string[]): Coords[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const coordsList: Coords[] = []\n\n  for (const row of range(rowCount)) {\n    for (const col of range(colCount)) {\n      if (pattern[row][col] === \"X\") {\n        const coords = { row, col }\n        coordsList.push(coords)\n      }\n    }\n  }\n\n  return coordsList\n}\n","export enum Colour { Black, White }\n","export enum Orientation { North, South, East, West }\n","import { Piece } from \"./piece\"\n\n// https://en.wikipedia.org/wiki/Pentomino\nconst piecesMap = new Map<string, string[]>([\n  [\n    \"F\",\n    [\n      \" XX\",\n      \"XX \",\n      \" X \"\n    ]\n  ],\n  [\n    \"I\",\n    [\n      \"X\",\n      \"X\",\n      \"X\",\n      \"X\",\n      \"X\"\n    ]\n  ],\n  [\n    \"L\",\n    [\n      \"X \",\n      \"X \",\n      \"X \",\n      \"XX\"\n    ]\n  ],\n  [\n    \"N\",\n    [\n      \" X\",\n      \" X\",\n      \"XX\",\n      \"X \"\n    ]\n  ],\n  [\n    \"P\",\n    [\n      \"XX\",\n      \"XX\",\n      \"X \"\n    ]\n  ],\n  [\n    \"T\",\n    [\n      \"XXX\",\n      \" X \",\n      \" X \"\n    ]\n  ],\n  [\n    \"U\",\n    [\n      \"X X\",\n      \"XXX\"\n    ]\n  ],\n  [\n    \"V\",\n    [\n      \"X  \",\n      \"X  \",\n      \"XXX\"\n    ]\n  ],\n  [\n    \"W\",\n    [\n      \"X  \",\n      \"XX \",\n      \" XX\"\n    ]\n  ],\n  [\n    \"X\",\n    [\n      \" X \",\n      \"XXX\",\n      \" X \"\n    ]\n  ],\n  [\n    \"Y\",\n    [\n      \" X\",\n      \"XX\",\n      \" X\",\n      \" X\"\n    ]\n  ],\n  [\n    \"Z\",\n    [\n      \"XX \",\n      \" X \",\n      \" XX\"\n    ]\n  ],\n])\n\nexport const pieces: Piece[] =\n  Array.from(piecesMap)\n    .map(([label, pattern]) => ({ label, pattern }))\n","import { Orientation } from \"./orientation\"\nimport { reflect, rotateCW, toCoordsList } from \"./pattern\"\nimport { Piece } from \"./piece\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { pieces } from \"./pieces\"\nimport { Variation } from \"./variation\"\n\ntype VariationCandidate = {\n  orientation: Orientation,\n  reflected: boolean,\n  pattern: string[]\n}\n\nconst reflectVariationCandidate = (vc: VariationCandidate): VariationCandidate => {\n  return {\n    ...vc,\n    reflected: true,\n    pattern: reflect(vc.pattern)\n  }\n}\n\nconst makeVariation = (vc: VariationCandidate): Variation => ({\n  orientation: vc.orientation,\n  reflected: vc.reflected,\n  coordsList: toCoordsList(vc.pattern)\n})\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const { label, pattern } = piece\n\n  const north = { orientation: Orientation.North, reflected: false, pattern }\n  const northReflected = reflectVariationCandidate(north)\n\n  const east = { orientation: Orientation.East, reflected: false, pattern: rotateCW(north.pattern) }\n  const eastReflected = reflectVariationCandidate(east)\n\n  const south = { orientation: Orientation.South, reflected: false, pattern: rotateCW(east.pattern) }\n  const southReflected = reflectVariationCandidate(south)\n\n  const west = { orientation: Orientation.West, reflected: false, pattern: rotateCW(south.pattern) }\n  const westReflected = reflectVariationCandidate(west)\n\n  const allVariationCandidates = [\n    north, northReflected,\n    east, eastReflected,\n    south, southReflected,\n    west, westReflected\n  ]\n\n  const representations = new Set<string>()\n  const uniqueVariationCandidates: VariationCandidate[] = []\n  for (const vc of allVariationCandidates) {\n    const representation = vc.pattern.join(\"|\")\n    if (!representations.has(representation)) {\n      representations.add(representation)\n      uniqueVariationCandidates.push(vc)\n    }\n  }\n\n  const variations = uniqueVariationCandidates.map(makeVariation)\n\n  return { label, variations }\n}\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations)\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\n\nexport class Demo implements IDemo<{}, InternalRow> {\n\n  buildInternalRows(puzzle: {}, checkForCancellation: () => boolean): InternalRow[] {\n    return this.allPossiblePiecePlacements()\n      .filter(internalRow => this.isValidPiecePlacement(internalRow))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow)\n    const locationColumns = this.makeLocationColumns(internalRow)\n    return pieceColumns.concat(locationColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: {}): number | undefined {\n    return undefined\n  }\n\n  allLocations =\n    range(8).flatMap(row =>\n      range(8).map(col =>\n        ({ row, col })))\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    for (const coords of internalRow.variation.coordsList) {\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      if (row >= 8 || col >= 8) return false\n      if ((row === 3 || row === 4) && (col === 3 || col === 4)) return false\n    }\n    return true\n  }\n\n  allPossiblePiecePlacements(): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    const fixedPieceLabels = piecesWithVariations.slice(0, 1).map(({ label }) => label)\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const variations = fixedPieceLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label\n          const internalRow = { label, variation, location }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0)\n    const pieceIndex = piecesWithVariations.findIndex(pwv => pwv.label === internalRow.label)\n    columns[pieceIndex] = 1\n    return columns\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const indices = internalRow.variation.coordsList.map(coords => {\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      return row * 8 + col\n    })\n\n    const columns = Array(8 * 8).fill(0)\n\n    for (const index of indices) {\n      columns[index] = 1\n    }\n\n    const indicesToExclude = [\n      3 * 8 + 3,\n      3 * 8 + 4,\n      4 * 8 + 3,\n      4 * 8 + 4\n    ]\n\n    return columns.filter((_, index) => !indicesToExclude.includes(index))\n  }\n}\n","import { range, reverseString } from \"utils\"\nimport { Colour } from \"./colour\"\nimport { Square } from \"./square\"\n\nexport const rotateCW = (pattern: string[]): string[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const rowIndices = range(rowCount)\n  const colIndices = range(colCount)\n  const transposed = colIndices.map(col => rowIndices.map(row => pattern[row][col]).join(\"\"))\n  return reflect(transposed)\n}\n\nexport const reflect = (pattern: string[]): string[] => {\n  return pattern.map(reverseString)\n}\n\nexport const toSquares = (pattern: string[]): Square[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const squares: Square[] = []\n\n  for (const row of range(rowCount)) {\n    for (const col of range(colCount)) {\n      const coords = { row, col }\n      switch (pattern[row][col]) {\n        case \"B\":\n          squares.push({coords, colour: Colour.Black})\n          break\n        case \"W\":\n          squares.push({coords, colour: Colour.White})\n          break\n      }\n    }\n  }\n\n  return squares\n}\n","export enum Orientation {\n  North,\n  South,\n  East,\n  West\n}\n\nexport const rotateCW = (orientation: Orientation): Orientation => {\n  switch (orientation) {\n    case Orientation.North: return Orientation.East\n    case Orientation.South: return Orientation.West\n    case Orientation.East: return Orientation.South\n    case Orientation.West: return Orientation.North\n  }\n}\n","import { Piece } from \"./piece\"\n\nconst piecesMap = new Map<string, string[]>([\n  [\n    \"A\",\n    [\n      \"B \",\n      \"WB\",\n      \"B \",\n      \"W \"\n    ]\n  ],\n  [\n    \"B\",\n    [\n      \"B  \",\n      \"WBW\"\n    ],\n  ],\n  [\n    \"C\",\n    [\n      \"W \",\n      \"BW\"\n    ]\n  ],\n  [\n    \"D\",\n    [\n      \" WB\",\n      \" B \",\n      \"BW \"\n    ]\n  ],\n  [\n    \"E\",\n    [\n      \"W \",\n      \"BW\",\n      \" B\",\n      \" W\"\n    ]\n  ],\n  [\n    \"F\",\n    [\n      \"WB \",\n      \" W \",\n      \" BW\"\n    ]\n  ],\n  [\n    \"G\",\n    [\n      \"WB \",\n      \" WB\"\n    ]\n  ],\n  [\n    \"H\",\n    [\n      \"B \",\n      \"WB\",\n      \"B \"\n    ]\n  ],\n  [\n    \"I\",\n    [\n      \"B \",\n      \"W \",\n      \"BW\",\n      \"W \"\n    ]\n  ],\n  [\n    \"J\",\n    [\n      \" B\",\n      \" W\",\n      \" B\",\n      \"BW\"\n    ]\n  ],\n  [\n    \"K\",\n    [\n      \"  W\",\n      \" WB\",\n      \"WB \"\n    ]\n  ],\n  [\n    \"L\",\n    [\n      \"B \",\n      \"W \",\n      \"BW\"\n    ]\n  ],\n  [\n    \"M\",\n    [\n      \" B\",\n      \" W\",\n      \"WB\",\n      \"B \"\n    ]\n  ],\n  [\n    \"N\",\n    [\n      \"W \",\n      \"B \",\n      \"W \",\n      \"BW\"\n    ]\n  ]\n])\n\nexport const pieces: Piece[] =\n  Array.from(piecesMap)\n    .map(([label, pattern]) => ({ label, pattern }))\n","import { Orientation } from \"./orientation\"\nimport { rotateCW, toSquares } from \"./pattern\"\nimport { Piece } from \"./piece\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { pieces } from \"./pieces\"\nimport { Variation } from \"./variation\"\n\ntype VariationCandidate = {\n  orientation: Orientation,\n  pattern: string[]\n}\n\nconst makeVariation = (vc: VariationCandidate): Variation => ({\n  orientation: vc.orientation,\n  squares: toSquares(vc.pattern)\n})\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const { label, pattern } = piece\n\n  const north = { orientation: Orientation.North, pattern }\n  const east = { orientation: Orientation.East, pattern: rotateCW(north.pattern) }\n  const south = { orientation: Orientation.South, pattern: rotateCW(east.pattern) }\n  const west = { orientation: Orientation.West, pattern: rotateCW(south.pattern) }\n\n  const allVariationCandidates = [north, east, south, west]\n\n  const representations = new Set<string>()\n  const uniqueVariationCandidates: VariationCandidate[] = []\n  for (const vc of allVariationCandidates) {\n    const representation = vc.pattern.join(\"|\")\n    if (!representations.has(representation)) {\n      representations.add(representation)\n      uniqueVariationCandidates.push(vc)\n    }\n  }\n\n  const variations = uniqueVariationCandidates.map(makeVariation)\n\n  return { label, variations }\n}\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations)\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { Colour } from \"./colour\"\nimport { InternalRow } from \"./internal-row\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\n\nexport class Demo implements IDemo<{}, InternalRow> {\n\n  buildInternalRows(puzzle: {}, checkForCancellation: () => boolean): InternalRow[] {\n    return this.allPossiblePiecePlacements()\n      .filter(internalRow => this.isValidPiecePlacement(internalRow))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow)\n    const locationColumns = this.makeLocationColumns(internalRow)\n    return pieceColumns.concat(locationColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: {}): number | undefined {\n    return undefined\n  }\n\n  allLocations =\n    range(8).flatMap(row =>\n      range(8).map(col =>\n        ({ row, col })))\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    for (const square of internalRow.variation.squares) {\n      const { coords, colour } = square\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      if (row < 0 || row >= 8) return false\n      if (col < 0 || col >= 8) return false\n      const requiredColour = (row + col) % 2 !== 0 ? Colour.White : Colour.Black\n      if (colour !== requiredColour) return false\n    }\n    return true\n  }\n\n  allPossiblePiecePlacements(): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    const fixedPieceLabels = piecesWithVariations.slice(0, 1).map(({ label }) => label)\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const variations = fixedPieceLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label\n          const internalRow = { label, variation, location }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0)\n    const pieceIndex = piecesWithVariations.findIndex(pwv => pwv.label === internalRow.label)\n    columns[pieceIndex] = 1\n    return columns\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const indices = internalRow.variation.squares.map(square => {\n      const { coords } = square\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      return row * 8 + col\n    })\n\n    const columns = Array(8 * 8).fill(0)\n\n    for (const index of indices) {\n      columns[index] = 1\n    }\n\n    return columns\n  }\n}\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { Puzzle } from \"./puzzle\"\nimport { InternalRow } from \"./internal-row\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    const allLocations = range(puzzle.size).flatMap(row =>\n      range(puzzle.size).map(col =>\n        ({ row, col })))\n    return allLocations.map(coords => ({ puzzle, coords }))\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.size * 2\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords\n    const size = internalRow.puzzle.size\n    const diagonalColumnCount = size + size - 3\n\n    const rowColumns = Array(size).fill(0)\n    const colColumns = Array(size).fill(0)\n    const diagonal1Columns = Array(diagonalColumnCount).fill(0)\n    const diagonal2Columns = Array(diagonalColumnCount).fill(0)\n\n    rowColumns[row] = 1\n    colColumns[col] = 1\n\n    const diagonal1 = row + col - 1\n    if (diagonal1 >= 0 && diagonal1 < diagonalColumnCount) diagonal1Columns[diagonal1] = 1\n\n    const diagonal2 = size - 1 - col + row - 1\n    if (diagonal2 >= 0 && diagonal2 < diagonalColumnCount) diagonal2Columns[diagonal2] = 1\n\n    return rowColumns\n      .concat(colColumns)\n      .concat(diagonal1Columns)\n      .concat(diagonal2Columns)\n  }\n}\n","export enum Orientation {\n  North,\n  South,\n  East,\n  West\n}\n\nexport const rotateCW = (orientation: Orientation): Orientation => {\n  switch (orientation) {\n    case Orientation.North: return Orientation.East\n    case Orientation.South: return Orientation.West\n    case Orientation.East: return Orientation.South\n    case Orientation.West: return Orientation.North\n  }\n}\n","import { Coords } from \"types\"\nimport { Piece } from \"./piece\"\n\nconst piecesMap = new Map<string, { lineSegments: string, polyLines: string }>([\n  [\"F\", { lineSegments: \"H00 V00 H10 V10\", polyLines: \"0,1 0,0 1,0 1,1|1,1 1,0 2,0\" }],\n  [\"H\", { lineSegments: \"V00 V10 H10 V11\", polyLines: \"0,0 1,0 1,1 2,1|2,0 1,0 1,1 2,1\" }],\n  [\"I\", { lineSegments: \"V00 V10 V20 V30 I10 I20 I30\", polyLines: \"0,0 1,0 2,0 3,0 4,0\" }],\n  [\"J\", { lineSegments: \"V10 H20 V11 V01 I11\", polyLines: \"1,0 2,0 2,1 1,1 0,1\" }],\n  [\"L\", { lineSegments: \"V00 V10 V20 H30 I10 I20\", polyLines: \"0,0 1,0 2,0 3,0 3,1\" }],\n  [\"N\", { lineSegments: \"V20 H20 V01 V11 I11\", polyLines: \"3,0 2,0 2,1 1,1 0,1\" }],\n  [\"O\", { lineSegments: \"H00 V01 H10 V00\", polyLines: \"0,0 0,1 1,1 1,0 0,0\" }],\n  [\"P\", { lineSegments: \"H00 V01 H10 V10\", polyLines: \"0,0 0,1 1,1 1,0 2,0\" }],\n  [\"R\", { lineSegments: \"H10 V11 V01 H01\", polyLines: \"1,0 1,1 2,1|1,0 1,1 0,1 0,2\" }],\n  [\"T\", { lineSegments: \"H00 H01 V01 V11 I11\", polyLines: \"0,0 0,1 1,1 2,1|0,2 0,1 1,1 2,1\" }],\n  [\"U\", { lineSegments: \"V00 H10 H11 V02 I11\", polyLines: \"0,0 1,0 1,1 1,2 0,2\" }],\n  [\"V\", { lineSegments: \"V00 V10 H20 H21 I10 I21\", polyLines: \"0,0 1,0 2,0 2,1 2,2\" }],\n  [\"W\", { lineSegments: \"V00 H10 V11 H21\", polyLines: \"0,0 1,0 1,1 2,1 2,2\" }],\n  [\"X\", { lineSegments: \"V01 V11 H10 H11\", polyLines: \"1,0 1,1 0,1|0,1 1,1 1,2|1,2 1,1 2,1|2,1 1,1 1,0\" }],\n  [\"Y\", { lineSegments: \"H10 V01 V11 V21 I21\", polyLines: \"1,0 1,1 0,1|1,0 1,1 2,1 3,1\" }],\n  [\"Z\", { lineSegments: \"H00 V01 V11 H21 I11\", polyLines: \"0,0 0,1 1,1 2,1 2,2\" }]\n])\n\nconst parsePiece = (\n  label: string,\n  lineSegmentDescriptions: string,\n  polyLineDescriptions: string\n): Piece => {\n  const horizontals: Coords[] = []\n  const verticals: Coords[] = []\n  const junctions: Coords[] = []\n  const polyLines = parsePolyLineDescriptions(polyLineDescriptions)\n\n  const bits = lineSegmentDescriptions.split(/\\s/).map(s => s.trim()).filter(Boolean)\n\n  for (const bit of bits) {\n    const type = bit[0]\n    const row = Number(bit[1])\n    const col = Number(bit[2])\n    const coords = { row, col }\n    switch (type) {\n      case \"H\":\n        horizontals.push(coords)\n        break\n      case \"V\":\n        verticals.push(coords)\n        break\n      case \"I\":\n        junctions.push(coords)\n        break\n    }\n  }\n\n  return { label, horizontals, verticals, junctions, polyLines: polyLines }\n}\n\nconst parsePolyLineDescriptions = (polyLineDescriptions: string): Coords[][] => {\n  return polyLineDescriptions\n    .split(\"|\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(parsePolyLineDescription)\n}\n\nconst parsePolyLineDescription = (polyLineDescription: string): Coords[] => {\n  return polyLineDescription\n    .split(/\\s/)\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(coordsString => {\n      const row = Number(coordsString[0])\n      const col = Number(coordsString[2])\n      return { row, col }\n    })\n}\n\nexport const pieces =\n  Array.from(piecesMap)\n    .map(([label, { lineSegments, polyLines }]) =>\n      parsePiece(label, lineSegments, polyLines))\n","import { Coords, coordsComparer } from \"types\"\nimport { maxBy } from \"utils\"\nimport { Orientation, rotateCW as rotateOrientationCW } from \"./orientation\"\n\nexport type Variation = {\n  orientation: Orientation,\n  reflected: boolean,\n  horizontals: Coords[],\n  verticals: Coords[],\n  junctions: Coords[]\n  polyLines: Coords[][]\n}\n\nexport const getDimensions = (variation: Variation): { width: number, height: number } => {\n  const width = variation.horizontals.length ? maxBy(variation.horizontals, h => h.col) + 1 : 0\n  const height = variation.verticals.length ? maxBy(variation.verticals, v => v.row) + 1 : 0\n  return { width, height }\n}\n\nexport const reflect = (variation: Variation): Variation => {\n  const { width } = getDimensions(variation)\n  const newHorizontals = variation.horizontals.map(c => ({ row: c.row, col: width - c.col - 1 }))\n  const newVerticals = variation.verticals.map(c => ({ row: c.row, col: width - c.col }))\n  const newJunctions = variation.junctions.map(c => ({ row: c.row, col: width - c.col }))\n  const newPolyLines = variation.polyLines.map(polyLine => polyLine.map(c => ({ row: c.row, col: width - c.col })))\n\n  return {\n    orientation: variation.orientation,\n    reflected: !variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines\n  }\n}\n\nexport const rotateCW = (variation: Variation): Variation => {\n  const { height } = getDimensions(variation)\n  const newHorizontals = variation.verticals.map(c => ({ row: c.col, col: height - c.row - 1 }))\n  const newVerticals = variation.horizontals.map(c => ({ row: c.col, col: height - c.row }))\n  const newJunctions = variation.junctions.map(c => ({ row: c.col, col: height - c.row }))\n  const newPolyLines = variation.polyLines.map(polyLine => polyLine.map(c => ({ row: c.col, col: height - c.row })))\n\n  return {\n    orientation: rotateOrientationCW(variation.orientation),\n    reflected: variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines\n  }\n}\n\nexport const normalisedRepresentation = (variation: Variation): string => {\n  const sortedHorizontals = variation.horizontals.slice().sort(coordsComparer)\n  const sortedVerticals = variation.verticals.slice().sort(coordsComparer)\n  const hs = sortedHorizontals.map(coords => `H${coords.row}:${coords.col}`)\n  const vs = sortedVerticals.map(coords => `V${coords.row}:${coords.col}`)\n  return hs.concat(vs).join(\"-\")\n}\n","import { Orientation } from \"./orientation\"\nimport { Piece } from \"./piece\"\nimport { pieces } from \"./pieces\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { normalisedRepresentation, reflect, rotateCW, Variation } from \"./variation\"\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const north = {\n    orientation: Orientation.North,\n    reflected: false,\n    horizontals: piece.horizontals,\n    verticals: piece.verticals,\n    junctions: piece.junctions,\n    polyLines: piece.polyLines\n  }\n  const northReflected = reflect(north)\n\n  const east = rotateCW(north)\n  const eastReflected = reflect(east)\n\n  const south = rotateCW(east)\n  const southReflected = reflect(south)\n\n  const west = rotateCW(south)\n  const westReflected = reflect(west)\n\n  const allVariations = [\n    north, northReflected,\n    east, eastReflected,\n    south, southReflected,\n    west, westReflected\n  ]\n\n  const representations = new Set<string>()\n  const uniqueVariations: Variation[] = []\n  allVariations.forEach(variation => {\n    const representation = normalisedRepresentation(variation)\n    if (!representations.has(representation)) {\n      representations.add(representation)\n      uniqueVariations.push(variation)\n    }\n  })\n\n  return { label: piece.label, variations: uniqueVariations }\n}\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations)\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    return this.allPossiblePiecePlacements(puzzle).filter(this.isValidPiecePlacement)\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow)\n    const horizontalsColumns = this.makeHorizontalsColumns(internalRow)\n    const vertialsColumns = this.makeVerticalsColumns(internalRow)\n    const junctionsColumns = this.makeJunctionsColumns(internalRow)\n    return pieceColumns\n      .concat(horizontalsColumns)\n      .concat(vertialsColumns)\n      .concat(junctionsColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    const numPieces = 15\n    const numHorizontals = 30\n    const numVerticals = 30\n    return numPieces + numHorizontals + numVerticals\n  }\n\n  allLocations =\n    range(9).flatMap(row =>\n      range(9).map(col =>\n        ({ row, col })))\n\n  getPiecesInPlay(puzzle: Puzzle): PieceWithVariations[] {\n    return piecesWithVariations.filter(pwv => pwv.label !== puzzle.pieceToOmit.label)\n  }\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    const { location } = internalRow\n\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row\n      const col = location.col + horizontal.col\n      if (row > 5) return false // valid rows for horizontal line segments: 0..5\n      if (col > 4) return false // valid cols for horizontal line segments: 0..4\n    }\n\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row\n      const col = location.col + vertical.col\n      if (row > 4) return false // valid rows for vertical line segments: 0..4\n      if (col > 5) return false // valid cols for vertical line segments: 0..5\n    }\n\n    return true\n  }\n\n  allPossiblePiecePlacements(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    const fixedPieceLabels = piecesWithVariations.slice().reverse().slice(0, 1).map(({ label }) => label)\n    const piecesInPlay = this.getPiecesInPlay(puzzle)\n\n    for (const pieceWithVariations of piecesInPlay) {\n      const variations = fixedPieceLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label\n          const internalRow = { puzzle, label, variation, location }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const piecesInPlay = this.getPiecesInPlay(internalRow.puzzle)\n    const columns = Array(piecesInPlay.length).fill(0)\n    const index = piecesInPlay.findIndex(pip => pip.label === internalRow.label)\n    columns[index] = 1\n    return columns\n  }\n\n  makeHorizontalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow\n    const columns = Array(30).fill(0)\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row\n      const col = location.col + horizontal.col\n      columns[row * 5 + col] = 1\n    }\n    return columns\n  }\n\n  makeVerticalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow\n    const columns = Array(30).fill(0)\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row\n      const col = location.col + vertical.col\n      columns[col * 5 + row] = 1\n    }\n    return columns\n  }\n\n  makeJunctionsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow\n    const columns = Array(16).fill(0)\n    for (const junction of internalRow.variation.junctions) {\n      const row = location.row + junction.row\n      const col = location.col + junction.col\n      if (row > 0 && row < 5 && col > 0 && col < 5) {\n        columns[(row - 1) * 4 + col - 1] = 1\n      }\n    }\n    return columns\n  }\n}\n","import { Coords, goLeft, sameCoords } from \"types\"\nimport { range } from \"utils\"\n\nexport const allHorizontals: Coords[] =\n  range(10).flatMap(row => range(9).map(col => ({ row, col })))\n    .filter(({ row, col }) => {\n      const centreRelativeRow = row - 4.5\n      const centreRelativeCol = col - 4.0\n      return (Math.abs(centreRelativeRow) + Math.abs(centreRelativeCol) <= 5)\n    })\n\nexport const allVerticals: Coords[] =\n  range(9).flatMap(row => range(10).map(col => ({ row, col })))\n    .filter(({ row, col }) => {\n      const centreRelativeRow = row - 4.0\n      const centreRelativeCol = col - 4.5\n      return (Math.abs(centreRelativeRow) + Math.abs(centreRelativeCol) <= 5)\n    })\n\nexport const allJunctions: Coords[] =\n  allHorizontals\n    .filter(h1 => allHorizontals.some(h2 => sameCoords(goLeft(h1), h2)))\n\nexport const allLocations: Coords[] =\n  allHorizontals.concat(allVerticals.filter(v => !allHorizontals.some(h => sameCoords(v, h))))\n","export enum RunType {\n  Horizontal,\n  Vertical\n}\n","import { Coords } from \"types\"\nimport { Piece } from \"./piece\"\n\nconst twoSidedPiecesMap = new Map<string, { lineSegments: string, polyLines: string }>([\n  [\"I\", { lineSegments: \"V00 V10 V20 V30 I10 I20 I30\", polyLines: \"0,0 1,0 2,0 3,0 4,0\" }],\n  [\"O\", { lineSegments: \"H00 V01 H10 V00\", polyLines: \"0,0 0,1 1,1 1,0 0,0\" }],\n  [\"T\", { lineSegments: \"H00 H01 V01 V11 I11\", polyLines: \"0,0 0,1 1,1 2,1|0,2 0,1 1,1 2,1\" }],\n  [\"U\", { lineSegments: \"V00 H10 H11 V02 I11\", polyLines: \"0,0 1,0 1,1 1,2 0,2\" }],\n  [\"V\", { lineSegments: \"V00 V10 H20 H21 I10 I21\", polyLines: \"0,0 1,0 2,0 2,1 2,2\" }],\n  [\"W\", { lineSegments: \"V00 H10 V11 H21\", polyLines: \"0,0 1,0 1,1 2,1 2,2\" }],\n  [\"X\", { lineSegments: \"V01 V11 H10 H11\", polyLines: \"1,0 1,1 0,1|0,1 1,1 1,2|1,2 1,1 2,1|2,1 1,1 1,0\" }]\n])\n\nconst oneSidedPiecesMap = new Map<string, { lineSegments: string, polyLines: string }>([\n  [\"F\", { lineSegments: \"H00 V00 H10 V10\", polyLines: \"0,1 0,0 1,0 1,1|1,1 1,0 2,0\" }],\n  [\"H\", { lineSegments: \"V00 V10 H10 V11\", polyLines: \"0,0 1,0 1,1 2,1|2,0 1,0 1,1 2,1\" }],\n  [\"J\", { lineSegments: \"V10 H20 V11 V01 I11\", polyLines: \"1,0 2,0 2,1 1,1 0,1\" }],\n  [\"L\", { lineSegments: \"V00 V10 V20 H30 I10 I20\", polyLines: \"0,0 1,0 2,0 3,0 3,1\" }],\n  [\"N\", { lineSegments: \"V20 H20 V01 V11 I11\", polyLines: \"3,0 2,0 2,1 1,1 0,1\" }],\n  [\"P\", { lineSegments: \"H00 V01 H10 V10\", polyLines: \"0,0 0,1 1,1 1,0 2,0\" }],\n  [\"R\", { lineSegments: \"H10 V11 V01 H01\", polyLines: \"1,0 1,1 2,1|1,0 1,1 0,1 0,2\" }],\n  [\"Y\", { lineSegments: \"H10 V01 V11 V21 I21\", polyLines: \"1,0 1,1 0,1|1,0 1,1 2,1 3,1\" }],\n  [\"Z\", { lineSegments: \"H00 V01 V11 H21 I11\", polyLines: \"0,0 0,1 1,1 2,1 2,2\" }]\n])\n\nconst parsePiece = (\n  label: string,\n  lineSegmentDescriptions: string,\n  polyLineDescriptions: string\n): Piece => {\n  const horizontals: Coords[] = []\n  const verticals: Coords[] = []\n  const junctions: Coords[] = []\n  const polyLines = parsePolyLineDescriptions(polyLineDescriptions)\n\n  const bits = lineSegmentDescriptions.split(/\\s/).map(s => s.trim()).filter(Boolean)\n\n  for (const bit of bits) {\n    const type = bit[0]\n    const row = Number(bit[1])\n    const col = Number(bit[2])\n    const coords = { row, col }\n    switch (type) {\n      case \"H\":\n        horizontals.push(coords)\n        break\n      case \"V\":\n        verticals.push(coords)\n        break\n      case \"I\":\n        junctions.push(coords)\n        break\n    }\n  }\n\n  return { label, horizontals, verticals, junctions, polyLines: polyLines }\n}\n\nconst parsePolyLineDescriptions = (polyLineDescriptions: string): Coords[][] => {\n  return polyLineDescriptions\n    .split(\"|\")\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(parsePolyLineDescription)\n}\n\nconst parsePolyLineDescription = (polyLineDescription: string): Coords[] => {\n  return polyLineDescription\n    .split(/\\s/)\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(coordsString => {\n      const row = Number(coordsString[0])\n      const col = Number(coordsString[2])\n      return { row, col }\n    })\n}\n\nexport const twoSidedPieces =\n  Array.from(twoSidedPiecesMap)\n    .map(([label, { lineSegments, polyLines }]) =>\n      parsePiece(label, lineSegments, polyLines))\n\nexport const oneSidedPieces =\n  Array.from(oneSidedPiecesMap)\n    .map(([label, { lineSegments, polyLines }]) =>\n      parsePiece(label, lineSegments, polyLines))\n","import { Coords, coordsComparer } from \"types\"\nimport { maxBy } from \"utils\"\nimport { Orientation, rotateCW as rotateOrientationCW } from \"./orientation\"\n\nexport type Variation = {\n  orientation: Orientation,\n  reflected: boolean,\n  horizontals: Coords[],\n  verticals: Coords[],\n  junctions: Coords[]\n  polyLines: Coords[][]\n}\n\nexport const getDimensions = (variation: Variation): { width: number, height: number } => {\n  const width = variation.horizontals.length ? maxBy(variation.horizontals, h => h.col) + 1 : 0\n  const height = variation.verticals.length ? maxBy(variation.verticals, v => v.row) + 1 : 0\n  return { width, height }\n}\n\nexport const reflect = (variation: Variation): Variation => {\n  const { width } = getDimensions(variation)\n  const newHorizontals = variation.horizontals.map(c => ({ row: c.row, col: width - c.col - 1 }))\n  const newVerticals = variation.verticals.map(c => ({ row: c.row, col: width - c.col }))\n  const newJunctions = variation.junctions.map(c => ({ row: c.row, col: width - c.col }))\n  const newPolyLines = variation.polyLines.map(polyLine => polyLine.map(c => ({ row: c.row, col: width - c.col })))\n\n  return {\n    orientation: variation.orientation,\n    reflected: !variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines\n  }\n}\n\nexport const rotateCW = (variation: Variation): Variation => {\n  const { height } = getDimensions(variation)\n  const newHorizontals = variation.verticals.map(c => ({ row: c.col, col: height - c.row - 1 }))\n  const newVerticals = variation.horizontals.map(c => ({ row: c.col, col: height - c.row }))\n  const newJunctions = variation.junctions.map(c => ({ row: c.col, col: height - c.row }))\n  const newPolyLines = variation.polyLines.map(polyLine => polyLine.map(c => ({ row: c.col, col: height - c.row })))\n\n  return {\n    orientation: rotateOrientationCW(variation.orientation),\n    reflected: variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines\n  }\n}\n\nexport const normalisedRepresentation = (variation: Variation): string => {\n  const sortedHorizontals = variation.horizontals.slice().sort(coordsComparer)\n  const sortedVerticals = variation.verticals.slice().sort(coordsComparer)\n  const hs = sortedHorizontals.map(coords => `H${coords.row}:${coords.col}`)\n  const vs = sortedVerticals.map(coords => `V${coords.row}:${coords.col}`)\n  return hs.concat(vs).join(\"-\")\n}\n","import { Orientation } from \"./orientation\"\nimport { Piece } from \"./piece\"\nimport { twoSidedPieces, oneSidedPieces } from \"./pieces\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { normalisedRepresentation, reflect, rotateCW, Variation } from \"./variation\"\n\nconst makeVariations = (piece: Piece, wantReflected: boolean): PieceWithVariations => {\n  const baseVariation = {\n    orientation: Orientation.North,\n    reflected: false,\n    horizontals: piece.horizontals,\n    verticals: piece.verticals,\n    junctions: piece.junctions,\n    polyLines: piece.polyLines\n  }\n\n  const north = wantReflected ? reflect(baseVariation) : baseVariation\n  const east = rotateCW(north)\n  const south = rotateCW(east)\n  const west = rotateCW(south)\n\n  const allVariations = [north, east, south, west]\n\n  const representations = new Set<string>()\n  const uniqueVariations: Variation[] = []\n  allVariations.forEach(variation => {\n    const representation = normalisedRepresentation(variation)\n    if (!representations.has(representation)) {\n      representations.add(representation)\n      uniqueVariations.push(variation)\n    }\n  })\n\n  return { label: piece.label, variations: uniqueVariations }\n}\n\nconst makeUnreflectedVariations = (piece: Piece) => makeVariations(piece, false)\nconst makeReflectedVariations = (piece: Piece) => makeVariations(piece, true)\n\nexport const piecesWithVariations: PieceWithVariations[] =\n  twoSidedPieces.map(makeUnreflectedVariations)\n    .concat(oneSidedPieces.map(makeUnreflectedVariations))\n    .concat(oneSidedPieces.map(makeReflectedVariations))\n","import { Orientation } from \"./orientation\"\nimport { Drawing } from \"./drawing\"\nimport { InternalRow } from \"./internal-row\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\n\nexport const Thumbnail = () => {\n  const solutionInternalRows = makeSolution()\n  return (\n    <Drawing\n      puzzle={{}}\n      solutionInternalRows={solutionInternalRows}\n      drawingOptions={{}}\n    />\n  )\n}\n\nexport const makeSolution = (): InternalRow[] => {\n  return [\n    makeSolutionInternalRow(\"I\", Orientation.North, false, 3, 2),\n    makeSolutionInternalRow(\"O\", Orientation.North, false, 4, 8),\n    makeSolutionInternalRow(\"T\", Orientation.North, false, 3, 5),\n    makeSolutionInternalRow(\"U\", Orientation.West, false, 2, 6),\n    makeSolutionInternalRow(\"V\", Orientation.South, false, 1, 4),\n    makeSolutionInternalRow(\"W\", Orientation.East, false, 2, 1),\n    makeSolutionInternalRow(\"X\", Orientation.North, false, 5, 2),\n\n    makeSolutionInternalRow(\"F\", Orientation.West, false, 5, 6),\n    makeSolutionInternalRow(\"H\", Orientation.South, false, 2, 4),\n    makeSolutionInternalRow(\"J\", Orientation.South, false, 0, 4),\n    makeSolutionInternalRow(\"L\", Orientation.North, false, 6, 4),\n    makeSolutionInternalRow(\"N\", Orientation.East, false, 3, 3),\n    makeSolutionInternalRow(\"P\", Orientation.North, false, 3, 7),\n    makeSolutionInternalRow(\"R\", Orientation.East, false, 3, 2),\n    makeSolutionInternalRow(\"Y\", Orientation.East, false, 1, 3),\n    makeSolutionInternalRow(\"Z\", Orientation.East, false, 6, 5),\n\n    makeSolutionInternalRow(\"F\", Orientation.South, true, 4, 1),\n    makeSolutionInternalRow(\"H\", Orientation.West, true, 7, 2),\n    makeSolutionInternalRow(\"J\", Orientation.East, true, 4, 0),\n    makeSolutionInternalRow(\"L\", Orientation.West, true, 5, 5),\n    makeSolutionInternalRow(\"N\", Orientation.North, true, 4, 5),\n    makeSolutionInternalRow(\"P\", Orientation.South, true, 5, 4),\n    makeSolutionInternalRow(\"R\", Orientation.East, true, 7, 4),\n    makeSolutionInternalRow(\"Y\", Orientation.West, true, 4, 2),\n    makeSolutionInternalRow(\"Z\", Orientation.North, true, 1, 2),\n  ]\n}\n\nconst makeSolutionInternalRow = (\n  label: string,\n  orientation: Orientation,\n  reflected: boolean,\n  row: number,\n  col: number\n): InternalRow => {\n\n  for (const pwv of piecesWithVariations) {\n    if (pwv.label === label) {\n      const variation = pwv.variations.find(v => v.orientation === orientation && v.reflected === reflected)\n      if (variation) {\n        const location = { row, col }\n        return { label, variation, location }\n      }\n    }\n  }\n  throw new Error(\"[makeSolutionInternalRow] failed to find variation\")\n}\n","import { Coords, DrawingProps, sameCoords } from \"types\"\nimport { first, last, range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\nimport { allHorizontals, allVerticals } from \"./locations\"\n\nconst VIEWBOX_WIDTH = 100\nconst VIEWBOX_HEIGHT = 100\n\nconst GRID_LINE_FULL_THICKNESS = 1\nconst TETRASTICK_FULL_THICKNESS = GRID_LINE_FULL_THICKNESS * 1.5;\nconst TETRASTICK_HALF_THICKNESS = TETRASTICK_FULL_THICKNESS / 2;\n\nconst GRID_LINE_COLOUR = \"#80808080\"\n\nconst SQUARE_WIDTH = (VIEWBOX_WIDTH - TETRASTICK_FULL_THICKNESS) / 9\nconst SQUARE_HEIGHT = (VIEWBOX_HEIGHT - TETRASTICK_FULL_THICKNESS) / 9\n\nconst calculateX = (col: number) => col * SQUARE_WIDTH + TETRASTICK_HALF_THICKNESS\nconst calculateY = (row: number) => row * SQUARE_HEIGHT + TETRASTICK_HALF_THICKNESS\n\nconst calculatePoint = (location: Coords, coords: Coords) =>\n  [calculateX(location.col + coords.col), calculateY(location.row + coords.row)]\n\nconst tetraStickColours = new Map<string, string>([\n  [\"F\", \"#FF7366\"],\n  [\"H\", \"#00E61A\"],\n  [\"I\", \"#660066\"],\n  [\"J\", \"#E6E6FF\"],\n  [\"L\", \"#596673\"],\n  [\"N\", \"#FFFF00\"],\n  [\"O\", \"#CCCC1A\"],\n  [\"P\", \"#994D33\"],\n  [\"R\", \"#9926B2\"],\n  [\"T\", \"#3300B2\"],\n  [\"U\", \"#FF2699\"],\n  [\"V\", \"#00FFFF\"],\n  [\"W\", \"#CCFF00\"],\n  [\"X\", \"#E60000\"],\n  [\"Y\", \"#6659E6\"],\n  [\"Z\", \"#008000\"]\n])\n\nexport const Drawing: React.FC<DrawingProps<Puzzle, InternalRow>> = ({\n  solutionInternalRows,\n}) => {\n\n  const drawHorizontalGridLines = (): JSX.Element[] => {\n    return allHorizontals.map(coords => {\n      const { row, col } = coords\n      const x1 = calculateX(col) + TETRASTICK_FULL_THICKNESS\n      const x2 = calculateX(col + 1) - TETRASTICK_FULL_THICKNESS\n      const y = calculateY(row)\n\n      return (\n        <line\n          key={`horizontal-grid-line-${row}-${col}`}\n          x1={x1}\n          y1={y}\n          x2={x2}\n          y2={y}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      )\n    })\n  }\n\n  const drawVerticalGridLines = (): JSX.Element[] => {\n    return allVerticals.map(coords => {\n      const { row, col } = coords\n      const x = calculateX(col)\n      const y1 = calculateY(row) + TETRASTICK_FULL_THICKNESS\n      const y2 = calculateY(row + 1) - TETRASTICK_FULL_THICKNESS\n      return (\n        <line\n          key={`vertical-grid-line-${row}-${col}`}\n          x1={x}\n          y1={y1}\n          x2={x}\n          y2={y2}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      )\n    })\n  }\n\n  const drawTetraSticks = (): JSX.Element[] => {\n    return solutionInternalRows.flatMap(drawTetraStick)\n  }\n\n  const LINE_END_MULTIPLIER = 3\n  const ROUNDED_CORNER_MULTIPLIER = 4\n\n  const insetPoint = (multiplier: number) => (coords1: Coords, coords2: Coords, point: number[]): number[] => {\n    const rowDiff = coords2.row - coords1.row\n    const colDiff = coords2.col - coords1.col\n    const verticalInset = TETRASTICK_HALF_THICKNESS * multiplier\n    const horizontalInset = TETRASTICK_HALF_THICKNESS * multiplier\n    const [x, y] = point\n    if (rowDiff === 1 && colDiff === 0) return [x, y + verticalInset]\n    if (rowDiff === -1 && colDiff === 0) return [x, y - verticalInset]\n    if (rowDiff === 0 && colDiff === 1) return [x + horizontalInset, y]\n    if (rowDiff === 0 && colDiff === -1) return [x - horizontalInset, y]\n    return point\n  }\n\n  const insetLineStart = insetPoint(LINE_END_MULTIPLIER)\n  const insetLineEnd = insetPoint(LINE_END_MULTIPLIER)\n  const insetRoundedCornerStart = insetPoint(ROUNDED_CORNER_MULTIPLIER)\n  const insetRoundedCornerEnd = insetPoint(ROUNDED_CORNER_MULTIPLIER)\n\n  // https://stackoverflow.com/a/40444735\n  // const angle = ([a,b],[c,d],[e,f]) => (Math.atan2(f-d,e-c)-Math.atan2(b-d,a-c)+3*pi)%(2*pi)-pi;\n  // const sweepFl = (S,V,E) => angle(E,S,V) > 0 ? 0 : 1;\n  const angle = (S: Coords, V: Coords, E: Coords) => {\n    const { row: b, col: a } = E\n    const { row: d, col: c } = S\n    const { row: f, col: e } = V\n    return (Math.atan2(f - d, e - c) - Math.atan2(b - d, a - c) + 3 * Math.PI) % (2 * Math.PI) - Math.PI\n  }\n\n  const moveTo = (point: number[]): string => {\n    const [x, y] = point\n    return `M${x},${y}`\n  }\n\n  const lineTo = (point: number[]): string => {\n    const [x, y] = point\n    return `L${x},${y}`\n  }\n\n  const roundedCornerTo = (S: Coords, V: Coords, E: Coords, point: number[]): string => {\n    const r = TETRASTICK_HALF_THICKNESS * ROUNDED_CORNER_MULTIPLIER\n    const largeArcFlag = 0\n    const sweepFlag = angle(S, V, E) < 0 ? 1 : 0\n    const [x, y] = point\n    return `A${r},${r},0,${largeArcFlag},${sweepFlag},${x},${y}`\n  }\n\n  const drawTetraStick = (internalRow: InternalRow): JSX.Element[] => {\n\n    const { label, variation, location } = internalRow\n    const colour = tetraStickColours.get(label)\n\n    const pathData: string[] = []\n\n    for (const polyLine of variation.polyLines) {\n      const isClosed = sameCoords(first(polyLine), last(polyLine))\n      const pathCommands: string[] = []\n\n      if (isClosed) {\n        const roundedCornerStart = insetRoundedCornerStart(polyLine[0], polyLine[1], calculatePoint(location, polyLine[0]))\n        pathCommands.push(moveTo(roundedCornerStart))\n      } else {\n        var lineStart = insetLineStart(polyLine[0], polyLine[1], calculatePoint(location, polyLine[0]))\n        pathCommands.push(moveTo(lineStart))\n      }\n\n      const indices = range(polyLine.length).slice(1).slice(0, -1)\n      for (const index of indices) {\n        const coords = polyLine[index]\n        const coordsPrev = polyLine[index - 1]\n        const coordsNext = polyLine[index + 1]\n        const point = calculatePoint(location, coords)\n\n        if (coordsPrev.row === coordsNext.row || coordsPrev.col === coordsNext.col) {\n          pathCommands.push(lineTo(point))\n        } else {\n          const roundedCornerStart = insetRoundedCornerStart(coords, coordsPrev, point)\n          pathCommands.push(lineTo(roundedCornerStart))\n\n          const roundedCornerEnd = insetRoundedCornerEnd(coords, coordsNext, point)\n          pathCommands.push(roundedCornerTo(coordsPrev, coords, coordsNext, roundedCornerEnd))\n        }\n      }\n\n      if (isClosed) {\n        const coords = polyLine[0]\n        const coordsPrev = polyLine.slice(-2)[0] // not -1 because -1 is the same coords as point 0\n        const coordsNext = polyLine[1]\n        const point = calculatePoint(location, coords)\n\n        const roundedCornerStart = insetRoundedCornerStart(coords, coordsPrev, point)\n        pathCommands.push(lineTo(roundedCornerStart))\n\n        const firstPoint = insetRoundedCornerStart(polyLine[0], polyLine[1], calculatePoint(location, coords))\n        pathCommands.push(roundedCornerTo(coordsPrev, coords, coordsNext, firstPoint))\n      } else {\n        const lineEnd = insetLineEnd(polyLine.slice(-1)[0], polyLine.slice(-2)[0], calculatePoint(location, polyLine.slice(-1)[0]))\n        pathCommands.push(lineTo(lineEnd))\n      }\n\n      pathData.push(pathCommands.join(\" \"))\n    }\n\n    const elements: JSX.Element[] = []\n\n    pathData.forEach((d, index) => {\n      const path = (\n        <path\n          key={`tetrastick-${label}-${variation.orientation}-${variation.reflected}-${index}`}\n          d={d}\n          stroke={colour}\n          strokeWidth={TETRASTICK_FULL_THICKNESS}\n          strokeLinecap=\"round\"\n          fill=\"none\"\n        />\n      )\n      elements.push(path)\n    })\n\n    return elements\n  }\n\n  return (\n    <svg viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`}>\n      {drawHorizontalGridLines()}\n      {drawVerticalGridLines()}\n      {drawTetraSticks()}\n    </svg>\n  )\n}\n","import { IDemo, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { allHorizontals, allJunctions, allVerticals } from \"./locations\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\nimport { Puzzle } from \"./puzzle\"\nimport { makeSolution as makeThumbnailSolution } from \"./thumbnail\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(_puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    return this.allPossiblePiecePlacements(5).filter(this.isValidPiecePlacement)\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow)\n    const horizontalsColumns = this.makeHorizontalsColumns(internalRow)\n    const vertialsColumns = this.makeVerticalsColumns(internalRow)\n    const junctionsColumns = this.makeJunctionsColumns(internalRow)\n    return pieceColumns\n      .concat(horizontalsColumns)\n      .concat(vertialsColumns)\n      .concat(junctionsColumns)\n  }\n\n  getNumPrimaryColumns(_puzzle: Puzzle): number | undefined {\n    const numPieces = piecesWithVariations.length\n    const numHorizontals = allHorizontals.length\n    const numVerticals = allVerticals.length\n    return numPieces + numHorizontals + numVerticals\n  }\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    const { location } = internalRow\n\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row\n      const col = location.col + horizontal.col\n      const coords = { row, col }\n      if (!allHorizontals.some(h => sameCoords(h, coords))) return false\n    }\n\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row\n      const col = location.col + vertical.col\n      const coords = { row, col }\n      if (!allVerticals.some(v => sameCoords(v, coords))) return false\n    }\n\n    return true\n  }\n\n  allPossiblePiecePlacements(numFixedPieces: number): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    const fixedInternalRows = makeThumbnailSolution().slice(0, numFixedPieces)\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const fixedInternalRow = fixedInternalRows.find(fir => (\n        fir.label === pieceWithVariations.label &&\n        fir.variation.reflected === pieceWithVariations.variations[0].reflected\n      ))\n\n      if (fixedInternalRow) {\n        internalRows.push(fixedInternalRow)\n        continue\n      }\n\n      const allLocationsInBoundingSquare =\n        range(9).flatMap(row =>\n          range(9).map(col =>\n            ({ row, col })))\n\n      for (const variation of pieceWithVariations.variations) {\n        for (const location of allLocationsInBoundingSquare) {\n          const label = pieceWithVariations.label\n          const internalRow = { label, variation, location }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0)\n    const index = piecesWithVariations.findIndex(pwv => (\n      pwv.label === internalRow.label &&\n      pwv.variations[0].reflected === internalRow.variation.reflected\n    ))\n    columns[index] = 1\n    return columns\n  }\n\n  makeHorizontalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow\n    const columns = Array(allHorizontals.length).fill(0)\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row\n      const col = location.col + horizontal.col\n      const coords = { row, col }\n      const index = allHorizontals.findIndex(h => sameCoords(h, coords))\n      if (index >= 0) {\n        columns[index] = 1\n      }\n    }\n    return columns\n  }\n\n  makeVerticalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow\n    const columns = Array(allVerticals.length).fill(0)\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row\n      const col = location.col + vertical.col\n      const coords = { row, col }\n      const index = allVerticals.findIndex(v => sameCoords(v, coords))\n      if (index >= 0) {\n        columns[index] = 1\n      }\n    }\n    return columns\n  }\n\n  makeJunctionsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow\n    const columns = Array(allJunctions.length).fill(0)\n    for (const junction of internalRow.variation.junctions) {\n      const row = location.row + junction.row\n      const col = location.col + junction.col\n      const coords = { row, col }\n      const index = allJunctions.findIndex(j => sameCoords(j, coords))\n      if (index >= 0) {\n        columns[index] = 1\n      }\n    }\n    return columns\n  }\n}\n","import { Coords, goDown, goLeft, goRight, goUp, IDemo } from \"types\"\nimport { except, range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    const internalRows: InternalRow[] = []\n\n    for (const room of puzzle.rooms) {\n      for (const initialValue of room.initialValues) {\n        const { cell, value } = initialValue\n        const isInitialValue = true\n        const internalRow = { puzzle, cell, value, isInitialValue, room }\n        internalRows.push(internalRow)\n      }\n\n      const givenCells = room.initialValues.map(({ cell }) => cell)\n      const givenValues = room.initialValues.map(({ value }) => value)\n      const cellsToSolve = except(room.cells, givenCells)\n      const values = range(room.cells.length).map(n => n + 1)\n      const valuesToSolve = except(values, givenValues)\n\n      for (const cell of cellsToSolve) {\n        for (const value of valuesToSolve) {\n          const isInitialValue = false\n          const internalRow = { puzzle, cell, value, isInitialValue, room }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const locationColumns = this.makeLocationColumns(internalRow)\n    const roomColumns = this.makeRoomColumns(internalRow)\n    const rippleColumns = this.makeRippleColumns(internalRow)\n    return locationColumns\n      .concat(roomColumns)\n      .concat(rippleColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    const { size } = puzzle\n    return size * size * 2\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size\n    const columns = Array(size * size).fill(0)\n    const { row, col } = internalRow.cell\n    const index = row * size + col\n    columns[index] = 1\n    return columns\n  }\n\n  makeRoomColumns(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size\n    const columns = Array(size * size).fill(0)\n    const index = internalRow.room.startIndex + internalRow.value - 1\n    columns[index] = 1\n    return columns\n  }\n\n  makeRippleColumns(internalRow: InternalRow): number[] {\n    const { size, maxValue } = internalRow.puzzle\n    const arrayOfArrays: number[][] = range(maxValue * 4).map(_ => Array(size * size).fill(0))\n    const baseIndex = (internalRow.value - 1) * 4\n\n    const setRippleColumnBits = (baseIndexOffset: number, transformCoords: (coords: Coords) => Coords): void => {\n      const rippleCells = this.getRippleCells(internalRow, transformCoords)\n      const array = arrayOfArrays[baseIndex + baseIndexOffset]\n      for (const cell of rippleCells) {\n        const index = cell.row * size + cell.col\n        array[index] = 1\n      }\n    }\n\n    setRippleColumnBits(0, goUp)\n    setRippleColumnBits(1, goDown)\n    setRippleColumnBits(2, goLeft)\n    setRippleColumnBits(3, goRight)\n\n    return arrayOfArrays.flat()\n  }\n\n  getRippleCells(\n    internalRow: InternalRow,\n    transformCoords: (coords: Coords) => Coords\n  ): Coords[] {\n    const size = internalRow.puzzle.size\n    let cell = internalRow.cell\n    const cells: Coords[] = [cell]\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of range(internalRow.value)) {\n      cell = transformCoords(cell)\n      const { row, col } = cell\n      if (row >= 0 && row < size && col >= 0 && col < size) {\n        cells.push({ row, col })\n      }\n    }\n\n    return cells\n  }\n}\n","import { Coords, sameCoords, goUp, goDown, goLeft, goRight } from \"types\"\nimport { range } from \"utils\"\nimport { ColourPair } from \"./colour-pair\"\nimport { Puzzle } from \"./puzzle\"\n\nexport const findPaths = (puzzle: Puzzle, colourPair: ColourPair): Coords[][] => {\n  const start = colourPair.start\n  const goal = colourPair.end\n  const currentPath = [start]\n  const paths: Coords[][] = []\n  const maxDirectionChanges = puzzle.colourPairs.length\n\n  findPathsInternal(puzzle, currentPath, paths, start, goal, maxDirectionChanges)\n\n  return paths\n}\n\n// Inspired by this: https://stackoverflow.com/a/22464491\nconst findPathsInternal = (\n  puzzle: Puzzle,\n  currentPath: Coords[],\n  paths: Coords[][],\n  node: Coords,\n  goal: Coords,\n  maxDirectionChanges: number\n): void => {\n  for (const nextNode of neighbours(puzzle, node, goal)) {\n    if (sameCoords(nextNode, goal)) {\n      const path = [...currentPath, nextNode]\n      if (countDirectionChanges(path) <= maxDirectionChanges) {\n        paths.push(path)\n      }\n    } else {\n      const index = currentPath.findIndex(p => sameCoords(p, nextNode))\n      if (index < 0) {\n        currentPath.push(nextNode)\n        if (countDirectionChanges(currentPath) <= maxDirectionChanges) {\n          findPathsInternal(puzzle, currentPath, paths, nextNode, goal, maxDirectionChanges)\n        }\n        currentPath.pop()\n      }\n    }\n  }\n}\n\nconst neighbours = (puzzle: Puzzle, node: Coords, goal: Coords): Coords[] => {\n\n  const dots = puzzle.colourPairs.flatMap(cp => [cp.start, cp.end])\n  const isDot = (n: Coords) => dots.findIndex(d => sameCoords(d, n)) >= 0\n\n  const ns = [\n    goUp(node),\n    goDown(node),\n    goLeft(node),\n    goRight(node)\n  ]\n\n  const isWithinPuzzle = (n: Coords) => (\n    n.row >= 0 && n.row < puzzle.size &&\n    n.col >= 0 && n.col < puzzle.size\n  )\n\n  const isEmptyLocationOrGoal = (n: Coords) =>\n    !isDot(n) || sameCoords(n, goal)\n\n  return ns\n    .filter(isWithinPuzzle)\n    .filter(isEmptyLocationOrGoal)\n}\n\nconst countDirectionChanges = (path: Coords[]): number => {\n  if (path.length < 3) return 0\n  let count = 0\n  for (const index of range(path.length).slice(1).slice(0, -1)) {\n    const p1 = path[index - 1]\n    const p3 = path[index + 1]\n    const rowDiff = Math.abs(p3.row - p1.row)\n    const colDiff = Math.abs(p3.col - p1.col)\n    if (rowDiff !== 0 && colDiff !== 0) count++\n  }\n  return count\n}\n","import { IDemo } from \"types\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\nimport { findPaths } from \"./path-finder\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    for (const colourPair of puzzle.colourPairs) {\n      const paths = findPaths(puzzle, colourPair)\n      for (const coordsList of paths) {\n        const internalRow = { puzzle, colourPair, coordsList }\n        internalRows.push(internalRow)\n      }\n    }\n    return internalRows\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size\n    const columns = Array(size * size).fill(0)\n    for (const coords of internalRow.coordsList) {\n      const index = coords.row * size + coords.col\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n}\n","import { sameCoordsList } from \"types\"\nimport { Coords } from \"types\"\nimport { RunType } from \"./run-type\"\n\nexport type Run = {\n  runType: RunType,\n  coordsList: Coords[],\n  sum: number\n}\n\nexport const sameRun = (run1: Run, run2: Run): boolean => {\n  return (\n    run1.runType === run2.runType &&\n    run1.sum === run2.sum &&\n    sameCoordsList(run1.coordsList, run2.coordsList)\n  )\n}\n","// https://www.chadgolden.com/blog/finding-all-the-permutations-of-an-array-in-c-sharp\n\nexport const doPermute = (nums: number[]): number[][] => {\n  const permutations: number[][] = []\n  doPermuteInternal(nums, 0, nums.length - 1, permutations)\n  return permutations\n}\n\nconst doPermuteInternal = (nums: number[], start: number, end: number, list: number[][]): void => {\n  if (start === end) {\n    list.push(nums.slice())\n  } else {\n    for (let i = start; i <= end; i++) {\n      swap(nums, start, i)\n      doPermuteInternal(nums, start + 1, end, list)\n      swap(nums, start, i)\n    }\n  }\n}\n\nconst swap = (nums: number[], index1: number, index2: number): void => {\n  const temp = nums[index1]\n  nums[index1] = nums[index2]\n  nums[index2] = temp\n}\n","export enum RunGroupType {\n  Horizontal,\n  Vertical\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { except, range, sum } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Run, sameRun } from \"./run\"\nimport { Puzzle } from \"./puzzle\"\nimport { RunType } from \"./run-type\"\nimport { doPermute } from \"./permutations\"\n\nconst DIGITS = range(9).map(n => n + 1)\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    const internalRows: InternalRow[] = []\n\n    const createInternalRowsFor = (runs: Run[]): void => {\n      for (const run of runs) {\n        for (const setOfValues of this.findSetsOfValues(run)) {\n          for (const values of doPermute(setOfValues)) {\n            const internalRow = { puzzle, run, values }\n            internalRows.push(internalRow)\n          }\n        }\n      }\n    }\n\n    createInternalRowsFor(puzzle.horizontalRuns)\n    createInternalRowsFor(puzzle.verticalRuns)\n\n    return internalRows\n  }\n\n  // Return sets of values where each set of values:\n  // - has length run.CoordsList.Length\n  // - sums to run.Sum\n  // - contains only values 1..9\n  // - does not have any duplicated values\n  // e.g. for run length 3 and sum 10, valid sets of values would be [1,4,5], [2,3,5], [1,3,6], etc\n  findSetsOfValues(run: Run): number[][] {\n    const setsOfValues: number[][] = []\n\n    const helper = (n: number, useds: number[][], setOfValues: number[]): void => {\n      const remainingDigits = except(DIGITS, useds.flat())\n      const used: number[] = []\n      useds.push(used)\n      for (const digit of remainingDigits) {\n        setOfValues.push(digit)\n        used.push(digit)\n        if (n > 1) {\n          helper(n - 1, useds, setOfValues)\n        } else {\n          if (sum(setOfValues) === run.sum) {\n            setsOfValues.push(setOfValues.slice())\n          }\n        }\n        setOfValues.pop()\n      }\n      useds.pop()\n    }\n\n    const runLength = run.coordsList.length\n    helper(runLength, [], []);\n\n    return setsOfValues\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, run, values } = internalRow\n    const horizontalRunColumns = this.makeHorizontalRunColumns(puzzle, run)\n    const verticalRunColumns = this.makeVerticalRunColumns(puzzle, run)\n    const horizontalRunValueColumns = this.makeHorizontalRunValueColumns(puzzle, run, values)\n    const verticalRunValueColumns = this.makeVerticalRunValueColumns(puzzle, run, values)\n    return horizontalRunColumns\n      .concat(verticalRunColumns)\n      .concat(horizontalRunValueColumns)\n      .concat(verticalRunValueColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRuns.length + puzzle.verticalRuns.length\n  }\n\n  makeHorizontalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.horizontalRuns.length).fill(0)\n    if (run.runType === RunType.Horizontal) {\n      const index = this.findHorizontalRunIndex(puzzle, run)\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  makeVerticalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.verticalRuns.length).fill(0)\n    if (run.runType === RunType.Vertical) {\n      const index = this.findVerticalRunIndex(puzzle, run)\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  makeHorizontalRunValueColumns(puzzle: Puzzle, run: Run, values: number[]): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0)\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index]\n      const encodedValue = run.runType === RunType.Horizontal\n        ? this.encodeValueNormal(value)\n        : this.encodeValueInverse(value)\n      const unknown = run.coordsList[index]\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown)\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] = encodedValue[encodedValueIndex]\n      }\n    }\n    return columns\n  }\n\n  makeVerticalRunValueColumns(puzzle: Puzzle, run: Run, values: number[]): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0)\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index]\n      const encodedValue = run.runType === RunType.Vertical\n        ? this.encodeValueNormal(value)\n        : this.encodeValueInverse(value)\n      const unknown = run.coordsList[index]\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown)\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] = encodedValue[encodedValueIndex]\n      }\n    }\n    return columns\n  }\n\n  encodeValueNormal(value: number): number[] {\n    const columns = Array(9).fill(0)\n    const index = value - 1\n    columns[index] = 1\n    return columns\n  }\n\n  encodeValueInverse(value: number): number[] {\n    const columns = Array(9).fill(1)\n    const index = value - 1\n    columns[index] = 0\n    return columns\n  }\n\n  findHorizontalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.horizontalRuns.findIndex(r => sameRun(r, run))\n  }\n\n  findVerticalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.verticalRuns.findIndex(r => sameRun(r, run))\n  }\n\n  findUnknownIndex(puzzle: Puzzle, unknown: Coords): number {\n    return puzzle.unknowns.findIndex(u => sameCoords(u, unknown))\n  }\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { except, range, sum } from \"utils\"\nimport { Puzzle } from \"./puzzle\"\nimport { InternalRow } from \"./internal-row\"\nimport { RunGroup } from \"./run-group\"\nimport { RunGroupType } from \"./run-group-type\"\nimport { HorizontalRunGroup } from \"./horizontal-run-group\"\nimport { VerticalRunGroup } from \"./vertical-run-group\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n\n    type StartingPositionData = {\n      startingPosition: number,\n      runLength: number\n    }\n\n    const size = puzzle.size\n    const internalRows: InternalRow[] = []\n\n    const buildInternalRowsForRunGroup = (runGroup: RunGroup): void => {\n      const workingSetOfStartingPositions: StartingPositionData[] = []\n\n      const recursivelyFindSetsOfStartingPositions = (startPosition: number, remainingLengths: number[]): void => {\n\n        if (internalRows.length % 1000 === 0) {\n          if (checkForCancellation()) return\n        }\n\n        if (remainingLengths.length === 0) {\n          if (workingSetOfStartingPositions.length === runGroup.lengths.length) {\n            const setOfStartingPositions = workingSetOfStartingPositions.slice().reverse()\n            const coordsLists: Coords[][] = []\n            for (const startingPositionData of setOfStartingPositions) {\n              const coordsList: Coords[] = []\n              for (const startingPosition of range(startingPositionData.runLength).map(x => x + startingPositionData.startingPosition)) {\n                const coords = this.makeRunGroupCoords(runGroup, startingPosition)\n                coordsList.push(coords)\n              }\n              coordsLists.push(coordsList)\n            }\n            const internalRow = { puzzle, runGroup, coordsLists }\n            internalRows.push(internalRow)\n          }\n          return\n        }\n\n        const runLength = remainingLengths[0]\n        const newRemainingLengths = remainingLengths.slice(1)\n        const sumOfRemainingLengths = sum(newRemainingLengths)\n        const requiredGaps = newRemainingLengths.length\n        const lastValidStartPosition = size - sumOfRemainingLengths - requiredGaps - runLength\n        const numValidStartPositions = lastValidStartPosition - startPosition + 1\n        const validStartPositions = range(numValidStartPositions).map(x => x + startPosition)\n\n        for (const validStartPosition of validStartPositions) {\n          const pair = { startingPosition: validStartPosition, runLength }\n          workingSetOfStartingPositions.push(pair)\n\n          const newStartPosition = validStartPosition + runLength + 1\n          recursivelyFindSetsOfStartingPositions(newStartPosition, newRemainingLengths)\n\n          workingSetOfStartingPositions.pop()\n        }\n      }\n\n      recursivelyFindSetsOfStartingPositions(0, runGroup.lengths)\n    }\n\n    for (const horizontalRunGroup of puzzle.horizontalRunGroups) {\n      buildInternalRowsForRunGroup(horizontalRunGroup)\n    }\n\n    for (const verticalRunGroup of puzzle.verticalRunGroups) {\n      buildInternalRowsForRunGroup(verticalRunGroup)\n    }\n\n    return internalRows\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRunGroups.length + puzzle.verticalRunGroups.length\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, runGroup, coordsLists } = internalRow\n    const rowColumns = this.makeRowColumns(puzzle, runGroup)\n    const colColumns = this.makeColColumns(puzzle, runGroup)\n    const horizontalBlockColumns = this.makeBlockColumns(puzzle, RunGroupType.Horizontal, runGroup, coordsLists)\n    const verticalBlockColumns = this.makeBlockColumns(puzzle, RunGroupType.Vertical, runGroup, coordsLists)\n    return rowColumns\n      .concat(colColumns)\n      .concat(horizontalBlockColumns)\n      .concat(verticalBlockColumns)\n  }\n\n  makeRowColumns(puzzle: Puzzle, runGroup: RunGroup): number[] {\n    const columns = Array(puzzle.horizontalRunGroups.length).fill(0)\n    if (runGroup.runGroupType === RunGroupType.Horizontal) {\n      const horizontalRunGroup = runGroup as HorizontalRunGroup\n      columns[horizontalRunGroup.row] = 1\n    }\n    return columns\n  }\n\n  makeColColumns(puzzle: Puzzle, runGroup: RunGroup): number[] {\n    const columns = Array(puzzle.verticalRunGroups.length).fill(0)\n    if (runGroup.runGroupType === RunGroupType.Vertical) {\n      const verticalRunGroup = runGroup as VerticalRunGroup\n      columns[verticalRunGroup.col] = 1\n    }\n    return columns\n  }\n\n  makeBlockColumns(\n    puzzle: Puzzle,\n    runGroupType: RunGroupType,\n    runGroup: RunGroup,\n    coordsLists: Coords[][]\n  ): number[] {\n    const size = puzzle.size\n    const columns = Array(size * size * 2).fill(0)\n    const selectedBlockCoords = coordsLists.flat()\n\n    if (runGroup.runGroupType === runGroupType) {\n      const allBlockCoords = range(size).map(otherValue => this.makeRunGroupCoords(runGroup, otherValue))\n      const unselectedBlockCoords = except(allBlockCoords, selectedBlockCoords, sameCoords)\n      for (const coords of selectedBlockCoords) {\n        this.markOn(columns, size, coords)\n      }\n      for (const coords of unselectedBlockCoords) {\n        this.markOff(columns, size, coords)\n      }\n    } else {\n      for (const coords of selectedBlockCoords) {\n        this.markOff(columns, size, coords)\n      }\n    }\n\n    return columns\n  }\n\n  private static ON_INDEX = 0\n  private static OFF_INDEX = 1\n\n  markOn(columns: number[], size: number, coords: Coords): void {\n    const baseIndex = (coords.row * size + coords.col) * 2\n    columns[baseIndex + Demo.ON_INDEX] = 1\n  }\n\n  markOff(columns: number[], size: number, coords: Coords): void {\n    var baseIndex = (coords.row * size + coords.col) * 2\n    columns[baseIndex + Demo.OFF_INDEX] = 1\n  }\n\n  makeRunGroupCoords(runGroup: RunGroup, otherValue: number): Coords {\n    if (runGroup.runGroupType === RunGroupType.Horizontal) {\n      const horizontalRunGroup = runGroup as HorizontalRunGroup\n      return { row: horizontalRunGroup.row, col: otherValue }\n    }\n    if (runGroup.runGroupType === RunGroupType.Vertical) {\n      const verticalRunGroup = runGroup as VerticalRunGroup\n      return { row: otherValue, col: verticalRunGroup.col }\n    }\n    throw new Error(\"[makeRunGroupCoords] unknown RunGroupType\")\n  }\n}\n","export enum ClueType { Across, Down }\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { ClueType } from \"./clue-type\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle, checkForCancellation: () => boolean): InternalRow[] {\n    const internalRows: InternalRow[] = []\n\n    for (const clue of puzzle.clues) {\n      for (const candidate of clue.candidates) {\n        const internalRow = { puzzle, clue, candidate }\n        internalRows.push(internalRow)\n      }\n    }\n\n    return internalRows\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    return this.makeColumns(internalRow)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n\n  makeColumns(internalRow: InternalRow): number[] {\n    const crossCheckingSquares = internalRow.puzzle.crossCheckingSquares\n    const clue = internalRow.clue\n    const columns = Array(crossCheckingSquares.length * 26).fill(0)\n\n    const findCrossCheckingSquareIndex = (coords: Coords): number => {\n      return crossCheckingSquares.findIndex(crossCheckingSquare =>\n        sameCoords(crossCheckingSquare, coords))\n    }\n\n    for (const index of range(clue.coordsList.length)) {\n      const coords = clue.coordsList[index]\n      const crossCheckingSquareIndex = findCrossCheckingSquareIndex(coords)\n      if (crossCheckingSquareIndex >= 0) {\n        const letter = internalRow.candidate[index]\n        const encodedLetterColumns = this.encodeLetter(letter, clue.clueType)\n        const baseIndex = crossCheckingSquareIndex * 26\n        for (const encodedLetterIndex of range(encodedLetterColumns.length)) {\n          columns[baseIndex + encodedLetterIndex] = encodedLetterColumns[encodedLetterIndex]\n        }\n      }\n    }\n\n    return columns\n  }\n\n  encodeLetter(letter: string, clueType: ClueType): number[] {\n    const upperLetter = letter.toLocaleUpperCase()\n    const index = upperLetter.codePointAt(0)! - \"A\".codePointAt(0)!\n    const [onValue, offValue] = clueType === ClueType.Across ? [1, 0] : [0, 1]\n    const columns = Array(26).fill(offValue)\n    columns[index] = onValue\n    return columns\n  }\n}\n","// To fix: Unexpected use of 'self'.\n/* eslint-disable no-restricted-globals */\n\nimport * as dlxlib from \"dlxlib/dlx\"\nimport { Mode, IDemo } from \"types\"\nimport { checkStopToken } from \"./stop-token\"\nimport { timeIt } from \"./time-it\"\n\nimport { Demo as SudokuDemo } from \"demos/sudoku/demo\"\nimport { Demo as PentominoesDemo } from \"demos/pentominoes/demo\"\nimport { Demo as DraughtboardPuzzleDemo } from \"demos/draughtboard-puzzle/demo\"\nimport { Demo as NQueensDemo } from \"demos/n-queens/demo\"\nimport { Demo as TetraSticksDemo } from \"demos/tetrasticks/demo\"\nimport { Demo as AztecDiamondDemo } from \"demos/aztec-diamond/demo\"\nimport { Demo as RippleEffectDemo } from \"demos/ripple-effect/demo\"\nimport { Demo as FlowFreeDemo } from \"demos/flow-free/demo\"\nimport { Demo as KakuroDemo } from \"demos/kakuro/demo\"\nimport { Demo as NonogramDemo } from \"demos/nonogram/demo\"\nimport { Demo as CrosswordDemo } from \"demos/crossword/demo\"\n\ntype DemoConstructor = new () => IDemo<unknown, unknown>\n\nconst map = new Map<string, DemoConstructor>([\n  [\"sudoku\", SudokuDemo],\n  [\"pentominoes\", PentominoesDemo],\n  [\"draughtboard-puzzle\", DraughtboardPuzzleDemo],\n  [\"n-queens\", NQueensDemo],\n  [\"tetrasticks\", TetraSticksDemo],\n  [\"aztec-diamond\", AztecDiamondDemo],\n  [\"ripple-effect\", RippleEffectDemo],\n  [\"flow-free\", FlowFreeDemo],\n  [\"kakuro\", KakuroDemo],\n  [\"nonogram\", NonogramDemo],\n  [\"crossword\", CrosswordDemo]\n])\n\n// To fix: 'worker.ts' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module.ts(1208)\nexport { }\n\ntype SearchStepEvent = {\n  partialSolution: number[],\n  stepIndex: number\n}\n\ntype SolutionFoundEvent = {\n  solution: number[],\n  solutionIndex: number\n}\n\nconst onSolve = (stopToken: string, shortName: string, puzzle: any, mode: Mode) => {\n\n  const checkForCancellation = (sendMessage: boolean = false) => {\n    const cancelled = checkStopToken(stopToken)\n    if (cancelled && sendMessage) {\n      console.log(\"[worker onSolve]\", \"cancelled!\")\n      self.postMessage({ type: \"cancelled\" })\n    }\n    return cancelled\n  }\n\n  console.log(\"[worker onSolve]\")\n  const demoConstructor = map.get(shortName)\n  if (!demoConstructor) {\n    self.postMessage({ type: \"error\", message: `unknown demo short name, \"${shortName}\"` })\n    return\n  }\n\n  const demo = new demoConstructor()\n\n  console.log(\"[worker onSolve]\", \"building internal rows...\")\n  const internalRows = timeIt(\"build internal rows\", () => demo.buildInternalRows(puzzle, checkForCancellation))\n  console.log(\"[worker onSolve]\", \"internalRows.length:\", internalRows.length)\n  if (checkForCancellation(true)) return\n\n  console.log(\"[worker onSolve]\", \"building matrix...\")\n  const matrix = timeIt(\"build matrix\", () => {\n    const matrix: Uint8Array[] = []\n    for (let index = 0; index < internalRows.length; index++) {\n      if (index % 1000 === 0) {\n        if (checkForCancellation()) {\n          break\n        }\n      }\n      const internalRow = internalRows[index]\n      const matrixRow = demo.internalRowToMatrixRow(internalRow)\n      matrix.push(Uint8Array.from(matrixRow))\n    }\n    return matrix\n  })\n  const rowCount = matrix.length\n  const colCount = matrix[0]?.length ?? 0\n  console.log(\"[worker onSolve]\", \"matrix size:\", `${rowCount}x${colCount}`)\n  if (checkForCancellation(true)) return\n\n  const numSolutions = 1\n  const numPrimaryColumns = demo.getNumPrimaryColumns(puzzle)\n\n  console.log(\"[worker onSolve]\", \"numPrimaryColumns:\", numPrimaryColumns)\n\n  const options: dlxlib.Options = {\n    numSolutions,\n    numPrimaryColumns,\n    checkForCancellation\n  }\n\n  let searchStepCount = 0\n\n  const onStep = (event: SearchStepEvent) => {\n    searchStepCount++\n    if (searchStepCount % 100 === 0) {\n      console.log(\"[worker onStep]\", \"searchStepCount:\", searchStepCount)\n    }\n    if (mode === Mode.SearchSteps) {\n      const partialSolution = event.partialSolution\n      const solutionInternalRows = partialSolution.map(index => internalRows[index])\n      self.postMessage({ type: \"searchStep\", solutionInternalRows })\n    }\n  }\n\n  const onSolution = (event: SolutionFoundEvent) => {\n    console.log(\"[worker onSolution]\", \"solutionIndex:\", event.solutionIndex, \"row count:\", event.solution.length)\n    const solution = event.solution\n    const solutionInternalRows = solution.map(index => internalRows[index])\n    self.postMessage({ type: \"solutionFound\", solutionInternalRows })\n  }\n\n  const dlx = new dlxlib.Dlx()\n  dlx.addListener(\"step\", onStep)\n  dlx.addListener(\"solution\", onSolution)\n\n  console.log(\"[worker onSolve]\", \"solving matrix...\")\n  const solutions = timeIt(\"solve matrix\", () => dlx.solve(matrix, options))\n  console.log(\"[worker onSolve]\", \"searchStepCount:\", searchStepCount)\n  console.log(\"[worker onSolve]\", \"solutions.length:\", solutions.length)\n  if (checkForCancellation(true)) return\n\n  self.postMessage({ type: \"finished\", numSolutionsFound: solutions.length })\n}\n\nself.onmessage = (ev: MessageEvent<any>) => {\n  try {\n    console.log(\"[worker onmessage]\", \"ev.data.type:\", ev.data.type)\n    if (ev.data.type === \"solve\") {\n      const stopToken = ev.data.stopToken as string\n      const shortName = ev.data.shortName as string\n      const mode = ev.data.mode as Mode\n      const { puzzle } = ev.data\n      timeIt(\"onSolve\", () => onSolve(stopToken, shortName, puzzle, mode))\n      return\n    }\n\n    if (ev.data.type === \"close\") {\n      self.close()\n      return\n    }\n  } catch (error) {\n    console.error(\"error:\", error)\n    if (error instanceof Error) {\n      self.postMessage({ type: \"error\", message: error.message })\n    } else {\n      self.postMessage({ type: \"error\", message: String(error) })\n    }\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [625], function() { return __webpack_require__(1907); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"b56eb7ce\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/dlxlib-demos/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t907: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdlxlib_demos\"] = self[\"webpackChunkdlxlib_demos\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(625).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DataObject","listHeader","rowIndex","up","down","left","right","this","addDataObject","dataObject","fn","loop","propName","next","ColumnObject","previousColumnObject","nextColumnObject","numberOfRows","columnObject","appendToColumn","unlinkFromColumn","relinkIntoColumn","search","Dlx","checkOptions","options","undefined","numSolutions","Number","isInteger","Error","numPrimaryColumns","matrix","MAX_SAFE_INTEGER","solutions","iterator","solutionGenerator","index","iteratorResult","done","push","value","root","buildInternalStructure","searchState","SearchState","EventEmitter","length","colIndexToListHeader","Map","cancelled","forEach","row","checkForCancellation","firstDataObjectInThisRow","col","colIndex","appendColumnHeader","set","get","appendToRow","byAscendingRowIndices","rowIndex1","rowIndex2","checkForCancellationFrequency","getStepIndex","raiseSearchStepEvent","isEmpty","currentSolution","raiseSolutionFoundEvent","slice","sort","c","chooseColumnWithFewestRows","coverColumn","r","pushRowIndex","loopRight","j","loopLeft","uncoverColumn","popRowIndex","chosenColumn","loopNext","column","unlinkColumnHeader","loopDown","i","unlinkDataObject","loopUp","relinkDataObject","relinkColumnHeader","dlx","stepIndex","solutionIndex","pop","listenerCount","e","partialSolution","emit","solution","range","n","Array","from","keys","sum","ns","reduce","acc","maxBy","xs","selector","map","Math","max","defaultSameness","x1","x2","except","xs1","xs2","isSame","filter","some","CurrentState","Mode","reverseString","s","reverse","join","goUp","coords","goDown","goLeft","goRight","sameCoords","coords1","coords2","coordsComparer","rowDiff","colDiff","checkStopToken","stopToken","xhr","XMLHttpRequest","open","send","timeIt","label","startTime","performance","now","result","elapsedTimeS","console","log","toLocaleString","Orientation","Demo","puzzle","flatMap","initialValue","initialValues","find","iv","_buildInternalRowsForInitialValue","_buildInternalRowsForCoords","isInitialValue","internalRow","box","_rowColToBox","zeroBasedValue","posColumns","_oneHot","rowColumns","colColumns","boxColumns","concat","major","minor","columns","fill","floor","Colour","rotateCW","pattern","rowCount","colCount","rowIndices","transposed","reflect","toCoordsList","coordsList","piecesMap","pieces","reflectVariationCandidate","vc","reflected","makeVariation","orientation","piecesWithVariations","piece","north","North","northReflected","east","East","eastReflected","south","South","southReflected","west","West","allVariationCandidates","representations","Set","uniqueVariationCandidates","representation","has","add","variations","allLocations","allPossiblePiecePlacements","isValidPiecePlacement","pieceColumns","makePieceColumns","locationColumns","makeLocationColumns","variation","location","internalRows","fixedPieceLabels","pieceWithVariations","includes","findIndex","pwv","indices","indicesToExclude","_","toSquares","squares","colour","Black","White","square","size","diagonalColumnCount","diagonal1Columns","diagonal2Columns","diagonal1","diagonal2","lineSegments","polyLines","parsePolyLineDescriptions","polyLineDescriptions","split","trim","Boolean","parsePolyLineDescription","polyLineDescription","coordsString","lineSegmentDescriptions","horizontals","verticals","junctions","bits","bit","type","parsePiece","getDimensions","width","h","height","v","newHorizontals","newVerticals","newJunctions","newPolyLines","polyLine","rotateOrientationCW","allVariations","uniqueVariations","sortedHorizontals","sortedVerticals","hs","vs","normalisedRepresentation","horizontalsColumns","makeHorizontalsColumns","vertialsColumns","makeVerticalsColumns","junctionsColumns","makeJunctionsColumns","numPieces","pieceToOmit","horizontal","vertical","piecesInPlay","getPiecesInPlay","pip","junction","allHorizontals","centreRelativeRow","centreRelativeCol","abs","allVerticals","allJunctions","h1","h2","RunType","twoSidedPiecesMap","oneSidedPiecesMap","twoSidedPieces","oneSidedPieces","makeVariations","wantReflected","baseVariation","makeUnreflectedVariations","makeSolution","makeSolutionInternalRow","_puzzle","numFixedPieces","fixedInternalRows","makeThumbnailSolution","fixedInternalRow","fir","allLocationsInBoundingSquare","rooms","room","cell","givenCells","givenValues","cellsToSolve","cells","valuesToSolve","roomColumns","makeRoomColumns","rippleColumns","makeRippleColumns","startIndex","maxValue","arrayOfArrays","baseIndex","setRippleColumnBits","baseIndexOffset","transformCoords","rippleCells","getRippleCells","array","flat","findPaths","colourPair","start","goal","end","currentPath","paths","maxDirectionChanges","colourPairs","findPathsInternal","node","nextNode","path","countDirectionChanges","p","neighbours","dots","cp","d","isDot","count","p1","p3","sameRun","run1","run2","runType","coordsList1","coordsList2","sameCoordsList","RunGroupType","doPermute","nums","permutations","doPermuteInternal","list","swap","index1","index2","temp","DIGITS","createInternalRowsFor","runs","run","findSetsOfValues","setOfValues","values","horizontalRuns","verticalRuns","setsOfValues","helper","useds","remainingDigits","used","digit","horizontalRunColumns","makeHorizontalRunColumns","verticalRunColumns","makeVerticalRunColumns","horizontalRunValueColumns","makeHorizontalRunValueColumns","verticalRunValueColumns","makeVerticalRunValueColumns","Horizontal","findHorizontalRunIndex","Vertical","findVerticalRunIndex","unknowns","encodedValue","encodeValueNormal","encodeValueInverse","unknown","unknownIndex","findUnknownIndex","encodedValueIndex","u","ClueType","buildInternalRowsForRunGroup","runGroup","workingSetOfStartingPositions","recursivelyFindSetsOfStartingPositions","startPosition","remainingLengths","runLength","newRemainingLengths","sumOfRemainingLengths","requiredGaps","validStartPositions","x","validStartPosition","pair","startingPosition","lengths","setOfStartingPositions","coordsLists","startingPositionData","makeRunGroupCoords","horizontalRunGroups","verticalRunGroups","makeRowColumns","makeColColumns","horizontalBlockColumns","makeBlockColumns","verticalBlockColumns","runGroupType","selectedBlockCoords","unselectedBlockCoords","otherValue","markOn","markOff","ON_INDEX","OFF_INDEX","clues","clue","candidates","candidate","makeColumns","crossCheckingSquares","findCrossCheckingSquareIndex","crossCheckingSquare","crossCheckingSquareIndex","letter","encodedLetterColumns","encodeLetter","clueType","encodedLetterIndex","toLocaleUpperCase","codePointAt","Across","onValue","offValue","SudokuDemo","PentominoesDemo","DraughtboardPuzzleDemo","NQueensDemo","TetraSticksDemo","AztecDiamondDemo","RippleEffectDemo","FlowFreeDemo","KakuroDemo","NonogramDemo","CrosswordDemo","self","onmessage","ev","data","shortName","mode","sendMessage","postMessage","demoConstructor","demo","buildInternalRows","matrixRow","internalRowToMatrixRow","Uint8Array","getNumPrimaryColumns","searchStepCount","dlxlib","addListener","event","SearchSteps","solutionInternalRows","solve","numSolutionsFound","message","onSolve","close","error","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","Infinity","fulfilled","Object","every","key","splice","getter","__esModule","a","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","promises","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}