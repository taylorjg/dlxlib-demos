{"version":3,"file":"static/js/803.ee4f278b.chunk.js","mappings":"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","sources":["dlxlib/dataObject.ts","dlxlib/columnObject.ts","dlxlib/dlx.ts","utils.ts","types.ts","demos/sudoku/demo.ts","demos/pentominoes/orientation.ts","demos/pentominoes/pattern.ts","demos/draughtboard-puzzle/colour.ts","demos/draughtboard-puzzle/orientation.ts","demos/pentominoes/pieces.ts","demos/pentominoes/pieces-with-variations.ts","demos/pentominoes/demo.ts","demos/draughtboard-puzzle/pattern.ts","demos/kakuro/run-type.ts","demos/draughtboard-puzzle/pieces.ts","demos/draughtboard-puzzle/pieces-with-variations.ts","demos/draughtboard-puzzle/demo.ts","demos/n-queens/demo.ts","demos/flow-free/path-finder.ts","demos/flow-free/demo.ts","demos/kakuro/run.ts","demos/kakuro/permutations.ts","demos/nonogram/run-group-type.ts","demos/kakuro/demo.ts","demos/nonogram/demo.ts","demos/crossword/clue-type.ts","demos/crossword/demo.ts","worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { ColumnObject } from \"./columnObject\"\n\nexport class DataObject {\n\n  public up: DataObject\n  public down: DataObject\n  public left: DataObject\n  public right: DataObject\n\n  public constructor(public listHeader?: ColumnObject, public rowIndex?: number) {\n    this.up = this\n    this.down = this\n    this.left = this\n    this.right = this\n    listHeader?.addDataObject(this)\n  }\n\n  public appendToRow(dataObject: DataObject) {\n    this.left.right = dataObject\n    dataObject.right = this\n    dataObject.left = this.left\n    this.left = dataObject\n  }\n\n  public appendToColumn(dataObject: DataObject) {\n    this.up.down = dataObject\n    dataObject.down = this\n    dataObject.up = this.up\n    this.up = dataObject\n  }\n\n  public unlinkFromColumn() {\n    this.down.up = this.up\n    this.up.down = this.down\n  }\n\n  public relinkIntoColumn() {\n    this.down.up = this\n    this.up.down = this\n  }\n\n  public loopUp(fn: (dataObject: DataObject) => void) { this.loop(fn, \"up\") }\n  public loopDown(fn: (dataObject: DataObject) => void) { this.loop(fn, \"down\") }\n  public loopLeft(fn: (dataObject: DataObject) => void) { this.loop(fn, \"left\") }\n  public loopRight(fn: (dataObject: DataObject) => void) { this.loop(fn, \"right\") }\n\n  private loop(\n    fn: (dataObject: DataObject) => void,\n    propName: \"up\" | \"down\" | \"left\" | \"right\"\n  ) {\n    for (let next = this[propName]; next !== this; next = next[propName]) {\n      fn(next)\n    }\n  }\n}\n","import { DataObject } from \"./dataObject\"\n\nexport class ColumnObject extends DataObject {\n\n  public previousColumnObject: ColumnObject\n  public nextColumnObject: ColumnObject\n  public numberOfRows: number\n\n  public constructor() {\n    super()\n    this.previousColumnObject = this\n    this.nextColumnObject = this\n    this.numberOfRows = 0\n  }\n\n  public appendColumnHeader(columnObject: ColumnObject) {\n    this.previousColumnObject.nextColumnObject = columnObject\n    columnObject.nextColumnObject = this\n    columnObject.previousColumnObject = this.previousColumnObject\n    this.previousColumnObject = columnObject\n  }\n\n  public unlinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this.previousColumnObject\n    this.previousColumnObject.nextColumnObject = this.nextColumnObject\n  }\n\n  public relinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this\n    this.previousColumnObject.nextColumnObject = this\n  }\n\n  public addDataObject(dataObject: DataObject) {\n    this.appendToColumn(dataObject)\n    this.numberOfRows++\n  }\n\n  public unlinkDataObject(dataObject: DataObject) {\n    dataObject.unlinkFromColumn()\n    this.numberOfRows--\n  }\n\n  public relinkDataObject(dataObject: DataObject) {\n    dataObject.relinkIntoColumn()\n    this.numberOfRows++\n  }\n\n  public loopNext(fn: (columnObject: ColumnObject) => void) {\n    for (let next = this.nextColumnObject; next !== this; next = next.nextColumnObject) {\n      fn(next)\n    }\n  }\n}\n","import EventEmitter from \"events\"\nimport { DataObject } from \"./dataObject\"\nimport { ColumnObject } from \"./columnObject\"\n\nexport type MatrixValue = any\nexport type MatrixRow = MatrixValue[]\nexport type Matrix = MatrixRow[]\n\nexport type Solution = number[]\nexport type PartialSolution = number[]\n\nexport type Options = {\n  numSolutions?: number\n  numPrimaryColumns?: number\n}\n\nexport function solve(matrix: Matrix, options: Options) {\n  return new Dlx().solve(matrix, options)\n}\n\nexport class Dlx extends EventEmitter {\n\n  public constructor() {\n    super()\n  }\n\n  public solve(matrix: Matrix, options?: Options): Solution[] {\n    this.checkOptions(options)\n    const numSolutions = options?.numSolutions ?? Number.MAX_SAFE_INTEGER\n    const solutions = []\n    const iterator = this.solutionGenerator(matrix, options)\n    for (let index = 0; index < numSolutions; index++) {\n      const iteratorResult = iterator.next()\n      if (iteratorResult.done) break\n      solutions.push(iteratorResult.value)\n    }\n    return solutions\n  }\n\n  public * solutionGenerator(matrix: Matrix, options?: Options): Generator<Solution> {\n    this.checkOptions(options)\n    const root = buildInternalStructure(matrix, options)\n    const searchState = new SearchState(this, root)\n    yield* search(searchState)\n  }\n\n  private checkOptions = (options?: Options): void => {\n    if (options?.numSolutions !== undefined) {\n      if (!Number.isInteger(options.numSolutions)) {\n        throw new Error(\"options.numSolutions must be an integer\")\n      }\n      if (options.numSolutions < 0) {\n        throw new Error(\"options.numSolutions can't be negative - don't be silly\")\n      }\n    }\n\n    if (options?.numPrimaryColumns !== undefined) {\n      if (!Number.isInteger(options.numPrimaryColumns)) {\n        throw new Error(\"options.numPrimaryColumns must be an integer\")\n      }\n      if (options.numPrimaryColumns < 0) {\n        throw new Error(\"options.numPrimaryColumns can't be negative - don't be silly\")\n      }\n    }\n  }\n}\n\nconst buildInternalStructure = (matrix: Matrix, options?: Options) => {\n\n  const numPrimaryColumns = options?.numPrimaryColumns ?? matrix[0].length\n\n  const root = new ColumnObject()\n  const colIndexToListHeader = new Map()\n\n  matrix.forEach((row: MatrixRow, rowIndex: number) => {\n    let firstDataObjectInThisRow: DataObject | undefined = undefined\n    row.forEach((col, colIndex: number) => {\n      if (rowIndex === 0) {\n        const listHeader = new ColumnObject()\n        if (colIndex < numPrimaryColumns) {\n          root.appendColumnHeader(listHeader)\n        }\n        colIndexToListHeader.set(colIndex, listHeader)\n      }\n      if (col) {\n        const listHeader = colIndexToListHeader.get(colIndex)\n        const dataObject = new DataObject(listHeader, rowIndex)\n        if (firstDataObjectInThisRow)\n          firstDataObjectInThisRow.appendToRow(dataObject)\n        else\n          firstDataObjectInThisRow = dataObject\n      }\n    })\n  })\n\n  return root\n}\n\nconst byAscendingRowIndices = (rowIndex1: number, rowIndex2: number) =>\n  rowIndex1 - rowIndex2\n\nfunction* search(searchState: SearchState): Generator<Solution> {\n\n  searchState.raiseSearchStepEvent()\n\n  if (searchState.isEmpty()) {\n    if (searchState.currentSolution.length) {\n      searchState.raiseSolutionFoundEvent()\n      yield searchState.currentSolution.slice().sort(byAscendingRowIndices)\n    }\n    return\n  }\n\n  const c = chooseColumnWithFewestRows(searchState)\n  coverColumn(c)\n  for (let r = c.down; r !== c; r = r.down) {\n    searchState.pushRowIndex(r.rowIndex!)\n    r.loopRight(j => coverColumn(j.listHeader!))\n    yield* search(searchState)\n    r.loopLeft(j => uncoverColumn(j.listHeader!))\n    searchState.popRowIndex()\n  }\n  uncoverColumn(c)\n}\n\nconst chooseColumnWithFewestRows = (searchState: SearchState) => {\n  let chosenColumn: ColumnObject | undefined = undefined\n  searchState.root.loopNext(column => {\n    if (!chosenColumn || column.numberOfRows < chosenColumn.numberOfRows) {\n      chosenColumn = column\n    }\n  })\n  return chosenColumn!\n}\n\nconst coverColumn = (c: ColumnObject) => {\n  c.unlinkColumnHeader()\n  c.loopDown(i => i.loopRight(j => j.listHeader!.unlinkDataObject(j)))\n}\n\nconst uncoverColumn = (c: ColumnObject) => {\n  c.loopUp(i => i.loopLeft(j => j.listHeader!.relinkDataObject(j)))\n  c.relinkColumnHeader()\n}\n\nclass SearchState {\n\n  public currentSolution: number[] = []\n  private stepIndex: number = 0\n  private solutionIndex: number = 0\n\n  public constructor(private dlx: Dlx, public root: ColumnObject) {\n  }\n\n  public isEmpty() {\n    return this.root.nextColumnObject === this.root\n  }\n\n  public pushRowIndex(rowIndex: number) {\n    this.currentSolution.push(rowIndex)\n  }\n\n  public popRowIndex() {\n    this.currentSolution.pop()\n  }\n\n  public raiseSearchStepEvent() {\n    if (this.dlx.listenerCount(\"step\") > 0 && this.currentSolution.length) {\n      const partialSolution: PartialSolution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices)\n      const e = {\n        partialSolution,\n        stepIndex: this.stepIndex++\n      }\n      this.dlx.emit(\"step\", e)\n    }\n  }\n\n  public raiseSolutionFoundEvent() {\n    if (this.dlx.listenerCount(\"solution\") > 0) {\n      const solution: Solution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices)\n      const e = {\n        solution,\n        solutionIndex: this.solutionIndex++\n      }\n      this.dlx.emit(\"solution\", e)\n    }\n  }\n}\n","export const range = (n: number) => Array.from(Array(n).keys())\nexport const sum = (ns: number[]): number => ns.reduce((acc, n) => acc + n, 0)\nexport const min = (ns: number[]): number => Math.min(...ns)\nexport const max = (ns: number[]): number => Math.max(...ns)\nexport function minBy<T>(xs: T[], selector: (x: T) => number): number { return min(xs.map(selector)) }\nexport function maxBy<T>(xs: T[], selector: (x: T) => number): number { return max(xs.map(selector)) }\nexport function first<T>(xs: T[]) { return xs[0] }\nexport function last<T>(xs: T[]) { return xs[xs.length - 1] }\n\nfunction defaultSameness<T>(x1: T, x2: T): boolean { return x1 === x2 }\n\nexport function except<T>(xs1: T[], xs2: T[], isSame: (x1: T, x2: T) => boolean = defaultSameness): T[] {\n  return xs1.filter(x1 => !xs2.some(x2 => isSame(x1, x2)))\n}\n\nexport function union<T>(xs1: T[], xs2: T[], isSame: (x1: T, x2: T) => boolean = defaultSameness): T[] {\n  return [...xs1].concat(xs2.filter(x2 => !xs1.some(x1 => isSame(x1, x2))))\n}\n\nexport function intersect<T>(xs1: T[], xs2: T[], isSame: (x1: T, x2: T) => boolean = defaultSameness): T[] {\n  const firstsInSecond = xs1.filter(x1 => xs2.some(x2 => isSame(x1, x2)))\n  const secondsInFirst = xs2.filter(x2 => xs1.some(x1 => isSame(x1, x2)))\n  return union(firstsInSecond, secondsInFirst, isSame)\n}\n\nexport const reverseString = (s: string): string => Array.from(s).reverse().join(\"\")\n","import { range } from \"utils\"\n\nexport type AvailableDemo = {\n  name: string,\n  shortName: string,\n  Thumbnail: React.FC,\n  hideBorder: boolean\n}\n\nexport type DrawingProps<TPuzzle, TInternalRow, TDrawingOptions = {}> = {\n  puzzle: TPuzzle,\n  solutionInternalRows: TInternalRow[],\n  drawingOptions: TDrawingOptions\n}\n\nexport type DemoControlsProps<TPuzzle, TDrawingOptions = {}> = {\n  selectedPuzzle: TPuzzle,\n  drawingOptions: TDrawingOptions,\n  onSelectedPuzzleChanged: (puzzle: TPuzzle) => void,\n  onDrawingOptionsChanged: (drawingOptions: TDrawingOptions) => void\n}\n\nexport interface IDemo<TPuzzle, TInternalRow> {\n  buildInternalRows(puzzle: TPuzzle): TInternalRow[]\n  internalRowToMatrixRow(internalRow: TInternalRow): number[]\n  getNumPrimaryColumns(puzzle: TPuzzle): number | undefined\n}\n\nexport type Coords = {\n  row: number,\n  col: number\n}\n\nexport const goUp = (coords: Coords): Coords => ({ row: coords.row - 1, col: coords.col })\nexport const goDown = (coords: Coords): Coords => ({ row: coords.row + 1, col: coords.col })\nexport const goLeft = (coords: Coords): Coords => ({ row: coords.row, col: coords.col - 1 })\nexport const goRight = (coords: Coords): Coords => ({ row: coords.row, col: coords.col + 1 })\n\nexport const sameCoords = (coords1: Coords, coords2: Coords): boolean =>\n  coords1.row === coords2.row && coords1.col === coords2.col\n\nexport const sameCoordsList = (coordsList1: Coords[], coordsList2: Coords[]): boolean => {\n  if (coordsList1.length !== coordsList2.length) return false\n  for (const index of range(coordsList1.length)) {\n    const coords1 = coordsList1[index]\n    const coords2 = coordsList2[index]\n    if (!sameCoords(coords1, coords2)) return false\n  }\n  return true\n}\n\nexport const coordsComparer = (coords1: Coords, coords2: Coords): number => {\n  const rowDiff = coords1.row - coords2.row\n  const colDiff = coords1.col - coords2.col\n  return rowDiff !== 0 ? rowDiff : colDiff\n}\n\nexport enum CurrentState {\n  Clean,\n  Solving,\n  Dirty\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { InitialValue } from \"./initial-value\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const allCoords = range(9).flatMap(row => range(9).map(col => ({ row, col })))\n    return allCoords.flatMap(coords => {\n      const initialValue = puzzle.initialValues.find(iv => sameCoords(iv.coords, coords))\n      return initialValue\n        ? this._buildInternalRowsForInitialValue(initialValue)\n        : this._buildInternalRowsForCoords(coords)\n    })\n  }\n\n  _buildInternalRowsForInitialValue(initialValue: InitialValue): InternalRow[] {\n    return [{ ...initialValue, isInitialValue: true }]\n  }\n\n  _buildInternalRowsForCoords(coords: Coords): InternalRow[] {\n    return range(9).map(n => n + 1).map(value => ({\n      coords,\n      value,\n      isInitialValue: false\n    }))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords\n    const box = this._rowColToBox(row, col);\n    const zeroBasedValue = internalRow.value - 1\n    const posColumns = this._oneHot(row, col);\n    const rowColumns = this._oneHot(row, zeroBasedValue);\n    const colColumns = this._oneHot(col, zeroBasedValue);\n    const boxColumns = this._oneHot(box, zeroBasedValue);\n    return posColumns\n      .concat(rowColumns)\n      .concat(colColumns)\n      .concat(boxColumns)\n  }\n\n  _oneHot(major: number, minor: number): number[] {\n    const columns = Array(81).fill(0)\n    columns[major * 9 + minor] = 1\n    return columns\n  }\n\n  _rowColToBox(row: number, col: number): number {\n    return Math.floor(row - (row % 3) + (col / 3))\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n}\n","export enum Orientation { North, South, East, West }\n","import { Coords } from \"types\"\nimport { range, reverseString } from \"utils\"\n\nexport const rotateCW = (pattern: string[]): string[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const rowIndices = range(rowCount)\n  const colIndices = range(colCount)\n  const transposed = colIndices.map(col => rowIndices.map(row => pattern[row][col]).join(\"\"))\n  return reflect(transposed)\n}\n\nexport const reflect = (pattern: string[]): string[] => {\n  return pattern.map(reverseString)\n}\n\nexport const toCoordsList = (pattern: string[]): Coords[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const coordsList: Coords[] = []\n\n  for (const row of range(rowCount)) {\n    for (const col of range(colCount)) {\n      if (pattern[row][col] === \"X\") {\n        const coords = { row, col }\n        coordsList.push(coords)\n      }\n    }\n  }\n\n  return coordsList\n}\n","export enum Colour { Black, White }\n","export enum Orientation { North, South, East, West }\n","import { Piece } from \"./piece\"\n\n// https://en.wikipedia.org/wiki/Pentomino\nconst piecesMap = new Map<string, string[]>([\n  [\n    \"F\",\n    [\n      \" XX\",\n      \"XX \",\n      \" X \"\n    ]\n  ],\n  [\n    \"I\",\n    [\n      \"X\",\n      \"X\",\n      \"X\",\n      \"X\",\n      \"X\"\n    ]\n  ],\n  [\n    \"L\",\n    [\n      \"X \",\n      \"X \",\n      \"X \",\n      \"XX\"\n    ]\n  ],\n  [\n    \"N\",\n    [\n      \" X\",\n      \" X\",\n      \"XX\",\n      \"X \"\n    ]\n  ],\n  [\n    \"P\",\n    [\n      \"XX\",\n      \"XX\",\n      \"X \"\n    ]\n  ],\n  [\n    \"T\",\n    [\n      \"XXX\",\n      \" X \",\n      \" X \"\n    ]\n  ],\n  [\n    \"U\",\n    [\n      \"X X\",\n      \"XXX\"\n    ]\n  ],\n  [\n    \"V\",\n    [\n      \"X  \",\n      \"X  \",\n      \"XXX\"\n    ]\n  ],\n  [\n    \"W\",\n    [\n      \"X  \",\n      \"XX \",\n      \" XX\"\n    ]\n  ],\n  [\n    \"X\",\n    [\n      \" X \",\n      \"XXX\",\n      \" X \"\n    ]\n  ],\n  [\n    \"Y\",\n    [\n      \" X\",\n      \"XX\",\n      \" X\",\n      \" X\"\n    ]\n  ],\n  [\n    \"Z\",\n    [\n      \"XX \",\n      \" X \",\n      \" XX\"\n    ]\n  ],\n])\n\nexport const pieces: Piece[] =\n  Array.from(piecesMap)\n    .map(([label, pattern]) => ({ label, pattern }))\n","import { Orientation } from \"./orientation\"\nimport { reflect, rotateCW, toCoordsList } from \"./pattern\"\nimport { Piece } from \"./piece\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { pieces } from \"./pieces\"\nimport { Variation } from \"./variation\"\n\ntype VariationCandidate = {\n  orientation: Orientation,\n  reflected: boolean,\n  pattern: string[]\n}\n\nconst reflectVariationCandidate = (vc: VariationCandidate): VariationCandidate => {\n  return {\n    ...vc,\n    reflected: true,\n    pattern: reflect(vc.pattern)\n  }\n}\n\nconst makeVariation = (vc: VariationCandidate): Variation => ({\n  orientation: vc.orientation,\n  reflected: vc.reflected,\n  coordsList: toCoordsList(vc.pattern)\n})\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const { label, pattern } = piece\n\n  const north = { orientation: Orientation.North, reflected: false, pattern }\n  const northReflected = reflectVariationCandidate(north)\n\n  const east = { orientation: Orientation.East, reflected: false, pattern: rotateCW(north.pattern) }\n  const eastReflected = reflectVariationCandidate(east)\n\n  const south = { orientation: Orientation.South, reflected: false, pattern: rotateCW(east.pattern) }\n  const southReflected = reflectVariationCandidate(south)\n\n  const west = { orientation: Orientation.West, reflected: false, pattern: rotateCW(south.pattern) }\n  const westReflected = reflectVariationCandidate(west)\n\n  const allVariationCandidates = [\n    north, northReflected,\n    east, eastReflected,\n    south, southReflected,\n    west, westReflected\n  ]\n\n  const representations = new Set<string>()\n  const uniqueVariationCandidates: VariationCandidate[] = []\n  for (const vc of allVariationCandidates) {\n    const representation = vc.pattern.join(\"|\")\n    if (!representations.has(representation)) {\n      representations.add(representation)\n      uniqueVariationCandidates.push(vc)\n    }\n  }\n\n  const variations = uniqueVariationCandidates.map(makeVariation)\n\n  return { label, variations }\n}\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations)\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\n\nexport class Demo implements IDemo<{}, InternalRow> {\n\n  buildInternalRows(puzzle: {}): InternalRow[] {\n    return this.allPossiblePiecePlacements()\n      .filter(internalRow => this.isValidPiecePlacement(internalRow))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow)\n    const locationColumns = this.makeLocationColumns(internalRow)\n    return pieceColumns.concat(locationColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: {}): number | undefined {\n    return undefined\n  }\n\n  allLocations =\n    range(8).flatMap(row =>\n      range(8).map(col =>\n        ({ row, col })))\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    for (const coords of internalRow.variation.coordsList) {\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      if (row >= 8 || col >= 8) return false\n      if ((row === 3 || row === 4) && (col === 3 || col === 4)) return false\n    }\n    return true\n  }\n\n  allPossiblePiecePlacements(): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    const fixedPiecesLabels = piecesWithVariations.slice(0, 1).map(({ label }) => label)\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const variations = fixedPiecesLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label\n          const internalRow = { label, variation, location }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0)\n    const pieceIndex = piecesWithVariations.findIndex(pwv => pwv.label === internalRow.label)\n    columns[pieceIndex] = 1\n    return columns\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const indices = internalRow.variation.coordsList.map(coords => {\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      return row * 8 + col\n    })\n\n    const columns = Array(8 * 8).fill(0)\n\n    for (const index of indices) {\n      columns[index] = 1\n    }\n\n    const indicesToExclude = [\n      3 * 8 + 3,\n      3 * 8 + 4,\n      4 * 8 + 3,\n      4 * 8 + 4\n    ]\n\n    return columns.filter((_, index) => !indicesToExclude.includes(index))\n  }\n}\n","import { range, reverseString } from \"utils\"\nimport { Colour } from \"./colour\"\nimport { Square } from \"./square\"\n\nexport const rotateCW = (pattern: string[]): string[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const rowIndices = range(rowCount)\n  const colIndices = range(colCount)\n  const transposed = colIndices.map(col => rowIndices.map(row => pattern[row][col]).join(\"\"))\n  return reflect(transposed)\n}\n\nexport const reflect = (pattern: string[]): string[] => {\n  return pattern.map(reverseString)\n}\n\nexport const toSquares = (pattern: string[]): Square[] => {\n  const rowCount = pattern.length\n  const colCount = pattern[0].length\n  const squares: Square[] = []\n\n  for (const row of range(rowCount)) {\n    for (const col of range(colCount)) {\n      const coords = { row, col }\n      switch (pattern[row][col]) {\n        case \"B\":\n          squares.push({coords, colour: Colour.Black})\n          break\n        case \"W\":\n          squares.push({coords, colour: Colour.White})\n          break\n      }\n    }\n  }\n\n  return squares\n}\n","export enum RunType {\n  Horizontal,\n  Vertical\n}\n","import { Piece } from \"./piece\"\n\nconst piecesMap = new Map<string, string[]>([\n  [\n    \"A\",\n    [\n      \"B \",\n      \"WB\",\n      \"B \",\n      \"W \"\n    ]\n  ],\n  [\n    \"B\",\n    [\n      \"B  \",\n      \"WBW\"\n    ],\n  ],\n  [\n    \"C\",\n    [\n      \"W \",\n      \"BW\"\n    ]\n  ],\n  [\n    \"D\",\n    [\n      \" WB\",\n      \" B \",\n      \"BW \"\n    ]\n  ],\n  [\n    \"E\",\n    [\n      \"W \",\n      \"BW\",\n      \" B\",\n      \" W\"\n    ]\n  ],\n  [\n    \"F\",\n    [\n      \"WB \",\n      \" W \",\n      \" BW\"\n    ]\n  ],\n  [\n    \"G\",\n    [\n      \"WB \",\n      \" WB\"\n    ]\n  ],\n  [\n    \"H\",\n    [\n      \"B \",\n      \"WB\",\n      \"B \"\n    ]\n  ],\n  [\n    \"I\",\n    [\n      \"B \",\n      \"W \",\n      \"BW\",\n      \"W \"\n    ]\n  ],\n  [\n    \"J\",\n    [\n      \" B\",\n      \" W\",\n      \" B\",\n      \"BW\"\n    ]\n  ],\n  [\n    \"K\",\n    [\n      \"  W\",\n      \" WB\",\n      \"WB \"\n    ]\n  ],\n  [\n    \"L\",\n    [\n      \"B \",\n      \"W \",\n      \"BW\"\n    ]\n  ],\n  [\n    \"M\",\n    [\n      \" B\",\n      \" W\",\n      \"WB\",\n      \"B \"\n    ]\n  ],\n  [\n    \"N\",\n    [\n      \"W \",\n      \"B \",\n      \"W \",\n      \"BW\"\n    ]\n  ]\n])\n\nexport const pieces: Piece[] =\n  Array.from(piecesMap)\n    .map(([label, pattern]) => ({ label, pattern }))\n","import { Orientation } from \"./orientation\"\nimport { rotateCW, toSquares } from \"./pattern\"\nimport { Piece } from \"./piece\"\nimport { PieceWithVariations } from \"./piece-with-variations\"\nimport { pieces } from \"./pieces\"\nimport { Variation } from \"./variation\"\n\ntype VariationCandidate = {\n  orientation: Orientation,\n  pattern: string[]\n}\n\nconst makeVariation = (vc: VariationCandidate): Variation => ({\n  orientation: vc.orientation,\n  squares: toSquares(vc.pattern)\n})\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const { label, pattern } = piece\n\n  const north = { orientation: Orientation.North, pattern }\n  const east = { orientation: Orientation.East, pattern: rotateCW(north.pattern) }\n  const south = { orientation: Orientation.South, pattern: rotateCW(east.pattern) }\n  const west = { orientation: Orientation.West, pattern: rotateCW(south.pattern) }\n\n  const allVariationCandidates = [north, east, south, west]\n\n  const representations = new Set<string>()\n  const uniqueVariationCandidates: VariationCandidate[] = []\n  for (const vc of allVariationCandidates) {\n    const representation = vc.pattern.join(\"|\")\n    if (!representations.has(representation)) {\n      representations.add(representation)\n      uniqueVariationCandidates.push(vc)\n    }\n  }\n\n  const variations = uniqueVariationCandidates.map(makeVariation)\n\n  return { label, variations }\n}\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations)\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { Colour } from \"./colour\"\nimport { InternalRow } from \"./internal-row\"\nimport { piecesWithVariations } from \"./pieces-with-variations\"\n\nexport class Demo implements IDemo<{}, InternalRow> {\n\n  buildInternalRows(puzzle: {}): InternalRow[] {\n    return this.allPossiblePiecePlacements()\n      .filter(internalRow => this.isValidPiecePlacement(internalRow))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow)\n    const locationColumns = this.makeLocationColumns(internalRow)\n    return pieceColumns.concat(locationColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: {}): number | undefined {\n    return undefined\n  }\n\n  allLocations =\n    range(8).flatMap(row =>\n      range(8).map(col =>\n        ({ row, col })))\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    for (const square of internalRow.variation.squares) {\n      const { coords, colour } = square\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      if (row < 0 || row >= 8) return false\n      if (col < 0 || col >= 8) return false\n      const requiredColour = (row + col) % 2 !== 0 ? Colour.White : Colour.Black\n      if (colour !== requiredColour) return false\n    }\n    return true\n  }\n\n  allPossiblePiecePlacements(): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    const fixedPiecesLabels = piecesWithVariations.slice(0, 1).map(({ label }) => label)\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const variations = fixedPiecesLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label\n          const internalRow = { label, variation, location }\n          internalRows.push(internalRow)\n        }\n      }\n    }\n\n    return internalRows\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0)\n    const pieceIndex = piecesWithVariations.findIndex(pwv => pwv.label === internalRow.label)\n    columns[pieceIndex] = 1\n    return columns\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const indices = internalRow.variation.squares.map(square => {\n      const { coords } = square\n      const row = internalRow.location.row + coords.row\n      const col = internalRow.location.col + coords.col\n      return row * 8 + col\n    })\n\n    const columns = Array(8 * 8).fill(0)\n\n    for (const index of indices) {\n      columns[index] = 1\n    }\n\n    return columns\n  }\n}\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { Puzzle } from \"./puzzle\"\nimport { InternalRow } from \"./internal-row\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const allLocations = range(puzzle.size).flatMap(row =>\n      range(puzzle.size).map(col =>\n        ({ row, col })))\n    return allLocations.map(coords => ({ puzzle, coords }))\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.size * 2\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords\n    const size = internalRow.puzzle.size\n    const diagonalColumnCount = size + size - 3\n\n    const rowColumns = Array(size).fill(0)\n    const colColumns = Array(size).fill(0)\n    const diagonal1Columns = Array(diagonalColumnCount).fill(0)\n    const diagonal2Columns = Array(diagonalColumnCount).fill(0)\n\n    rowColumns[row] = 1\n    colColumns[col] = 1\n\n    const diagonal1 = row + col - 1\n    if (diagonal1 >= 0 && diagonal1 < diagonalColumnCount) diagonal1Columns[diagonal1] = 1\n\n    const diagonal2 = size - 1 - col + row - 1\n    if (diagonal2 >= 0 && diagonal2 < diagonalColumnCount) diagonal2Columns[diagonal2] = 1\n\n    return rowColumns\n      .concat(colColumns)\n      .concat(diagonal1Columns)\n      .concat(diagonal2Columns)\n  }\n}\n","import { Coords, sameCoords, goUp, goDown, goLeft, goRight } from \"types\"\nimport { range } from \"utils\"\nimport { ColourPair } from \"./colour-pair\"\nimport { Puzzle } from \"./puzzle\"\n\nexport const findPaths = (puzzle: Puzzle, colourPair: ColourPair): Coords[][] => {\n  const start = colourPair.start\n  const goal = colourPair.end\n  const currentPath = [start]\n  const paths: Coords[][] = []\n  const maxDirectionChanges = puzzle.colourPairs.length\n\n  findPathsInternal(puzzle, currentPath, paths, start, goal, maxDirectionChanges)\n\n  return paths\n}\n\n// Inspired by this: https://stackoverflow.com/a/22464491\nconst findPathsInternal = (\n  puzzle: Puzzle,\n  currentPath: Coords[],\n  paths: Coords[][],\n  node: Coords,\n  goal: Coords,\n  maxDirectionChanges: number\n): void => {\n  for (const nextNode of neighbours(puzzle, node, goal)) {\n    if (sameCoords(nextNode, goal)) {\n      const path = [...currentPath, nextNode]\n      if (countDirectionChanges(path) <= maxDirectionChanges) {\n        paths.push(path)\n      }\n    } else {\n      const index = currentPath.findIndex(p => sameCoords(p, nextNode))\n      if (index < 0) {\n        currentPath.push(nextNode)\n        if (countDirectionChanges(currentPath) <= maxDirectionChanges) {\n          findPathsInternal(puzzle, currentPath, paths, nextNode, goal, maxDirectionChanges)\n        }\n        currentPath.pop()\n      }\n    }\n  }\n}\n\nconst neighbours = (puzzle: Puzzle, node: Coords, goal: Coords): Coords[] => {\n\n  const dots = puzzle.colourPairs.flatMap(cp => [cp.start, cp.end])\n  const isDot = (n: Coords) => dots.findIndex(d => sameCoords(d, n)) >= 0\n\n  const ns = [\n    goUp(node),\n    goDown(node),\n    goLeft(node),\n    goRight(node)\n  ]\n\n  const isWithinPuzzle = (n: Coords) => (\n    n.row >= 0 && n.row < puzzle.size &&\n    n.col >= 0 && n.col < puzzle.size\n  )\n\n  const isEmptyLocationOrGoal = (n: Coords) =>\n    !isDot(n) || sameCoords(n, goal)\n\n  return ns\n    .filter(isWithinPuzzle)\n    .filter(isEmptyLocationOrGoal)\n}\n\nconst countDirectionChanges = (path: Coords[]): number => {\n  if (path.length < 3) return 0\n  let count = 0\n  for (const index of range(path.length).slice(1).slice(0, -1)) {\n    const p1 = path[index - 1]\n    const p3 = path[index + 1]\n    const rowDiff = Math.abs(p3.row - p1.row)\n    const colDiff = Math.abs(p3.col - p1.col)\n    if (rowDiff !== 0 && colDiff !== 0) count++\n  }\n  return count\n}\n","import { IDemo } from \"types\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\nimport { findPaths } from \"./path-finder\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    for (const colourPair of puzzle.colourPairs) {\n      const paths = findPaths(puzzle, colourPair)\n      for (const coordsList of paths) {\n        const internalRow = { puzzle, colourPair, coordsList }\n        internalRows.push(internalRow)\n      }\n    }\n    return internalRows\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size\n    const columns = Array(size * size).fill(0)\n    for (const coords of internalRow.coordsList) {\n      const index = coords.row * size + coords.col\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n}\n","import { sameCoordsList } from \"types\"\nimport { Coords } from \"types\"\nimport { RunType } from \"./run-type\"\n\nexport type Run = {\n  runType: RunType,\n  coordsList: Coords[],\n  sum: number\n}\n\nexport const sameRun = (run1: Run, run2: Run): boolean => {\n  return (\n    run1.runType === run2.runType &&\n    run1.sum === run2.sum &&\n    sameCoordsList(run1.coordsList, run2.coordsList)\n  )\n}\n","// https://www.chadgolden.com/blog/finding-all-the-permutations-of-an-array-in-c-sharp\n\nexport const doPermute = (nums: number[]): number[][] => {\n  const permutations: number[][] = []\n  doPermuteInternal(nums, 0, nums.length - 1, permutations)\n  return permutations\n}\n\nconst doPermuteInternal = (nums: number[], start: number, end: number, list: number[][]): void => {\n  if (start === end) {\n    list.push(nums.slice())\n  } else {\n    for (let i = start; i <= end; i++) {\n      swap(nums, start, i)\n      doPermuteInternal(nums, start + 1, end, list)\n      swap(nums, start, i)\n    }\n  }\n}\n\nconst swap = (nums: number[], index1: number, index2: number): void => {\n  const temp = nums[index1]\n  nums[index1] = nums[index2]\n  nums[index2] = temp\n}\n","export enum RunGroupType {\n  Horizontal,\n  Vertical\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { except, range, sum } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Run, sameRun } from \"./run\"\nimport { Puzzle } from \"./puzzle\"\nimport { RunType } from \"./run-type\"\nimport { doPermute } from \"./permutations\"\n\nconst DIGITS = range(9).map(n => n + 1)\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = []\n\n    const createInternalRowsFor = (runs: Run[]): void => {\n      for (const run of runs) {\n        for (const setOfValues of this.findSetsOfValues(run)) {\n          for (const values of doPermute(setOfValues)) {\n            const internalRow = { puzzle, run, values }\n            internalRows.push(internalRow)\n          }\n        }\n      }\n    }\n\n    createInternalRowsFor(puzzle.horizontalRuns)\n    createInternalRowsFor(puzzle.verticalRuns)\n\n    return internalRows\n  }\n\n  // Return sets of values where each set of values:\n  // - has length run.CoordsList.Length\n  // - sums to run.Sum\n  // - contains only values 1..9\n  // - does not have any duplicated values\n  // e.g. for run length 3 and sum 10, valid sets of values would be [1,4,5], [2,3,5], [1,3,6], etc\n  findSetsOfValues(run: Run): number[][] {\n    const setsOfValues: number[][] = []\n\n    const helper = (n: number, useds: number[][], setOfValues: number[]): void => {\n      const remainingDigits = except(DIGITS, useds.flat())\n      const used: number[] = []\n      useds.push(used)\n      for (const digit of remainingDigits) {\n        setOfValues.push(digit)\n        used.push(digit)\n        if (n > 1) {\n          helper(n - 1, useds, setOfValues)\n        } else {\n          if (sum(setOfValues) === run.sum) {\n            setsOfValues.push(setOfValues.slice())\n          }\n        }\n        setOfValues.pop()\n      }\n      useds.pop()\n    }\n\n    const runLength = run.coordsList.length\n    helper(runLength, [], []);\n\n    return setsOfValues\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, run, values } = internalRow\n    const horizontalRunColumns = this.makeHorizontalRunColumns(puzzle, run)\n    const verticalRunColumns = this.makeVerticalRunColumns(puzzle, run)\n    const horizontalRunValueColumns = this.makeHorizontalRunValueColumns(puzzle, run, values)\n    const verticalRunValueColumns = this.makeVerticalRunValueColumns(puzzle, run, values)\n    return horizontalRunColumns\n      .concat(verticalRunColumns)\n      .concat(horizontalRunValueColumns)\n      .concat(verticalRunValueColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRuns.length + puzzle.verticalRuns.length\n  }\n\n  makeHorizontalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.horizontalRuns.length).fill(0)\n    if (run.runType === RunType.Horizontal) {\n      const index = this.findHorizontalRunIndex(puzzle, run)\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  makeVerticalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.verticalRuns.length).fill(0)\n    if (run.runType === RunType.Vertical) {\n      const index = this.findVerticalRunIndex(puzzle, run)\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  makeHorizontalRunValueColumns(puzzle: Puzzle, run: Run, values: number[]): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0)\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index]\n      const encodedValue = run.runType === RunType.Horizontal\n        ? this.encodeValueNormal(value)\n        : this.encodeValueInverse(value)\n      const unknown = run.coordsList[index]\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown)\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] = encodedValue[encodedValueIndex]\n      }\n    }\n    return columns\n  }\n\n  makeVerticalRunValueColumns(puzzle: Puzzle, run: Run, values: number[]): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0)\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index]\n      const encodedValue = run.runType === RunType.Vertical\n        ? this.encodeValueNormal(value)\n        : this.encodeValueInverse(value)\n      const unknown = run.coordsList[index]\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown)\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] = encodedValue[encodedValueIndex]\n      }\n    }\n    return columns\n  }\n\n  encodeValueNormal(value: number): number[] {\n    const columns = Array(9).fill(0)\n    const index = value - 1\n    columns[index] = 1\n    return columns\n  }\n\n  encodeValueInverse(value: number): number[] {\n    const columns = Array(9).fill(1)\n    const index = value - 1\n    columns[index] = 0\n    return columns\n  }\n\n  findHorizontalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.horizontalRuns.findIndex(r => sameRun(r, run))\n  }\n\n  findVerticalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.verticalRuns.findIndex(r => sameRun(r, run))\n  }\n\n  findUnknownIndex(puzzle: Puzzle, unknown: Coords): number {\n    return puzzle.unknowns.findIndex(u => sameCoords(u, unknown))\n  }\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { except, range, sum } from \"utils\"\nimport { Puzzle } from \"./puzzle\"\nimport { InternalRow } from \"./internal-row\"\nimport { RunGroup } from \"./run-group\"\nimport { RunGroupType } from \"./run-group-type\"\nimport { HorizontalRunGroup } from \"./horizontal-run-group\"\nimport { VerticalRunGroup } from \"./vertical-run-group\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n\n    type StartingPositionData = {\n      startingPosition: number,\n      runLength: number\n    }\n\n    const size = puzzle.size\n    const internalRows: InternalRow[] = []\n\n    const buildInternalRowsForRunGroup = (runGroup: RunGroup): void => {\n      const workingSetOfStartingPositions: StartingPositionData[] = []\n\n      const recursivelyFindSetsOfStartingPositions = (startPosition: number, remainingLengths: number[]): void => {\n        if (remainingLengths.length === 0) {\n          if (workingSetOfStartingPositions.length === runGroup.lengths.length) {\n            const setOfStartingPositions = workingSetOfStartingPositions.slice().reverse()\n            const coordsLists: Coords[][] = []\n            for (const startingPositionData of setOfStartingPositions) {\n              const coordsList: Coords[] = []\n              for (const startingPosition of range(startingPositionData.runLength).map(x => x + startingPositionData.startingPosition)) {\n                const coords = this.makeRunGroupCoords(runGroup, startingPosition)\n                coordsList.push(coords)\n              }\n              coordsLists.push(coordsList)\n            }\n            const internalRow = { puzzle, runGroup, coordsLists }\n            internalRows.push(internalRow)\n          }\n          return\n        }\n\n        const runLength = remainingLengths[0]\n        const newRemainingLengths = remainingLengths.slice(1)\n        const sumOfRemainingLengths = sum(newRemainingLengths)\n        const requiredGaps = newRemainingLengths.length\n        const lastValidStartPosition = size - sumOfRemainingLengths - requiredGaps - runLength\n        const numValidStartPositions = lastValidStartPosition - startPosition + 1\n        const validStartPositions = range(numValidStartPositions).map(x => x + startPosition)\n\n        for (const validStartPosition of validStartPositions) {\n          const pair = { startingPosition: validStartPosition, runLength }\n          workingSetOfStartingPositions.push(pair)\n\n          const newStartPosition = validStartPosition + runLength + 1\n          recursivelyFindSetsOfStartingPositions(newStartPosition, newRemainingLengths)\n\n          workingSetOfStartingPositions.pop()\n        }\n      }\n\n      recursivelyFindSetsOfStartingPositions(0, runGroup.lengths)\n    }\n\n    for (const horizontalRunGroup of puzzle.horizontalRunGroups) {\n      buildInternalRowsForRunGroup(horizontalRunGroup)\n    }\n\n    for (const verticalRunGroup of puzzle.verticalRunGroups) {\n      buildInternalRowsForRunGroup(verticalRunGroup)\n    }\n\n    return internalRows\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRunGroups.length + puzzle.verticalRunGroups.length\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, runGroup, coordsLists } = internalRow\n    const rowColumns = this.makeRowColumns(puzzle, runGroup)\n    const colColumns = this.makeColColumns(puzzle, runGroup)\n    const horizontalBlockColumns = this.makeBlockColumns(puzzle, RunGroupType.Horizontal, runGroup, coordsLists)\n    const verticalBlockColumns = this.makeBlockColumns(puzzle, RunGroupType.Vertical, runGroup, coordsLists)\n    return rowColumns\n      .concat(colColumns)\n      .concat(horizontalBlockColumns)\n      .concat(verticalBlockColumns)\n  }\n\n  makeRowColumns(puzzle: Puzzle, runGroup: RunGroup): number[] {\n    const columns = Array(puzzle.horizontalRunGroups.length).fill(0)\n    if (runGroup.runGroupType === RunGroupType.Horizontal) {\n      const horizontalRunGroup = runGroup as HorizontalRunGroup\n      columns[horizontalRunGroup.row] = 1\n    }\n    return columns\n  }\n\n  makeColColumns(puzzle: Puzzle, runGroup: RunGroup): number[] {\n    const columns = Array(puzzle.verticalRunGroups.length).fill(0)\n    if (runGroup.runGroupType === RunGroupType.Vertical) {\n      const verticalRunGroup = runGroup as VerticalRunGroup\n      columns[verticalRunGroup.col] = 1\n    }\n    return columns\n  }\n\n  makeBlockColumns(\n    puzzle: Puzzle,\n    runGroupType: RunGroupType,\n    runGroup: RunGroup,\n    coordsLists: Coords[][]\n  ): number[] {\n    const size = puzzle.size\n    const columns = Array(size * size * 2).fill(0)\n    const selectedBlockCoords = coordsLists.flat()\n\n    if (runGroup.runGroupType === runGroupType) {\n      const allBlockCoords = range(size).map(otherValue => this.makeRunGroupCoords(runGroup, otherValue))\n      const unselectedBlockCoords = except(allBlockCoords, selectedBlockCoords, sameCoords)\n      for (const coords of selectedBlockCoords) {\n        this.markOn(columns, size, coords)\n      }\n      for (const coords of unselectedBlockCoords) {\n        this.markOff(columns, size, coords)\n      }\n    } else {\n      for (const coords of selectedBlockCoords) {\n        this.markOff(columns, size, coords)\n      }\n    }\n\n    return columns\n  }\n\n  private static ON_INDEX = 0\n  private static OFF_INDEX = 1\n\n  markOn(columns: number[], size: number, coords: Coords): void {\n    const baseIndex = (coords.row * size + coords.col) * 2\n    columns[baseIndex + Demo.ON_INDEX] = 1\n  }\n\n  markOff(columns: number[], size: number, coords: Coords): void {\n    var baseIndex = (coords.row * size + coords.col) * 2\n    columns[baseIndex + Demo.OFF_INDEX] = 1\n  }\n\n  makeRunGroupCoords(runGroup: RunGroup, otherValue: number): Coords {\n    if (runGroup.runGroupType === RunGroupType.Horizontal) {\n      const horizontalRunGroup = runGroup as HorizontalRunGroup\n      return { row: horizontalRunGroup.row, col: otherValue }\n    }\n    if (runGroup.runGroupType === RunGroupType.Vertical) {\n      const verticalRunGroup = runGroup as VerticalRunGroup\n      return { row: otherValue, col: verticalRunGroup.col }\n    }\n    throw new Error(\"[makeRunGroupCoords] unknown RunGroupType\")\n  }\n}\n","export enum ClueType { Across, Down }\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { ClueType } from \"./clue-type\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = []\n\n    for (const clue of puzzle.clues) {\n      for (const candidate of clue.candidates) {\n        const internalRow = { puzzle, clue, candidate }\n        internalRows.push(internalRow)\n      }\n    }\n\n    return internalRows\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    return this.makeColumns(internalRow)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n\n  makeColumns(internalRow: InternalRow): number[] {\n    const crossCheckingSquares = internalRow.puzzle.crossCheckingSquares\n    const clue = internalRow.clue\n    const columns = Array(crossCheckingSquares.length * 26).fill(0)\n\n    const findCrossCheckingSquareIndex = (coords: Coords): number => {\n      return crossCheckingSquares.findIndex(crossCheckingSquare =>\n        sameCoords(crossCheckingSquare, coords))\n    }\n\n    for (const index of range(clue.coordsList.length)) {\n      const coords = clue.coordsList[index]\n      const crossCheckingSquareIndex = findCrossCheckingSquareIndex(coords)\n      if (crossCheckingSquareIndex >= 0) {\n        const letter = internalRow.candidate[index]\n        const encodedLetterColumns = this.encodeLetter(letter, clue.clueType)\n        const baseIndex = crossCheckingSquareIndex * 26\n        for (const encodedLetterIndex of range(encodedLetterColumns.length)) {\n          columns[baseIndex + encodedLetterIndex] = encodedLetterColumns[encodedLetterIndex]\n        }\n      }\n    }\n\n    return columns\n  }\n\n  encodeLetter(letter: string, clueType: ClueType): number[] {\n    const upperLetter = letter.toLocaleUpperCase()\n    const index = upperLetter.codePointAt(0)! - \"A\".codePointAt(0)!\n    const [onValue, offValue] = clueType === ClueType.Across ? [1, 0] : [0, 1]\n    const columns = Array(26).fill(offValue)\n    columns[index] = onValue\n    return columns\n  }\n}\n","// Unexpected use of 'self'.\n/* eslint-disable no-restricted-globals */\n\nimport * as dlxlib from \"dlxlib/dlx\"\nimport { Demo as SudokuDemo } from \"demos/sudoku/demo\"\nimport { Demo as PentominoesDemo } from \"demos/pentominoes/demo\"\nimport { Demo as DraughtboardPuzzleDemo } from \"demos/draughtboard-puzzle/demo\"\nimport { Demo as NQueensDemo } from \"demos/n-queens/demo\"\nimport { Demo as FlowFreeDemo } from \"demos/flow-free/demo\"\nimport { Demo as KakuroDemo } from \"demos/kakuro/demo\"\nimport { Demo as NonogramDemo } from \"demos/nonogram/demo\"\nimport { Demo as CrosswordDemo } from \"demos/crossword/demo\"\n\nconst map = new Map<string, any>([\n  [\"sudoku\", SudokuDemo],\n  [\"pentominoes\", PentominoesDemo],\n  [\"draughtboard-puzzle\", DraughtboardPuzzleDemo],\n  [\"n-queens\", NQueensDemo],\n  [\"flow-free\", FlowFreeDemo],\n  [\"kakuro\", KakuroDemo],\n  [\"nonogram\", NonogramDemo],\n  [\"crossword\", CrosswordDemo]\n])\n\n// 'worker.ts' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module.ts(1208)\nexport { }\n\ntype SearchStepEvent = {\n  partialSolution: number[],\n  stepIndex: number\n}\n\ntype SolutionFoundEvent = {\n  solution: number[],\n  solutionIndex: number\n}\n\nconst onSolve = (shortName: string, puzzle: any) => {\n  const demoConstructor = map.get(shortName)\n  if (!demoConstructor) {\n    self.postMessage({ type: \"unknownDemo\" })\n    return\n  }\n  const demo = new demoConstructor()\n  const internalRows = demo.buildInternalRows(puzzle)\n  const matrix = internalRows.map((internalRow: any) => demo.internalRowToMatrixRow(internalRow))\n  const options: dlxlib.Options = {\n    numSolutions: 1,\n    numPrimaryColumns: demo.getNumPrimaryColumns(puzzle)\n  }\n\n  const onStep = (event: SearchStepEvent) => {\n    console.log(\"[worker onStep]\", \"stepIndex:\", event.stepIndex)\n    const partialSolution = event.partialSolution\n    const solutionInternalRows = partialSolution.map(index => internalRows[index])\n    self.postMessage({ type: \"searchStep\", solutionInternalRows })\n  }\n\n  const onSolution = (event: SolutionFoundEvent) => {\n    console.log(\"[worker onSolution]\", \"solutionIndex:\", event.solutionIndex)\n    const solution = event.solution\n    const solutionInternalRows = solution.map(index => internalRows[index])\n    self.postMessage({ type: \"solutionFound\", solutionInternalRows })\n  }\n\n  const dlx = new dlxlib.Dlx()\n  // dlx.addListener(\"step\", onStep)\n  dlx.addListener(\"solution\", onSolution)\n  const solutions = dlx.solve(matrix, options)\n\n  self.postMessage({ type: \"finished\", numSolutionsFound: solutions.length })\n}\n\nself.onmessage = (ev: MessageEvent<any>) => {\n  try {\n    console.log(\"[worker onmessage]\", \"ev.data.type:\", ev.data.type)\n    if (ev.data.type === \"solve\") {\n      const { shortName, puzzle } = ev.data\n      onSolve(shortName, puzzle)\n      return\n    }\n  } catch (error) {\n    console.error(\"error:\", error)\n    if (error instanceof Error) {\n      self.postMessage({ type: \"error\", message: error.message })\n    } else {\n      self.postMessage({ type: \"error\", message: String(error) })\n    }\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [933], function() { return __webpack_require__(9803); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"039fce7e\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/dlxlib-demos/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t803: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdlxlib_demos\"] = self[\"webpackChunkdlxlib_demos\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(933).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DataObject","listHeader","rowIndex","up","down","left","right","this","addDataObject","dataObject","fn","loop","propName","next","ColumnObject","previousColumnObject","nextColumnObject","numberOfRows","columnObject","appendToColumn","unlinkFromColumn","relinkIntoColumn","search","Dlx","checkOptions","options","undefined","numSolutions","Number","isInteger","Error","numPrimaryColumns","matrix","MAX_SAFE_INTEGER","solutions","iterator","solutionGenerator","index","iteratorResult","done","push","value","root","buildInternalStructure","searchState","SearchState","EventEmitter","length","colIndexToListHeader","Map","forEach","row","firstDataObjectInThisRow","col","colIndex","appendColumnHeader","set","get","appendToRow","byAscendingRowIndices","rowIndex1","rowIndex2","raiseSearchStepEvent","isEmpty","currentSolution","raiseSolutionFoundEvent","slice","sort","c","chooseColumnWithFewestRows","coverColumn","r","pushRowIndex","loopRight","j","loopLeft","uncoverColumn","popRowIndex","chosenColumn","loopNext","column","unlinkColumnHeader","loopDown","i","unlinkDataObject","loopUp","relinkDataObject","relinkColumnHeader","dlx","stepIndex","solutionIndex","pop","listenerCount","e","partialSolution","emit","solution","range","n","Array","from","keys","sum","ns","reduce","acc","defaultSameness","x1","x2","except","xs1","xs2","isSame","filter","some","CurrentState","reverseString","s","reverse","join","goDown","coords","goLeft","goRight","sameCoords","coords1","coords2","Orientation","Demo","puzzle","flatMap","map","initialValue","initialValues","find","iv","_buildInternalRowsForInitialValue","_buildInternalRowsForCoords","isInitialValue","internalRow","box","_rowColToBox","zeroBasedValue","posColumns","_oneHot","rowColumns","colColumns","boxColumns","concat","major","minor","columns","fill","Math","floor","Colour","rotateCW","pattern","rowCount","colCount","rowIndices","transposed","reflect","toCoordsList","coordsList","piecesMap","pieces","label","reflectVariationCandidate","vc","reflected","makeVariation","orientation","piecesWithVariations","piece","north","North","northReflected","east","East","eastReflected","south","South","southReflected","west","West","allVariationCandidates","representations","Set","uniqueVariationCandidates","representation","has","add","variations","allLocations","allPossiblePiecePlacements","isValidPiecePlacement","pieceColumns","makePieceColumns","locationColumns","makeLocationColumns","variation","location","internalRows","fixedPiecesLabels","pieceWithVariations","includes","findIndex","pwv","indices","indicesToExclude","_","RunType","toSquares","squares","colour","Black","White","square","size","diagonalColumnCount","diagonal1Columns","diagonal2Columns","diagonal1","diagonal2","findPaths","colourPair","start","goal","end","currentPath","paths","maxDirectionChanges","colourPairs","findPathsInternal","node","nextNode","path","countDirectionChanges","p","neighbours","dots","cp","d","isDot","count","p1","p3","rowDiff","abs","colDiff","sameRun","run1","run2","runType","coordsList1","coordsList2","sameCoordsList","RunGroupType","doPermute","nums","permutations","doPermuteInternal","list","swap","index1","index2","temp","DIGITS","createInternalRowsFor","runs","run","findSetsOfValues","setOfValues","values","horizontalRuns","verticalRuns","setsOfValues","helper","useds","remainingDigits","flat","used","digit","horizontalRunColumns","makeHorizontalRunColumns","verticalRunColumns","makeVerticalRunColumns","horizontalRunValueColumns","makeHorizontalRunValueColumns","verticalRunValueColumns","makeVerticalRunValueColumns","Horizontal","findHorizontalRunIndex","Vertical","findVerticalRunIndex","unknowns","encodedValue","encodeValueNormal","encodeValueInverse","unknown","unknownIndex","findUnknownIndex","encodedValueIndex","u","ClueType","buildInternalRowsForRunGroup","runGroup","workingSetOfStartingPositions","recursivelyFindSetsOfStartingPositions","startPosition","remainingLengths","runLength","newRemainingLengths","sumOfRemainingLengths","requiredGaps","validStartPositions","x","validStartPosition","pair","startingPosition","lengths","setOfStartingPositions","coordsLists","startingPositionData","makeRunGroupCoords","horizontalRunGroups","verticalRunGroups","makeRowColumns","makeColColumns","horizontalBlockColumns","makeBlockColumns","verticalBlockColumns","runGroupType","selectedBlockCoords","unselectedBlockCoords","otherValue","markOn","markOff","ON_INDEX","OFF_INDEX","clues","clue","candidates","candidate","makeColumns","crossCheckingSquares","findCrossCheckingSquareIndex","crossCheckingSquare","crossCheckingSquareIndex","letter","encodedLetterColumns","encodeLetter","clueType","baseIndex","encodedLetterIndex","toLocaleUpperCase","codePointAt","Across","onValue","offValue","SudokuDemo","PentominoesDemo","DraughtboardPuzzleDemo","NQueensDemo","FlowFreeDemo","KakuroDemo","NonogramDemo","CrosswordDemo","self","onmessage","ev","console","log","data","type","shortName","demoConstructor","demo","buildInternalRows","internalRowToMatrixRow","getNumPrimaryColumns","dlxlib","addListener","event","solutionInternalRows","postMessage","solve","numSolutionsFound","onSolve","error","message","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","result","chunkIds","priority","notFulfilled","Infinity","fulfilled","Object","every","key","splice","getter","__esModule","a","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","promises","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}