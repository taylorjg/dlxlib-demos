{"version":3,"file":"static/js/907.46126b22.chunk.js","mappings":"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","sources":["dlxlib/dataObject.ts","dlxlib/columnObject.ts","dlxlib/dlx.ts","utils.ts","types.ts","worker/stop-token.ts","worker/time-it.ts","demos/pentominoes/orientation.ts","demos/sudoku/demo.ts","demos/pentominoes/pattern.ts","demos/draughtboard-puzzle/colour.ts","demos/draughtboard-puzzle/orientation.ts","demos/pentominoes/pieces.ts","demos/pentominoes/pieces-with-variations.ts","demos/pentominoes/demo.ts","demos/draughtboard-puzzle/pattern.ts","demos/tetrasticks/orientation.ts","demos/draughtboard-puzzle/pieces.ts","demos/draughtboard-puzzle/pieces-with-variations.ts","demos/draughtboard-puzzle/demo.ts","demos/n-queens/demo.ts","demos/aztec-diamond/orientation.ts","demos/tetrasticks/pieces.ts","demos/tetrasticks/variation.ts","demos/tetrasticks/pieces-with-variations.ts","demos/tetrasticks/demo.ts","demos/aztec-diamond/locations.ts","demos/kakuro/run-type.ts","demos/aztec-diamond/pieces.ts","demos/aztec-diamond/variation.ts","demos/aztec-diamond/pieces-with-variations.ts","demos/aztec-diamond/thumbnail.tsx","demos/aztec-diamond/drawing.tsx","demos/aztec-diamond/demo.ts","demos/ripple-effect/demo.ts","demos/flow-free/path-finder.ts","demos/flow-free/demo.ts","demos/kakuro/run.ts","demos/kakuro/permutations.ts","demos/nonogram/run-group-type.ts","demos/kakuro/demo.ts","demos/nonogram/demo.ts","demos/crossword/clue-type.ts","demos/crossword/demo.ts","worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { ColumnObject } from \"./columnObject\";\n\nexport class DataObject {\n  public up: DataObject;\n  public down: DataObject;\n  public left: DataObject;\n  public right: DataObject;\n\n  public constructor(\n    public listHeader?: ColumnObject,\n    public rowIndex?: number\n  ) {\n    this.up = this;\n    this.down = this;\n    this.left = this;\n    this.right = this;\n    listHeader?.addDataObject(this);\n  }\n\n  public appendToRow(dataObject: DataObject) {\n    this.left.right = dataObject;\n    dataObject.right = this;\n    dataObject.left = this.left;\n    this.left = dataObject;\n  }\n\n  public appendToColumn(dataObject: DataObject) {\n    this.up.down = dataObject;\n    dataObject.down = this;\n    dataObject.up = this.up;\n    this.up = dataObject;\n  }\n\n  public unlinkFromColumn() {\n    this.down.up = this.up;\n    this.up.down = this.down;\n  }\n\n  public relinkIntoColumn() {\n    this.down.up = this;\n    this.up.down = this;\n  }\n\n  public loopUp(fn: (dataObject: DataObject) => void) {\n    this.loop(fn, \"up\");\n  }\n  public loopDown(fn: (dataObject: DataObject) => void) {\n    this.loop(fn, \"down\");\n  }\n  public loopLeft(fn: (dataObject: DataObject) => void) {\n    this.loop(fn, \"left\");\n  }\n  public loopRight(fn: (dataObject: DataObject) => void) {\n    this.loop(fn, \"right\");\n  }\n\n  private loop(\n    fn: (dataObject: DataObject) => void,\n    propName: \"up\" | \"down\" | \"left\" | \"right\"\n  ) {\n    for (let next = this[propName]; next !== this; next = next[propName]) {\n      fn(next);\n    }\n  }\n}\n","import { DataObject } from \"./dataObject\";\n\nexport class ColumnObject extends DataObject {\n  public previousColumnObject: ColumnObject;\n  public nextColumnObject: ColumnObject;\n  public numberOfRows: number;\n\n  public constructor() {\n    super();\n    this.previousColumnObject = this;\n    this.nextColumnObject = this;\n    this.numberOfRows = 0;\n  }\n\n  public appendColumnHeader(columnObject: ColumnObject) {\n    this.previousColumnObject.nextColumnObject = columnObject;\n    columnObject.nextColumnObject = this;\n    columnObject.previousColumnObject = this.previousColumnObject;\n    this.previousColumnObject = columnObject;\n  }\n\n  public unlinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this.previousColumnObject;\n    this.previousColumnObject.nextColumnObject = this.nextColumnObject;\n  }\n\n  public relinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this;\n    this.previousColumnObject.nextColumnObject = this;\n  }\n\n  public addDataObject(dataObject: DataObject) {\n    this.appendToColumn(dataObject);\n    this.numberOfRows++;\n  }\n\n  public unlinkDataObject(dataObject: DataObject) {\n    dataObject.unlinkFromColumn();\n    this.numberOfRows--;\n  }\n\n  public relinkDataObject(dataObject: DataObject) {\n    dataObject.relinkIntoColumn();\n    this.numberOfRows++;\n  }\n\n  public loopNext(fn: (columnObject: ColumnObject) => void) {\n    for (\n      let next = this.nextColumnObject;\n      next !== this;\n      next = next.nextColumnObject\n    ) {\n      fn(next);\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\nimport EventEmitter from \"events\";\nimport { DataObject } from \"./dataObject\";\nimport { ColumnObject } from \"./columnObject\";\n\nexport type Matrix = Uint8Array[];\nexport type Solution = number[];\nexport type PartialSolution = number[];\n\nexport type Options = {\n  numSolutions?: number;\n  numPrimaryColumns?: number;\n  checkForCancellation?: () => boolean;\n  checkForCancellationFrequency?: number;\n};\n\nexport function solve(matrix: Matrix, options: Options) {\n  return new Dlx().solve(matrix, options);\n}\n\nexport class Dlx extends EventEmitter {\n  public solve(matrix: Matrix, options?: Options): Solution[] {\n    this.checkOptions(options);\n    const numSolutions = options?.numSolutions ?? Number.MAX_SAFE_INTEGER;\n    const solutions = [];\n    const iterator = this.solutionGenerator(matrix, options);\n    for (let index = 0; index < numSolutions; index++) {\n      const iteratorResult = iterator.next();\n      if (iteratorResult.done) break;\n      solutions.push(iteratorResult.value);\n    }\n    return solutions;\n  }\n\n  public *solutionGenerator(\n    matrix: Matrix,\n    options?: Options\n  ): Generator<Solution> {\n    this.checkOptions(options);\n    const root = buildInternalStructure(matrix, options);\n    const searchState = new SearchState(this, root);\n    yield* search(searchState, options);\n  }\n\n  private checkOptions = (options?: Options): void => {\n    if (options?.numSolutions !== undefined) {\n      if (!Number.isInteger(options.numSolutions)) {\n        throw new Error(\"options.numSolutions must be an integer\");\n      }\n      if (options.numSolutions < 0) {\n        throw new Error(\n          \"options.numSolutions can't be negative - don't be silly\"\n        );\n      }\n    }\n\n    if (options?.numPrimaryColumns !== undefined) {\n      if (!Number.isInteger(options.numPrimaryColumns)) {\n        throw new Error(\"options.numPrimaryColumns must be an integer\");\n      }\n      if (options.numPrimaryColumns < 0) {\n        throw new Error(\n          \"options.numPrimaryColumns can't be negative - don't be silly\"\n        );\n      }\n    }\n  };\n}\n\nconst buildInternalStructure = (matrix: Matrix, options?: Options) => {\n  const numPrimaryColumns = options?.numPrimaryColumns ?? matrix[0].length;\n\n  const root = new ColumnObject();\n  const colIndexToListHeader = new Map();\n  let cancelled = false;\n\n  matrix.forEach((row: Uint8Array, rowIndex: number) => {\n    if (rowIndex % 1000 === 0) {\n      if (options?.checkForCancellation?.()) {\n        cancelled = true;\n      }\n    }\n    if (cancelled) return;\n    let firstDataObjectInThisRow: DataObject | undefined = undefined;\n    row.forEach((col, colIndex: number) => {\n      if (rowIndex === 0) {\n        const listHeader = new ColumnObject();\n        if (colIndex < numPrimaryColumns) {\n          root.appendColumnHeader(listHeader);\n        }\n        colIndexToListHeader.set(colIndex, listHeader);\n      }\n      if (col) {\n        const listHeader = colIndexToListHeader.get(colIndex);\n        const dataObject = new DataObject(listHeader, rowIndex);\n        if (firstDataObjectInThisRow)\n          firstDataObjectInThisRow.appendToRow(dataObject);\n        else firstDataObjectInThisRow = dataObject;\n      }\n    });\n  });\n\n  return root;\n};\n\nconst byAscendingRowIndices = (rowIndex1: number, rowIndex2: number) =>\n  rowIndex1 - rowIndex2;\n\nfunction* search(\n  searchState: SearchState,\n  options?: Options\n): Generator<Solution> {\n  const checkForCancellationFrequency =\n    options?.checkForCancellationFrequency ?? 100;\n  if (searchState.getStepIndex() % checkForCancellationFrequency === 0) {\n    if (options?.checkForCancellation?.()) {\n      return;\n    }\n  }\n\n  searchState.raiseSearchStepEvent();\n\n  if (searchState.isEmpty()) {\n    if (searchState.currentSolution.length) {\n      searchState.raiseSolutionFoundEvent();\n      yield searchState.currentSolution.slice().sort(byAscendingRowIndices);\n    }\n    return;\n  }\n\n  const c = chooseColumnWithFewestRows(searchState);\n  coverColumn(c);\n  for (let r = c.down; r !== c; r = r.down) {\n    searchState.pushRowIndex(r.rowIndex!);\n    r.loopRight((j) => coverColumn(j.listHeader!));\n    yield* search(searchState, options);\n    r.loopLeft((j) => uncoverColumn(j.listHeader!));\n    searchState.popRowIndex();\n  }\n  uncoverColumn(c);\n}\n\nconst chooseColumnWithFewestRows = (searchState: SearchState) => {\n  let chosenColumn: ColumnObject | undefined = undefined;\n  searchState.root.loopNext((column) => {\n    if (!chosenColumn || column.numberOfRows < chosenColumn.numberOfRows) {\n      chosenColumn = column;\n    }\n  });\n  return chosenColumn!;\n};\n\nconst coverColumn = (c: ColumnObject) => {\n  c.unlinkColumnHeader();\n  c.loopDown((i) => i.loopRight((j) => j.listHeader!.unlinkDataObject(j)));\n};\n\nconst uncoverColumn = (c: ColumnObject) => {\n  c.loopUp((i) => i.loopLeft((j) => j.listHeader!.relinkDataObject(j)));\n  c.relinkColumnHeader();\n};\n\nclass SearchState {\n  public currentSolution: number[] = [];\n  private stepIndex = 0;\n  private solutionIndex = 0;\n\n  public constructor(private dlx: Dlx, public root: ColumnObject) {}\n\n  public getStepIndex(): number {\n    return this.stepIndex;\n  }\n\n  public isEmpty() {\n    return this.root.nextColumnObject === this.root;\n  }\n\n  public pushRowIndex(rowIndex: number) {\n    this.currentSolution.push(rowIndex);\n  }\n\n  public popRowIndex() {\n    this.currentSolution.pop();\n  }\n\n  public raiseSearchStepEvent() {\n    if (this.dlx.listenerCount(\"step\") > 0 && this.currentSolution.length) {\n      const partialSolution: PartialSolution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices);\n      const e = {\n        partialSolution,\n        stepIndex: this.stepIndex++,\n      };\n      this.dlx.emit(\"step\", e);\n    }\n  }\n\n  public raiseSolutionFoundEvent() {\n    if (this.dlx.listenerCount(\"solution\") > 0) {\n      const solution: Solution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices);\n      const e = {\n        solution,\n        solutionIndex: this.solutionIndex++,\n      };\n      this.dlx.emit(\"solution\", e);\n    }\n  }\n}\n","export const range = (n: number): number[] => Array.from(Array(n).keys());\nexport const sum = (ns: number[]): number => ns.reduce((acc, n) => acc + n, 0);\nexport const min = (ns: number[]): number => Math.min(...ns);\nexport const max = (ns: number[]): number => Math.max(...ns);\nexport function minBy<T>(xs: T[], selector: (x: T) => number): number {\n  return min(xs.map(selector));\n}\nexport function maxBy<T>(xs: T[], selector: (x: T) => number): number {\n  return max(xs.map(selector));\n}\nexport function first<T>(xs: T[]): T {\n  return xs[0];\n}\nexport function last<T>(xs: T[]): T {\n  return xs[xs.length - 1];\n}\nexport function distinct<T>(xs: T[]): T[] {\n  return Array.from(new Set(xs));\n}\n\nfunction defaultSameness<T>(x1: T, x2: T): boolean {\n  return x1 === x2;\n}\n\nexport function except<T>(\n  xs1: T[],\n  xs2: T[],\n  isSame: (x1: T, x2: T) => boolean = defaultSameness\n): T[] {\n  return xs1.filter((x1) => !xs2.some((x2) => isSame(x1, x2)));\n}\n\nexport function union<T>(\n  xs1: T[],\n  xs2: T[],\n  isSame: (x1: T, x2: T) => boolean = defaultSameness\n): T[] {\n  return [...xs1].concat(xs2.filter((x2) => !xs1.some((x1) => isSame(x1, x2))));\n}\n\nexport function intersect<T>(\n  xs1: T[],\n  xs2: T[],\n  isSame: (x1: T, x2: T) => boolean = defaultSameness\n): T[] {\n  const firstsInSecond = xs1.filter((x1) => xs2.some((x2) => isSame(x1, x2)));\n  const secondsInFirst = xs2.filter((x2) => xs1.some((x1) => isSame(x1, x2)));\n  return union(firstsInSecond, secondsInFirst, isSame);\n}\n\nexport const reverseString = (s: string): string =>\n  Array.from(s).reverse().join(\"\");\n","import { range } from \"utils\";\n\nexport type EmptyPuzzle = Record<string, never>;\nexport type EmptyInternalRow = Record<string, never>;\nexport type EmptyDrawingOptions = Record<string, never>;\n\nexport type AvailableDemo = {\n  name: string;\n  shortName: string;\n  Thumbnail: React.FC;\n  hideBorder: boolean;\n  readmeSource?: string;\n};\n\nexport type DrawingProps<\n  TPuzzle,\n  TInternalRow,\n  TDrawingOptions = EmptyDrawingOptions\n> = {\n  puzzle: TPuzzle;\n  solutionInternalRows: TInternalRow[];\n  drawingOptions: TDrawingOptions;\n};\n\nexport type DemoControlsProps<\n  TPuzzle,\n  TDrawingOptions = EmptyDrawingOptions\n> = {\n  selectedPuzzle: TPuzzle;\n  drawingOptions: TDrawingOptions;\n  onSelectedPuzzleChanged: (puzzle: TPuzzle) => void;\n  onDrawingOptionsChanged: (drawingOptions: TDrawingOptions) => void;\n};\n\nexport interface IDemo<TPuzzle, TInternalRow> {\n  buildInternalRows(\n    puzzle: TPuzzle,\n    checkForCancellation: () => boolean\n  ): TInternalRow[];\n  internalRowToMatrixRow(internalRow: TInternalRow): number[];\n  getNumPrimaryColumns(puzzle: TPuzzle): number | undefined;\n}\n\nexport type Point = {\n  x: number;\n  y: number;\n};\n\nexport type Coords = {\n  row: number;\n  col: number;\n};\n\nexport const goUp = (coords: Coords): Coords => ({\n  row: coords.row - 1,\n  col: coords.col,\n});\nexport const goDown = (coords: Coords): Coords => ({\n  row: coords.row + 1,\n  col: coords.col,\n});\nexport const goLeft = (coords: Coords): Coords => ({\n  row: coords.row,\n  col: coords.col - 1,\n});\nexport const goRight = (coords: Coords): Coords => ({\n  row: coords.row,\n  col: coords.col + 1,\n});\n\nexport const sameCoords = (coords1: Coords, coords2: Coords): boolean =>\n  coords1.row === coords2.row && coords1.col === coords2.col;\n\nexport const addCoords = (coords1: Coords, coords2: Coords): Coords => ({\n  row: coords1.row + coords2.row,\n  col: coords1.col + coords2.col,\n});\n\nexport const sameCoordsList = (\n  coordsList1: Coords[],\n  coordsList2: Coords[]\n): boolean => {\n  if (coordsList1.length !== coordsList2.length) return false;\n  for (const index of range(coordsList1.length)) {\n    const coords1 = coordsList1[index];\n    const coords2 = coordsList2[index];\n    if (!sameCoords(coords1, coords2)) return false;\n  }\n  return true;\n};\n\nexport const coordsComparer = (coords1: Coords, coords2: Coords): number => {\n  const rowDiff = coords1.row - coords2.row;\n  const colDiff = coords1.col - coords2.col;\n  return rowDiff !== 0 ? rowDiff : colDiff;\n};\n\nexport enum CurrentState {\n  Clean,\n  Solving,\n  Dirty,\n}\n\nexport enum Mode {\n  FirstSolution,\n  SearchSteps,\n}\n\nexport type UIToWorkerSolveMessage = {\n  type: string;\n  stopToken: string;\n  shortName: string;\n  puzzle: unknown;\n  mode: Mode;\n};\n\nexport type UIToWorkerCloseMessage = {\n  type: string;\n};\n\nexport type UIToWorkerMessage = UIToWorkerSolveMessage | UIToWorkerCloseMessage;\n\nexport type WorkerToUISearchStepMessage = {\n  type: string;\n  solutionInternalRows: unknown[];\n};\n\nexport type WorkerToUISolutionFoundMessage = {\n  type: string;\n  solutionInternalRows: unknown[];\n};\n\nexport type WorkerToUIFinishedMessage = {\n  type: string;\n  numSolutionsFound: number;\n};\n\nexport type WorkerToUIErrorMessage = {\n  type: string;\n  errorMessage: string;\n};\n\nexport type WorkerToUICancelledMessage = {\n  type: string;\n};\n\nexport type WorkerToUIMessage =\n  | WorkerToUISearchStepMessage\n  | WorkerToUISolutionFoundMessage\n  | WorkerToUIFinishedMessage\n  | WorkerToUIErrorMessage\n  | WorkerToUICancelledMessage;\n","// https://github.com/panstromek/zebra-rs/blob/82d616225930b3ad423a2c6d883c79b94ee08ba6/webzebra/src/stopToken.ts\n\nexport function createStopToken(): string {\n  return URL.createObjectURL(new Blob());\n}\n\nexport function stop(stopToken: string): void {\n  return URL.revokeObjectURL(stopToken);\n}\n\nexport function checkStopToken(stopToken: string): boolean {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", stopToken, false);\n  try {\n    xhr.send(null);\n  } catch {\n    return true;\n  }\n  return false;\n}\n","export function timeIt<T>(label: string, fn: () => T): T {\n  const startTime = performance.now();\n  const result: T = fn();\n  const endTime = performance.now();\n  const elapsedTimeMs = endTime - startTime;\n  const elapsedTimeS = elapsedTimeMs / 1000;\n  console.log(`[${label}] elapsed time: ${elapsedTimeS.toLocaleString()}s`);\n  return result;\n}\n","export enum Orientation {\n  North,\n  South,\n  East,\n  West,\n}\n","import { Coords, IDemo, sameCoords } from \"types\";\nimport { range } from \"utils\";\nimport { InitialValue } from \"./initial-value\";\nimport { InternalRow } from \"./internal-row\";\nimport { Puzzle } from \"./puzzle\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    const allCoords = range(9).flatMap((row) =>\n      range(9).map((col) => ({ row, col }))\n    );\n    return allCoords.flatMap((coords) => {\n      const initialValue = puzzle.initialValues.find((iv) =>\n        sameCoords(iv.coords, coords)\n      );\n      return initialValue\n        ? this._buildInternalRowsForInitialValue(initialValue)\n        : this._buildInternalRowsForCoords(coords);\n    });\n  }\n\n  _buildInternalRowsForInitialValue(initialValue: InitialValue): InternalRow[] {\n    return [{ ...initialValue, isInitialValue: true }];\n  }\n\n  _buildInternalRowsForCoords(coords: Coords): InternalRow[] {\n    return range(9)\n      .map((n) => n + 1)\n      .map((value) => ({\n        coords,\n        value,\n        isInitialValue: false,\n      }));\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords;\n    const box = this._rowColToBox(row, col);\n    const zeroBasedValue = internalRow.value - 1;\n    const posColumns = this._oneHot(row, col);\n    const rowColumns = this._oneHot(row, zeroBasedValue);\n    const colColumns = this._oneHot(col, zeroBasedValue);\n    const boxColumns = this._oneHot(box, zeroBasedValue);\n    return posColumns.concat(rowColumns).concat(colColumns).concat(boxColumns);\n  }\n\n  _oneHot(major: number, minor: number): number[] {\n    const columns = Array(81).fill(0);\n    columns[major * 9 + minor] = 1;\n    return columns;\n  }\n\n  _rowColToBox(row: number, col: number): number {\n    return Math.floor(row - (row % 3) + col / 3);\n  }\n\n  getNumPrimaryColumns(_puzzle: Puzzle): number | undefined {\n    return undefined;\n  }\n}\n","import { Coords } from \"types\";\nimport { range, reverseString } from \"utils\";\n\nexport const rotateCW = (pattern: string[]): string[] => {\n  const rowCount = pattern.length;\n  const colCount = pattern[0].length;\n  const rowIndices = range(rowCount);\n  const colIndices = range(colCount);\n  const transposed = colIndices.map((col) =>\n    rowIndices.map((row) => pattern[row][col]).join(\"\")\n  );\n  return reflect(transposed);\n};\n\nexport const reflect = (pattern: string[]): string[] => {\n  return pattern.map(reverseString);\n};\n\nexport const toCoordsList = (pattern: string[]): Coords[] => {\n  const rowCount = pattern.length;\n  const colCount = pattern[0].length;\n  const coordsList: Coords[] = [];\n\n  for (const row of range(rowCount)) {\n    for (const col of range(colCount)) {\n      if (pattern[row][col] === \"X\") {\n        const coords = { row, col };\n        coordsList.push(coords);\n      }\n    }\n  }\n\n  return coordsList;\n};\n","export enum Colour {\n  Black,\n  White,\n}\n","export enum Orientation {\n  North,\n  South,\n  East,\n  West,\n}\n","import { Piece } from \"./piece\";\n\n// https://en.wikipedia.org/wiki/Pentomino\nconst piecesMap = new Map<string, string[]>([\n  [\"F\", [\" XX\", \"XX \", \" X \"]],\n  [\"I\", [\"X\", \"X\", \"X\", \"X\", \"X\"]],\n  [\"L\", [\"X \", \"X \", \"X \", \"XX\"]],\n  [\"N\", [\" X\", \" X\", \"XX\", \"X \"]],\n  [\"P\", [\"XX\", \"XX\", \"X \"]],\n  [\"T\", [\"XXX\", \" X \", \" X \"]],\n  [\"U\", [\"X X\", \"XXX\"]],\n  [\"V\", [\"X  \", \"X  \", \"XXX\"]],\n  [\"W\", [\"X  \", \"XX \", \" XX\"]],\n  [\"X\", [\" X \", \"XXX\", \" X \"]],\n  [\"Y\", [\" X\", \"XX\", \" X\", \" X\"]],\n  [\"Z\", [\"XX \", \" X \", \" XX\"]],\n]);\n\nexport const pieces: Piece[] = Array.from(piecesMap).map(\n  ([label, pattern]) => ({ label, pattern })\n);\n","import { Orientation } from \"./orientation\";\nimport { reflect, rotateCW, toCoordsList } from \"./pattern\";\nimport { Piece } from \"./piece\";\nimport { PieceWithVariations } from \"./piece-with-variations\";\nimport { pieces } from \"./pieces\";\nimport { Variation } from \"./variation\";\n\ntype VariationCandidate = {\n  orientation: Orientation;\n  reflected: boolean;\n  pattern: string[];\n};\n\nconst reflectVariationCandidate = (\n  vc: VariationCandidate\n): VariationCandidate => {\n  return {\n    ...vc,\n    reflected: true,\n    pattern: reflect(vc.pattern),\n  };\n};\n\nconst makeVariation = (vc: VariationCandidate): Variation => ({\n  orientation: vc.orientation,\n  reflected: vc.reflected,\n  coordsList: toCoordsList(vc.pattern),\n});\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const { label, pattern } = piece;\n\n  const north = { orientation: Orientation.North, reflected: false, pattern };\n  const northReflected = reflectVariationCandidate(north);\n\n  const east = {\n    orientation: Orientation.East,\n    reflected: false,\n    pattern: rotateCW(north.pattern),\n  };\n  const eastReflected = reflectVariationCandidate(east);\n\n  const south = {\n    orientation: Orientation.South,\n    reflected: false,\n    pattern: rotateCW(east.pattern),\n  };\n  const southReflected = reflectVariationCandidate(south);\n\n  const west = {\n    orientation: Orientation.West,\n    reflected: false,\n    pattern: rotateCW(south.pattern),\n  };\n  const westReflected = reflectVariationCandidate(west);\n\n  const allVariationCandidates = [\n    north,\n    northReflected,\n    east,\n    eastReflected,\n    south,\n    southReflected,\n    west,\n    westReflected,\n  ];\n\n  const representations = new Set<string>();\n  const uniqueVariationCandidates: VariationCandidate[] = [];\n  for (const vc of allVariationCandidates) {\n    const representation = vc.pattern.join(\"|\");\n    if (!representations.has(representation)) {\n      representations.add(representation);\n      uniqueVariationCandidates.push(vc);\n    }\n  }\n\n  const variations = uniqueVariationCandidates.map(makeVariation);\n\n  return { label, variations };\n};\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations);\n","import { EmptyPuzzle, IDemo } from \"types\";\nimport { range } from \"utils\";\nimport { InternalRow } from \"./internal-row\";\nimport { piecesWithVariations } from \"./pieces-with-variations\";\n\nexport class Demo implements IDemo<EmptyPuzzle, InternalRow> {\n  buildInternalRows(\n    _puzzle: EmptyPuzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    return this.allPossiblePiecePlacements().filter((internalRow) =>\n      this.isValidPiecePlacement(internalRow)\n    );\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow);\n    const locationColumns = this.makeLocationColumns(internalRow);\n    return pieceColumns.concat(locationColumns);\n  }\n\n  getNumPrimaryColumns(_puzzle: EmptyPuzzle): number | undefined {\n    return undefined;\n  }\n\n  allLocations = range(8).flatMap((row) =>\n    range(8).map((col) => ({ row, col }))\n  );\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    for (const coords of internalRow.variation.coordsList) {\n      const row = internalRow.location.row + coords.row;\n      const col = internalRow.location.col + coords.col;\n      if (row >= 8 || col >= 8) return false;\n      if ((row === 3 || row === 4) && (col === 3 || col === 4)) return false;\n    }\n    return true;\n  }\n\n  allPossiblePiecePlacements(): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n    const fixedPieceLabels = piecesWithVariations\n      .slice(0, 1)\n      .map(({ label }) => label);\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const variations = fixedPieceLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations;\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label;\n          const internalRow = { label, variation, location };\n          internalRows.push(internalRow);\n        }\n      }\n    }\n\n    return internalRows;\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0);\n    const pieceIndex = piecesWithVariations.findIndex(\n      (pwv) => pwv.label === internalRow.label\n    );\n    columns[pieceIndex] = 1;\n    return columns;\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const indices = internalRow.variation.coordsList.map((coords) => {\n      const row = internalRow.location.row + coords.row;\n      const col = internalRow.location.col + coords.col;\n      return row * 8 + col;\n    });\n\n    const columns = Array(8 * 8).fill(0);\n\n    for (const index of indices) {\n      columns[index] = 1;\n    }\n\n    const indicesToExclude = [3 * 8 + 3, 3 * 8 + 4, 4 * 8 + 3, 4 * 8 + 4];\n\n    return columns.filter((_, index) => !indicesToExclude.includes(index));\n  }\n}\n","import { range, reverseString } from \"utils\";\nimport { Colour } from \"./colour\";\nimport { Square } from \"./square\";\n\nexport const rotateCW = (pattern: string[]): string[] => {\n  const rowCount = pattern.length;\n  const colCount = pattern[0].length;\n  const rowIndices = range(rowCount);\n  const colIndices = range(colCount);\n  const transposed = colIndices.map((col) =>\n    rowIndices.map((row) => pattern[row][col]).join(\"\")\n  );\n  return reflect(transposed);\n};\n\nexport const reflect = (pattern: string[]): string[] => {\n  return pattern.map(reverseString);\n};\n\nexport const toSquares = (pattern: string[]): Square[] => {\n  const rowCount = pattern.length;\n  const colCount = pattern[0].length;\n  const squares: Square[] = [];\n\n  for (const row of range(rowCount)) {\n    for (const col of range(colCount)) {\n      const coords = { row, col };\n      switch (pattern[row][col]) {\n        case \"B\":\n          squares.push({ coords, colour: Colour.Black });\n          break;\n        case \"W\":\n          squares.push({ coords, colour: Colour.White });\n          break;\n      }\n    }\n  }\n\n  return squares;\n};\n","export enum Orientation {\n  North,\n  South,\n  East,\n  West,\n}\n\nexport const rotateCW = (orientation: Orientation): Orientation => {\n  switch (orientation) {\n    case Orientation.North:\n      return Orientation.East;\n    case Orientation.South:\n      return Orientation.West;\n    case Orientation.East:\n      return Orientation.South;\n    case Orientation.West:\n      return Orientation.North;\n  }\n};\n","import { Piece } from \"./piece\";\n\nconst piecesMap = new Map<string, string[]>([\n  [\"A\", [\"B \", \"WB\", \"B \", \"W \"]],\n  [\"B\", [\"B  \", \"WBW\"]],\n  [\"C\", [\"W \", \"BW\"]],\n  [\"D\", [\" WB\", \" B \", \"BW \"]],\n  [\"E\", [\"W \", \"BW\", \" B\", \" W\"]],\n  [\"F\", [\"WB \", \" W \", \" BW\"]],\n  [\"G\", [\"WB \", \" WB\"]],\n  [\"H\", [\"B \", \"WB\", \"B \"]],\n  [\"I\", [\"B \", \"W \", \"BW\", \"W \"]],\n  [\"J\", [\" B\", \" W\", \" B\", \"BW\"]],\n  [\"K\", [\"  W\", \" WB\", \"WB \"]],\n  [\"L\", [\"B \", \"W \", \"BW\"]],\n  [\"M\", [\" B\", \" W\", \"WB\", \"B \"]],\n  [\"N\", [\"W \", \"B \", \"W \", \"BW\"]],\n]);\n\nexport const pieces: Piece[] = Array.from(piecesMap).map(\n  ([label, pattern]) => ({ label, pattern })\n);\n","import { Orientation } from \"./orientation\";\nimport { rotateCW, toSquares } from \"./pattern\";\nimport { Piece } from \"./piece\";\nimport { PieceWithVariations } from \"./piece-with-variations\";\nimport { pieces } from \"./pieces\";\nimport { Variation } from \"./variation\";\n\ntype VariationCandidate = {\n  orientation: Orientation;\n  pattern: string[];\n};\n\nconst makeVariation = (vc: VariationCandidate): Variation => ({\n  orientation: vc.orientation,\n  squares: toSquares(vc.pattern),\n});\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const { label, pattern } = piece;\n\n  const north = { orientation: Orientation.North, pattern };\n  const east = {\n    orientation: Orientation.East,\n    pattern: rotateCW(north.pattern),\n  };\n  const south = {\n    orientation: Orientation.South,\n    pattern: rotateCW(east.pattern),\n  };\n  const west = {\n    orientation: Orientation.West,\n    pattern: rotateCW(south.pattern),\n  };\n\n  const allVariationCandidates = [north, east, south, west];\n\n  const representations = new Set<string>();\n  const uniqueVariationCandidates: VariationCandidate[] = [];\n  for (const vc of allVariationCandidates) {\n    const representation = vc.pattern.join(\"|\");\n    if (!representations.has(representation)) {\n      representations.add(representation);\n      uniqueVariationCandidates.push(vc);\n    }\n  }\n\n  const variations = uniqueVariationCandidates.map(makeVariation);\n\n  return { label, variations };\n};\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations);\n","import { EmptyPuzzle, IDemo } from \"types\";\nimport { range } from \"utils\";\nimport { Colour } from \"./colour\";\nimport { InternalRow } from \"./internal-row\";\nimport { piecesWithVariations } from \"./pieces-with-variations\";\n\nexport class Demo implements IDemo<EmptyPuzzle, InternalRow> {\n  buildInternalRows(\n    _puzzle: EmptyPuzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    return this.allPossiblePiecePlacements().filter((internalRow) =>\n      this.isValidPiecePlacement(internalRow)\n    );\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow);\n    const locationColumns = this.makeLocationColumns(internalRow);\n    return pieceColumns.concat(locationColumns);\n  }\n\n  getNumPrimaryColumns(_puzzle: EmptyPuzzle): number | undefined {\n    return undefined;\n  }\n\n  allLocations = range(8).flatMap((row) =>\n    range(8).map((col) => ({ row, col }))\n  );\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    for (const square of internalRow.variation.squares) {\n      const { coords, colour } = square;\n      const row = internalRow.location.row + coords.row;\n      const col = internalRow.location.col + coords.col;\n      if (row < 0 || row >= 8) return false;\n      if (col < 0 || col >= 8) return false;\n      const requiredColour =\n        (row + col) % 2 !== 0 ? Colour.White : Colour.Black;\n      if (colour !== requiredColour) return false;\n    }\n    return true;\n  }\n\n  allPossiblePiecePlacements(): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n    const fixedPieceLabels = piecesWithVariations\n      .slice(0, 1)\n      .map(({ label }) => label);\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const variations = fixedPieceLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations;\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label;\n          const internalRow = { label, variation, location };\n          internalRows.push(internalRow);\n        }\n      }\n    }\n\n    return internalRows;\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0);\n    const pieceIndex = piecesWithVariations.findIndex(\n      (pwv) => pwv.label === internalRow.label\n    );\n    columns[pieceIndex] = 1;\n    return columns;\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const indices = internalRow.variation.squares.map((square) => {\n      const { coords } = square;\n      const row = internalRow.location.row + coords.row;\n      const col = internalRow.location.col + coords.col;\n      return row * 8 + col;\n    });\n\n    const columns = Array(8 * 8).fill(0);\n\n    for (const index of indices) {\n      columns[index] = 1;\n    }\n\n    return columns;\n  }\n}\n","import { IDemo } from \"types\";\nimport { range } from \"utils\";\nimport { Puzzle } from \"./puzzle\";\nimport { InternalRow } from \"./internal-row\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    const allLocations = range(puzzle.size).flatMap((row) =>\n      range(puzzle.size).map((col) => ({ row, col }))\n    );\n    return allLocations.map((coords) => ({ puzzle, coords }));\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.size * 2;\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords;\n    const size = internalRow.puzzle.size;\n    const diagonalColumnCount = size + size - 3;\n\n    const rowColumns = Array(size).fill(0);\n    const colColumns = Array(size).fill(0);\n    const diagonal1Columns = Array(diagonalColumnCount).fill(0);\n    const diagonal2Columns = Array(diagonalColumnCount).fill(0);\n\n    rowColumns[row] = 1;\n    colColumns[col] = 1;\n\n    const diagonal1 = row + col - 1;\n    if (diagonal1 >= 0 && diagonal1 < diagonalColumnCount)\n      diagonal1Columns[diagonal1] = 1;\n\n    const diagonal2 = size - 1 - col + row - 1;\n    if (diagonal2 >= 0 && diagonal2 < diagonalColumnCount)\n      diagonal2Columns[diagonal2] = 1;\n\n    return rowColumns\n      .concat(colColumns)\n      .concat(diagonal1Columns)\n      .concat(diagonal2Columns);\n  }\n}\n","export enum Orientation {\n  North,\n  South,\n  East,\n  West,\n}\n\nexport const rotateCW = (orientation: Orientation): Orientation => {\n  switch (orientation) {\n    case Orientation.North:\n      return Orientation.East;\n    case Orientation.South:\n      return Orientation.West;\n    case Orientation.East:\n      return Orientation.South;\n    case Orientation.West:\n      return Orientation.North;\n  }\n};\n","import { Coords } from \"types\";\nimport { Piece } from \"./piece\";\n\nconst piecesMap = new Map<string, { lineSegments: string; polyLines: string }>([\n  [\n    \"F\",\n    {\n      lineSegments: \"H00 V00 H10 V10\",\n      polyLines: \"0,1 0,0 1,0 1,1|1,1 1,0 2,0\",\n    },\n  ],\n  [\n    \"H\",\n    {\n      lineSegments: \"V00 V10 H10 V11\",\n      polyLines: \"0,0 1,0 1,1 2,1|2,0 1,0 1,1 2,1\",\n    },\n  ],\n  [\n    \"I\",\n    {\n      lineSegments: \"V00 V10 V20 V30 I10 I20 I30\",\n      polyLines: \"0,0 1,0 2,0 3,0 4,0\",\n    },\n  ],\n  [\n    \"J\",\n    { lineSegments: \"V10 H20 V11 V01 I11\", polyLines: \"1,0 2,0 2,1 1,1 0,1\" },\n  ],\n  [\n    \"L\",\n    {\n      lineSegments: \"V00 V10 V20 H30 I10 I20\",\n      polyLines: \"0,0 1,0 2,0 3,0 3,1\",\n    },\n  ],\n  [\n    \"N\",\n    { lineSegments: \"V20 H20 V01 V11 I11\", polyLines: \"3,0 2,0 2,1 1,1 0,1\" },\n  ],\n  [\"O\", { lineSegments: \"H00 V01 H10 V00\", polyLines: \"0,0 0,1 1,1 1,0 0,0\" }],\n  [\"P\", { lineSegments: \"H00 V01 H10 V10\", polyLines: \"0,0 0,1 1,1 1,0 2,0\" }],\n  [\n    \"R\",\n    {\n      lineSegments: \"H10 V11 V01 H01\",\n      polyLines: \"1,0 1,1 2,1|1,0 1,1 0,1 0,2\",\n    },\n  ],\n  [\n    \"T\",\n    {\n      lineSegments: \"H00 H01 V01 V11 I11\",\n      polyLines: \"0,0 0,1 1,1 2,1|0,2 0,1 1,1 2,1\",\n    },\n  ],\n  [\n    \"U\",\n    { lineSegments: \"V00 H10 H11 V02 I11\", polyLines: \"0,0 1,0 1,1 1,2 0,2\" },\n  ],\n  [\n    \"V\",\n    {\n      lineSegments: \"V00 V10 H20 H21 I10 I21\",\n      polyLines: \"0,0 1,0 2,0 2,1 2,2\",\n    },\n  ],\n  [\"W\", { lineSegments: \"V00 H10 V11 H21\", polyLines: \"0,0 1,0 1,1 2,1 2,2\" }],\n  [\n    \"X\",\n    {\n      lineSegments: \"V01 V11 H10 H11\",\n      polyLines: \"1,0 1,1 0,1|0,1 1,1 1,2|1,2 1,1 2,1|2,1 1,1 1,0\",\n    },\n  ],\n  [\n    \"Y\",\n    {\n      lineSegments: \"H10 V01 V11 V21 I21\",\n      polyLines: \"1,0 1,1 0,1|1,0 1,1 2,1 3,1\",\n    },\n  ],\n  [\n    \"Z\",\n    { lineSegments: \"H00 V01 V11 H21 I11\", polyLines: \"0,0 0,1 1,1 2,1 2,2\" },\n  ],\n]);\n\nconst parsePiece = (\n  label: string,\n  lineSegmentDescriptions: string,\n  polyLineDescriptions: string\n): Piece => {\n  const horizontals: Coords[] = [];\n  const verticals: Coords[] = [];\n  const junctions: Coords[] = [];\n  const polyLines = parsePolyLineDescriptions(polyLineDescriptions);\n\n  const bits = lineSegmentDescriptions\n    .split(/\\s/)\n    .map((s) => s.trim())\n    .filter(Boolean);\n\n  for (const bit of bits) {\n    const type = bit[0];\n    const row = Number(bit[1]);\n    const col = Number(bit[2]);\n    const coords = { row, col };\n    switch (type) {\n      case \"H\":\n        horizontals.push(coords);\n        break;\n      case \"V\":\n        verticals.push(coords);\n        break;\n      case \"I\":\n        junctions.push(coords);\n        break;\n    }\n  }\n\n  return { label, horizontals, verticals, junctions, polyLines: polyLines };\n};\n\nconst parsePolyLineDescriptions = (\n  polyLineDescriptions: string\n): Coords[][] => {\n  return polyLineDescriptions\n    .split(\"|\")\n    .map((s) => s.trim())\n    .filter(Boolean)\n    .map(parsePolyLineDescription);\n};\n\nconst parsePolyLineDescription = (polyLineDescription: string): Coords[] => {\n  return polyLineDescription\n    .split(/\\s/)\n    .map((s) => s.trim())\n    .filter(Boolean)\n    .map((coordsString) => {\n      const row = Number(coordsString[0]);\n      const col = Number(coordsString[2]);\n      return { row, col };\n    });\n};\n\nexport const pieces = Array.from(piecesMap).map(\n  ([label, { lineSegments, polyLines }]) =>\n    parsePiece(label, lineSegments, polyLines)\n);\n","import { Coords, coordsComparer } from \"types\";\nimport { maxBy } from \"utils\";\nimport { Orientation, rotateCW as rotateOrientationCW } from \"./orientation\";\n\nexport type Variation = {\n  orientation: Orientation;\n  reflected: boolean;\n  horizontals: Coords[];\n  verticals: Coords[];\n  junctions: Coords[];\n  polyLines: Coords[][];\n};\n\nexport const getDimensions = (\n  variation: Variation\n): { width: number; height: number } => {\n  const width = variation.horizontals.length\n    ? maxBy(variation.horizontals, (h) => h.col) + 1\n    : 0;\n  const height = variation.verticals.length\n    ? maxBy(variation.verticals, (v) => v.row) + 1\n    : 0;\n  return { width, height };\n};\n\nexport const reflect = (variation: Variation): Variation => {\n  const { width } = getDimensions(variation);\n  const newHorizontals = variation.horizontals.map((c) => ({\n    row: c.row,\n    col: width - c.col - 1,\n  }));\n  const newVerticals = variation.verticals.map((c) => ({\n    row: c.row,\n    col: width - c.col,\n  }));\n  const newJunctions = variation.junctions.map((c) => ({\n    row: c.row,\n    col: width - c.col,\n  }));\n  const newPolyLines = variation.polyLines.map((polyLine) =>\n    polyLine.map((c) => ({ row: c.row, col: width - c.col }))\n  );\n\n  return {\n    orientation: variation.orientation,\n    reflected: !variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines,\n  };\n};\n\nexport const rotateCW = (variation: Variation): Variation => {\n  const { height } = getDimensions(variation);\n  const newHorizontals = variation.verticals.map((c) => ({\n    row: c.col,\n    col: height - c.row - 1,\n  }));\n  const newVerticals = variation.horizontals.map((c) => ({\n    row: c.col,\n    col: height - c.row,\n  }));\n  const newJunctions = variation.junctions.map((c) => ({\n    row: c.col,\n    col: height - c.row,\n  }));\n  const newPolyLines = variation.polyLines.map((polyLine) =>\n    polyLine.map((c) => ({ row: c.col, col: height - c.row }))\n  );\n\n  return {\n    orientation: rotateOrientationCW(variation.orientation),\n    reflected: variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines,\n  };\n};\n\nexport const normalisedRepresentation = (variation: Variation): string => {\n  const sortedHorizontals = variation.horizontals.slice().sort(coordsComparer);\n  const sortedVerticals = variation.verticals.slice().sort(coordsComparer);\n  const hs = sortedHorizontals.map((coords) => `H${coords.row}:${coords.col}`);\n  const vs = sortedVerticals.map((coords) => `V${coords.row}:${coords.col}`);\n  return hs.concat(vs).join(\"-\");\n};\n","import { Orientation } from \"./orientation\";\nimport { Piece } from \"./piece\";\nimport { pieces } from \"./pieces\";\nimport { PieceWithVariations } from \"./piece-with-variations\";\nimport {\n  normalisedRepresentation,\n  reflect,\n  rotateCW,\n  Variation,\n} from \"./variation\";\n\nconst findUniqueVariations = (piece: Piece): PieceWithVariations => {\n  const north = {\n    orientation: Orientation.North,\n    reflected: false,\n    horizontals: piece.horizontals,\n    verticals: piece.verticals,\n    junctions: piece.junctions,\n    polyLines: piece.polyLines,\n  };\n  const northReflected = reflect(north);\n\n  const east = rotateCW(north);\n  const eastReflected = reflect(east);\n\n  const south = rotateCW(east);\n  const southReflected = reflect(south);\n\n  const west = rotateCW(south);\n  const westReflected = reflect(west);\n\n  const allVariations = [\n    north,\n    northReflected,\n    east,\n    eastReflected,\n    south,\n    southReflected,\n    west,\n    westReflected,\n  ];\n\n  const representations = new Set<string>();\n  const uniqueVariations: Variation[] = [];\n  allVariations.forEach((variation) => {\n    const representation = normalisedRepresentation(variation);\n    if (!representations.has(representation)) {\n      representations.add(representation);\n      uniqueVariations.push(variation);\n    }\n  });\n\n  return { label: piece.label, variations: uniqueVariations };\n};\n\nexport const piecesWithVariations = pieces.map(findUniqueVariations);\n","import { IDemo } from \"types\";\nimport { range } from \"utils\";\nimport { InternalRow } from \"./internal-row\";\nimport { PieceWithVariations } from \"./piece-with-variations\";\nimport { piecesWithVariations } from \"./pieces-with-variations\";\nimport { Puzzle } from \"./puzzle\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    return this.allPossiblePiecePlacements(puzzle).filter(\n      this.isValidPiecePlacement\n    );\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow);\n    const horizontalsColumns = this.makeHorizontalsColumns(internalRow);\n    const vertialsColumns = this.makeVerticalsColumns(internalRow);\n    const junctionsColumns = this.makeJunctionsColumns(internalRow);\n    return pieceColumns\n      .concat(horizontalsColumns)\n      .concat(vertialsColumns)\n      .concat(junctionsColumns);\n  }\n\n  getNumPrimaryColumns(_puzzle: Puzzle): number | undefined {\n    const numPieces = 15;\n    const numHorizontals = 30;\n    const numVerticals = 30;\n    return numPieces + numHorizontals + numVerticals;\n  }\n\n  allLocations = range(9).flatMap((row) =>\n    range(9).map((col) => ({ row, col }))\n  );\n\n  getPiecesInPlay(puzzle: Puzzle): PieceWithVariations[] {\n    return piecesWithVariations.filter(\n      (pwv) => pwv.label !== puzzle.pieceToOmit.label\n    );\n  }\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    const { location } = internalRow;\n\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row;\n      const col = location.col + horizontal.col;\n      if (row > 5) return false; // valid rows for horizontal line segments: 0..5\n      if (col > 4) return false; // valid cols for horizontal line segments: 0..4\n    }\n\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row;\n      const col = location.col + vertical.col;\n      if (row > 4) return false; // valid rows for vertical line segments: 0..4\n      if (col > 5) return false; // valid cols for vertical line segments: 0..5\n    }\n\n    return true;\n  }\n\n  allPossiblePiecePlacements(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n    const fixedPieceLabels = piecesWithVariations\n      .slice()\n      .reverse()\n      .slice(0, 1)\n      .map(({ label }) => label);\n    const piecesInPlay = this.getPiecesInPlay(puzzle);\n\n    for (const pieceWithVariations of piecesInPlay) {\n      const variations = fixedPieceLabels.includes(pieceWithVariations.label)\n        ? pieceWithVariations.variations.slice(0, 1)\n        : pieceWithVariations.variations;\n\n      for (const variation of variations) {\n        for (const location of this.allLocations) {\n          const label = pieceWithVariations.label;\n          const internalRow = { puzzle, label, variation, location };\n          internalRows.push(internalRow);\n        }\n      }\n    }\n\n    return internalRows;\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const piecesInPlay = this.getPiecesInPlay(internalRow.puzzle);\n    const columns = Array(piecesInPlay.length).fill(0);\n    const index = piecesInPlay.findIndex(\n      (pip) => pip.label === internalRow.label\n    );\n    columns[index] = 1;\n    return columns;\n  }\n\n  makeHorizontalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow;\n    const columns = Array(30).fill(0);\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row;\n      const col = location.col + horizontal.col;\n      columns[row * 5 + col] = 1;\n    }\n    return columns;\n  }\n\n  makeVerticalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow;\n    const columns = Array(30).fill(0);\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row;\n      const col = location.col + vertical.col;\n      columns[col * 5 + row] = 1;\n    }\n    return columns;\n  }\n\n  makeJunctionsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow;\n    const columns = Array(16).fill(0);\n    for (const junction of internalRow.variation.junctions) {\n      const row = location.row + junction.row;\n      const col = location.col + junction.col;\n      if (row > 0 && row < 5 && col > 0 && col < 5) {\n        columns[(row - 1) * 4 + col - 1] = 1;\n      }\n    }\n    return columns;\n  }\n}\n","import { Coords, goLeft, sameCoords } from \"types\";\nimport { range } from \"utils\";\n\nexport const allHorizontals: Coords[] = range(10)\n  .flatMap((row) => range(9).map((col) => ({ row, col })))\n  .filter(({ row, col }) => {\n    const centreRelativeRow = row - 4.5;\n    const centreRelativeCol = col - 4.0;\n    return Math.abs(centreRelativeRow) + Math.abs(centreRelativeCol) <= 5;\n  });\n\nexport const allVerticals: Coords[] = range(9)\n  .flatMap((row) => range(10).map((col) => ({ row, col })))\n  .filter(({ row, col }) => {\n    const centreRelativeRow = row - 4.0;\n    const centreRelativeCol = col - 4.5;\n    return Math.abs(centreRelativeRow) + Math.abs(centreRelativeCol) <= 5;\n  });\n\nexport const allJunctions: Coords[] = allHorizontals.filter((h1) =>\n  allHorizontals.some((h2) => sameCoords(goLeft(h1), h2))\n);\n\nexport const allLocations: Coords[] = allHorizontals.concat(\n  allVerticals.filter((v) => !allHorizontals.some((h) => sameCoords(v, h)))\n);\n","export enum RunType {\n  Horizontal,\n  Vertical,\n}\n","import { Coords } from \"types\";\nimport { Piece } from \"./piece\";\n\nconst twoSidedPiecesMap = new Map<\n  string,\n  { lineSegments: string; polyLines: string }\n>([\n  [\n    \"I\",\n    {\n      lineSegments: \"V00 V10 V20 V30 I10 I20 I30\",\n      polyLines: \"0,0 1,0 2,0 3,0 4,0\",\n    },\n  ],\n  [\"O\", { lineSegments: \"H00 V01 H10 V00\", polyLines: \"0,0 0,1 1,1 1,0 0,0\" }],\n  [\n    \"T\",\n    {\n      lineSegments: \"H00 H01 V01 V11 I11\",\n      polyLines: \"0,0 0,1 1,1 2,1|0,2 0,1 1,1 2,1\",\n    },\n  ],\n  [\n    \"U\",\n    { lineSegments: \"V00 H10 H11 V02 I11\", polyLines: \"0,0 1,0 1,1 1,2 0,2\" },\n  ],\n  [\n    \"V\",\n    {\n      lineSegments: \"V00 V10 H20 H21 I10 I21\",\n      polyLines: \"0,0 1,0 2,0 2,1 2,2\",\n    },\n  ],\n  [\"W\", { lineSegments: \"V00 H10 V11 H21\", polyLines: \"0,0 1,0 1,1 2,1 2,2\" }],\n  [\n    \"X\",\n    {\n      lineSegments: \"V01 V11 H10 H11\",\n      polyLines: \"1,0 1,1 0,1|0,1 1,1 1,2|1,2 1,1 2,1|2,1 1,1 1,0\",\n    },\n  ],\n]);\n\nconst oneSidedPiecesMap = new Map<\n  string,\n  { lineSegments: string; polyLines: string }\n>([\n  [\n    \"F\",\n    {\n      lineSegments: \"H00 V00 H10 V10\",\n      polyLines: \"0,1 0,0 1,0 1,1|1,1 1,0 2,0\",\n    },\n  ],\n  [\n    \"H\",\n    {\n      lineSegments: \"V00 V10 H10 V11\",\n      polyLines: \"0,0 1,0 1,1 2,1|2,0 1,0 1,1 2,1\",\n    },\n  ],\n  [\n    \"J\",\n    { lineSegments: \"V10 H20 V11 V01 I11\", polyLines: \"1,0 2,0 2,1 1,1 0,1\" },\n  ],\n  [\n    \"L\",\n    {\n      lineSegments: \"V00 V10 V20 H30 I10 I20\",\n      polyLines: \"0,0 1,0 2,0 3,0 3,1\",\n    },\n  ],\n  [\n    \"N\",\n    { lineSegments: \"V20 H20 V01 V11 I11\", polyLines: \"3,0 2,0 2,1 1,1 0,1\" },\n  ],\n  [\"P\", { lineSegments: \"H00 V01 H10 V10\", polyLines: \"0,0 0,1 1,1 1,0 2,0\" }],\n  [\n    \"R\",\n    {\n      lineSegments: \"H10 V11 V01 H01\",\n      polyLines: \"1,0 1,1 2,1|1,0 1,1 0,1 0,2\",\n    },\n  ],\n  [\n    \"Y\",\n    {\n      lineSegments: \"H10 V01 V11 V21 I21\",\n      polyLines: \"1,0 1,1 0,1|1,0 1,1 2,1 3,1\",\n    },\n  ],\n  [\n    \"Z\",\n    { lineSegments: \"H00 V01 V11 H21 I11\", polyLines: \"0,0 0,1 1,1 2,1 2,2\" },\n  ],\n]);\n\nconst parsePiece = (\n  label: string,\n  lineSegmentDescriptions: string,\n  polyLineDescriptions: string\n): Piece => {\n  const horizontals: Coords[] = [];\n  const verticals: Coords[] = [];\n  const junctions: Coords[] = [];\n  const polyLines = parsePolyLineDescriptions(polyLineDescriptions);\n\n  const bits = lineSegmentDescriptions\n    .split(/\\s/)\n    .map((s) => s.trim())\n    .filter(Boolean);\n\n  for (const bit of bits) {\n    const type = bit[0];\n    const row = Number(bit[1]);\n    const col = Number(bit[2]);\n    const coords = { row, col };\n    switch (type) {\n      case \"H\":\n        horizontals.push(coords);\n        break;\n      case \"V\":\n        verticals.push(coords);\n        break;\n      case \"I\":\n        junctions.push(coords);\n        break;\n    }\n  }\n\n  return { label, horizontals, verticals, junctions, polyLines: polyLines };\n};\n\nconst parsePolyLineDescriptions = (\n  polyLineDescriptions: string\n): Coords[][] => {\n  return polyLineDescriptions\n    .split(\"|\")\n    .map((s) => s.trim())\n    .filter(Boolean)\n    .map(parsePolyLineDescription);\n};\n\nconst parsePolyLineDescription = (polyLineDescription: string): Coords[] => {\n  return polyLineDescription\n    .split(/\\s/)\n    .map((s) => s.trim())\n    .filter(Boolean)\n    .map((coordsString) => {\n      const row = Number(coordsString[0]);\n      const col = Number(coordsString[2]);\n      return { row, col };\n    });\n};\n\nexport const twoSidedPieces = Array.from(twoSidedPiecesMap).map(\n  ([label, { lineSegments, polyLines }]) =>\n    parsePiece(label, lineSegments, polyLines)\n);\n\nexport const oneSidedPieces = Array.from(oneSidedPiecesMap).map(\n  ([label, { lineSegments, polyLines }]) =>\n    parsePiece(label, lineSegments, polyLines)\n);\n","import { Coords, coordsComparer } from \"types\";\nimport { maxBy } from \"utils\";\nimport { Orientation, rotateCW as rotateOrientationCW } from \"./orientation\";\n\nexport type Variation = {\n  orientation: Orientation;\n  reflected: boolean;\n  horizontals: Coords[];\n  verticals: Coords[];\n  junctions: Coords[];\n  polyLines: Coords[][];\n};\n\nexport const getDimensions = (\n  variation: Variation\n): { width: number; height: number } => {\n  const width = variation.horizontals.length\n    ? maxBy(variation.horizontals, (h) => h.col) + 1\n    : 0;\n  const height = variation.verticals.length\n    ? maxBy(variation.verticals, (v) => v.row) + 1\n    : 0;\n  return { width, height };\n};\n\nexport const reflect = (variation: Variation): Variation => {\n  const { width } = getDimensions(variation);\n  const newHorizontals = variation.horizontals.map((c) => ({\n    row: c.row,\n    col: width - c.col - 1,\n  }));\n  const newVerticals = variation.verticals.map((c) => ({\n    row: c.row,\n    col: width - c.col,\n  }));\n  const newJunctions = variation.junctions.map((c) => ({\n    row: c.row,\n    col: width - c.col,\n  }));\n  const newPolyLines = variation.polyLines.map((polyLine) =>\n    polyLine.map((c) => ({ row: c.row, col: width - c.col }))\n  );\n\n  return {\n    orientation: variation.orientation,\n    reflected: !variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines,\n  };\n};\n\nexport const rotateCW = (variation: Variation): Variation => {\n  const { height } = getDimensions(variation);\n  const newHorizontals = variation.verticals.map((c) => ({\n    row: c.col,\n    col: height - c.row - 1,\n  }));\n  const newVerticals = variation.horizontals.map((c) => ({\n    row: c.col,\n    col: height - c.row,\n  }));\n  const newJunctions = variation.junctions.map((c) => ({\n    row: c.col,\n    col: height - c.row,\n  }));\n  const newPolyLines = variation.polyLines.map((polyLine) =>\n    polyLine.map((c) => ({ row: c.col, col: height - c.row }))\n  );\n\n  return {\n    orientation: rotateOrientationCW(variation.orientation),\n    reflected: variation.reflected,\n    horizontals: newHorizontals,\n    verticals: newVerticals,\n    junctions: newJunctions,\n    polyLines: newPolyLines,\n  };\n};\n\nexport const normalisedRepresentation = (variation: Variation): string => {\n  const sortedHorizontals = variation.horizontals.slice().sort(coordsComparer);\n  const sortedVerticals = variation.verticals.slice().sort(coordsComparer);\n  const hs = sortedHorizontals.map((coords) => `H${coords.row}:${coords.col}`);\n  const vs = sortedVerticals.map((coords) => `V${coords.row}:${coords.col}`);\n  return hs.concat(vs).join(\"-\");\n};\n","import { Orientation } from \"./orientation\";\nimport { Piece } from \"./piece\";\nimport { twoSidedPieces, oneSidedPieces } from \"./pieces\";\nimport { PieceWithVariations } from \"./piece-with-variations\";\nimport {\n  normalisedRepresentation,\n  reflect,\n  rotateCW,\n  Variation,\n} from \"./variation\";\n\nconst makeVariations = (\n  piece: Piece,\n  wantReflected: boolean\n): PieceWithVariations => {\n  const baseVariation = {\n    orientation: Orientation.North,\n    reflected: false,\n    horizontals: piece.horizontals,\n    verticals: piece.verticals,\n    junctions: piece.junctions,\n    polyLines: piece.polyLines,\n  };\n\n  const north = wantReflected ? reflect(baseVariation) : baseVariation;\n  const east = rotateCW(north);\n  const south = rotateCW(east);\n  const west = rotateCW(south);\n\n  const allVariations = [north, east, south, west];\n\n  const representations = new Set<string>();\n  const uniqueVariations: Variation[] = [];\n  allVariations.forEach((variation) => {\n    const representation = normalisedRepresentation(variation);\n    if (!representations.has(representation)) {\n      representations.add(representation);\n      uniqueVariations.push(variation);\n    }\n  });\n\n  return { label: piece.label, variations: uniqueVariations };\n};\n\nconst makeUnreflectedVariations = (piece: Piece) =>\n  makeVariations(piece, false);\nconst makeReflectedVariations = (piece: Piece) => makeVariations(piece, true);\n\nexport const piecesWithVariations: PieceWithVariations[] = twoSidedPieces\n  .map(makeUnreflectedVariations)\n  .concat(oneSidedPieces.map(makeUnreflectedVariations))\n  .concat(oneSidedPieces.map(makeReflectedVariations));\n","import { Orientation } from \"./orientation\";\nimport { Drawing } from \"./drawing\";\nimport { InternalRow } from \"./internal-row\";\nimport { piecesWithVariations } from \"./pieces-with-variations\";\n\nexport const Thumbnail = () => {\n  const { puzzle, solutionInternalRows } = makeThumbnailSolution();\n  const drawingOptions = {};\n\n  return (\n    <Drawing\n      puzzle={puzzle}\n      solutionInternalRows={solutionInternalRows}\n      drawingOptions={drawingOptions}\n    />\n  );\n};\n\nexport const makeThumbnailSolution = () => {\n  const puzzle = {};\n  const solutionInternalRows = makeSolution();\n  return { puzzle, solutionInternalRows };\n};\n\nconst makeSolution = (): InternalRow[] => {\n  return [\n    makeSolutionInternalRow(\"I\", Orientation.North, false, 3, 2),\n    makeSolutionInternalRow(\"O\", Orientation.North, false, 4, 8),\n    makeSolutionInternalRow(\"T\", Orientation.North, false, 3, 5),\n    makeSolutionInternalRow(\"U\", Orientation.West, false, 2, 6),\n    makeSolutionInternalRow(\"V\", Orientation.South, false, 1, 4),\n    makeSolutionInternalRow(\"W\", Orientation.East, false, 2, 1),\n    makeSolutionInternalRow(\"X\", Orientation.North, false, 5, 2),\n\n    makeSolutionInternalRow(\"F\", Orientation.West, false, 5, 6),\n    makeSolutionInternalRow(\"H\", Orientation.South, false, 2, 4),\n    makeSolutionInternalRow(\"J\", Orientation.South, false, 0, 4),\n    makeSolutionInternalRow(\"L\", Orientation.North, false, 6, 4),\n    makeSolutionInternalRow(\"N\", Orientation.East, false, 3, 3),\n    makeSolutionInternalRow(\"P\", Orientation.North, false, 3, 7),\n    makeSolutionInternalRow(\"R\", Orientation.East, false, 3, 2),\n    makeSolutionInternalRow(\"Y\", Orientation.East, false, 1, 3),\n    makeSolutionInternalRow(\"Z\", Orientation.East, false, 6, 5),\n\n    makeSolutionInternalRow(\"F\", Orientation.South, true, 4, 1),\n    makeSolutionInternalRow(\"H\", Orientation.West, true, 7, 2),\n    makeSolutionInternalRow(\"J\", Orientation.East, true, 4, 0),\n    makeSolutionInternalRow(\"L\", Orientation.West, true, 5, 5),\n    makeSolutionInternalRow(\"N\", Orientation.North, true, 4, 5),\n    makeSolutionInternalRow(\"P\", Orientation.South, true, 5, 4),\n    makeSolutionInternalRow(\"R\", Orientation.East, true, 7, 4),\n    makeSolutionInternalRow(\"Y\", Orientation.West, true, 4, 2),\n    makeSolutionInternalRow(\"Z\", Orientation.North, true, 1, 2),\n  ];\n};\n\nconst makeSolutionInternalRow = (\n  label: string,\n  orientation: Orientation,\n  reflected: boolean,\n  row: number,\n  col: number\n): InternalRow => {\n  for (const pwv of piecesWithVariations) {\n    if (pwv.label === label) {\n      const variation = pwv.variations.find(\n        (v) => v.orientation === orientation && v.reflected === reflected\n      );\n      if (variation) {\n        const location = { row, col };\n        return { label, variation, location };\n      }\n    }\n  }\n  throw new Error(\"[makeSolutionInternalRow] failed to find variation\");\n};\n","import { Coords, DrawingProps, EmptyPuzzle, sameCoords } from \"types\";\nimport { first, last, range } from \"utils\";\nimport { InternalRow } from \"./internal-row\";\nimport { allHorizontals, allVerticals } from \"./locations\";\n\nconst VIEWBOX_WIDTH = 100;\nconst VIEWBOX_HEIGHT = 100;\n\nconst GRID_LINE_FULL_THICKNESS = 1;\nconst TETRASTICK_FULL_THICKNESS = GRID_LINE_FULL_THICKNESS * 1.5;\nconst TETRASTICK_HALF_THICKNESS = TETRASTICK_FULL_THICKNESS / 2;\n\nconst GRID_LINE_COLOUR = \"#80808080\";\n\nconst SQUARE_WIDTH = (VIEWBOX_WIDTH - TETRASTICK_FULL_THICKNESS) / 9;\nconst SQUARE_HEIGHT = (VIEWBOX_HEIGHT - TETRASTICK_FULL_THICKNESS) / 9;\n\nconst calculateX = (col: number) =>\n  col * SQUARE_WIDTH + TETRASTICK_HALF_THICKNESS;\nconst calculateY = (row: number) =>\n  row * SQUARE_HEIGHT + TETRASTICK_HALF_THICKNESS;\n\nconst calculatePoint = (location: Coords, coords: Coords) => [\n  calculateX(location.col + coords.col),\n  calculateY(location.row + coords.row),\n];\n\nconst tetraStickColours = new Map<string, string>([\n  [\"F\", \"#FF7366\"],\n  [\"H\", \"#00E61A\"],\n  [\"I\", \"#660066\"],\n  [\"J\", \"#E6E6FF\"],\n  [\"L\", \"#596673\"],\n  [\"N\", \"#FFFF00\"],\n  [\"O\", \"#CCCC1A\"],\n  [\"P\", \"#994D33\"],\n  [\"R\", \"#9926B2\"],\n  [\"T\", \"#3300B2\"],\n  [\"U\", \"#FF2699\"],\n  [\"V\", \"#00FFFF\"],\n  [\"W\", \"#CCFF00\"],\n  [\"X\", \"#E60000\"],\n  [\"Y\", \"#6659E6\"],\n  [\"Z\", \"#008000\"],\n]);\n\ntype LocalDrawingProps = DrawingProps<EmptyPuzzle, InternalRow>;\n\nexport const Drawing: React.FunctionComponent<LocalDrawingProps> = ({\n  solutionInternalRows,\n}: LocalDrawingProps) => {\n  const drawHorizontalGridLines = (): JSX.Element[] => {\n    return allHorizontals.map((coords) => {\n      const { row, col } = coords;\n      const x1 = calculateX(col) + TETRASTICK_FULL_THICKNESS;\n      const x2 = calculateX(col + 1) - TETRASTICK_FULL_THICKNESS;\n      const y = calculateY(row);\n\n      return (\n        <line\n          key={`horizontal-grid-line-${row}-${col}`}\n          x1={x1}\n          y1={y}\n          x2={x2}\n          y2={y}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      );\n    });\n  };\n\n  const drawVerticalGridLines = (): JSX.Element[] => {\n    return allVerticals.map((coords) => {\n      const { row, col } = coords;\n      const x = calculateX(col);\n      const y1 = calculateY(row) + TETRASTICK_FULL_THICKNESS;\n      const y2 = calculateY(row + 1) - TETRASTICK_FULL_THICKNESS;\n      return (\n        <line\n          key={`vertical-grid-line-${row}-${col}`}\n          x1={x}\n          y1={y1}\n          x2={x}\n          y2={y2}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      );\n    });\n  };\n\n  const drawTetraSticks = (): JSX.Element[] => {\n    return solutionInternalRows.flatMap(drawTetraStick);\n  };\n\n  const LINE_END_MULTIPLIER = 3;\n  const ROUNDED_CORNER_MULTIPLIER = 4;\n\n  const insetPoint =\n    (multiplier: number) =>\n    (coords1: Coords, coords2: Coords, point: number[]): number[] => {\n      const rowDiff = coords2.row - coords1.row;\n      const colDiff = coords2.col - coords1.col;\n      const verticalInset = TETRASTICK_HALF_THICKNESS * multiplier;\n      const horizontalInset = TETRASTICK_HALF_THICKNESS * multiplier;\n      const [x, y] = point;\n      if (rowDiff === 1 && colDiff === 0) return [x, y + verticalInset];\n      if (rowDiff === -1 && colDiff === 0) return [x, y - verticalInset];\n      if (rowDiff === 0 && colDiff === 1) return [x + horizontalInset, y];\n      if (rowDiff === 0 && colDiff === -1) return [x - horizontalInset, y];\n      return point;\n    };\n\n  const insetLineStart = insetPoint(LINE_END_MULTIPLIER);\n  const insetLineEnd = insetPoint(LINE_END_MULTIPLIER);\n  const insetRoundedCornerStart = insetPoint(ROUNDED_CORNER_MULTIPLIER);\n  const insetRoundedCornerEnd = insetPoint(ROUNDED_CORNER_MULTIPLIER);\n\n  // https://stackoverflow.com/a/40444735\n  // const angle = ([a,b],[c,d],[e,f]) => (Math.atan2(f-d,e-c)-Math.atan2(b-d,a-c)+3*pi)%(2*pi)-pi;\n  // const sweepFl = (S,V,E) => angle(E,S,V) > 0 ? 0 : 1;\n  const angle = (S: Coords, V: Coords, E: Coords) => {\n    const { row: b, col: a } = E;\n    const { row: d, col: c } = S;\n    const { row: f, col: e } = V;\n    return (\n      ((Math.atan2(f - d, e - c) - Math.atan2(b - d, a - c) + 3 * Math.PI) %\n        (2 * Math.PI)) -\n      Math.PI\n    );\n  };\n\n  const moveTo = (point: number[]): string => {\n    const [x, y] = point;\n    return `M${x},${y}`;\n  };\n\n  const lineTo = (point: number[]): string => {\n    const [x, y] = point;\n    return `L${x},${y}`;\n  };\n\n  const roundedCornerTo = (\n    S: Coords,\n    V: Coords,\n    E: Coords,\n    point: number[]\n  ): string => {\n    const r = TETRASTICK_HALF_THICKNESS * ROUNDED_CORNER_MULTIPLIER;\n    const largeArcFlag = 0;\n    const sweepFlag = angle(S, V, E) < 0 ? 1 : 0;\n    const [x, y] = point;\n    return `A${r},${r},0,${largeArcFlag},${sweepFlag},${x},${y}`;\n  };\n\n  const drawTetraStick = (internalRow: InternalRow): JSX.Element[] => {\n    const { label, variation, location } = internalRow;\n    const colour = tetraStickColours.get(label);\n\n    const pathData: string[] = [];\n\n    for (const polyLine of variation.polyLines) {\n      const isClosed = sameCoords(first(polyLine), last(polyLine));\n      const pathCommands: string[] = [];\n\n      if (isClosed) {\n        const roundedCornerStart = insetRoundedCornerStart(\n          polyLine[0],\n          polyLine[1],\n          calculatePoint(location, polyLine[0])\n        );\n        pathCommands.push(moveTo(roundedCornerStart));\n      } else {\n        const lineStart = insetLineStart(\n          polyLine[0],\n          polyLine[1],\n          calculatePoint(location, polyLine[0])\n        );\n        pathCommands.push(moveTo(lineStart));\n      }\n\n      const indices = range(polyLine.length).slice(1).slice(0, -1);\n      for (const index of indices) {\n        const coords = polyLine[index];\n        const coordsPrev = polyLine[index - 1];\n        const coordsNext = polyLine[index + 1];\n        const point = calculatePoint(location, coords);\n\n        if (\n          coordsPrev.row === coordsNext.row ||\n          coordsPrev.col === coordsNext.col\n        ) {\n          pathCommands.push(lineTo(point));\n        } else {\n          const roundedCornerStart = insetRoundedCornerStart(\n            coords,\n            coordsPrev,\n            point\n          );\n          pathCommands.push(lineTo(roundedCornerStart));\n\n          const roundedCornerEnd = insetRoundedCornerEnd(\n            coords,\n            coordsNext,\n            point\n          );\n          pathCommands.push(\n            roundedCornerTo(coordsPrev, coords, coordsNext, roundedCornerEnd)\n          );\n        }\n      }\n\n      if (isClosed) {\n        const coords = polyLine[0];\n        const coordsPrev = polyLine.slice(-2)[0]; // not -1 because -1 is the same coords as point 0\n        const coordsNext = polyLine[1];\n        const point = calculatePoint(location, coords);\n\n        const roundedCornerStart = insetRoundedCornerStart(\n          coords,\n          coordsPrev,\n          point\n        );\n        pathCommands.push(lineTo(roundedCornerStart));\n\n        const firstPoint = insetRoundedCornerStart(\n          polyLine[0],\n          polyLine[1],\n          calculatePoint(location, coords)\n        );\n        pathCommands.push(\n          roundedCornerTo(coordsPrev, coords, coordsNext, firstPoint)\n        );\n      } else {\n        const lineEnd = insetLineEnd(\n          polyLine.slice(-1)[0],\n          polyLine.slice(-2)[0],\n          calculatePoint(location, polyLine.slice(-1)[0])\n        );\n        pathCommands.push(lineTo(lineEnd));\n      }\n\n      pathData.push(pathCommands.join(\" \"));\n    }\n\n    const elements: JSX.Element[] = [];\n\n    pathData.forEach((d, index) => {\n      const path = (\n        <path\n          key={`tetrastick-${label}-${variation.orientation}-${variation.reflected}-${index}`}\n          d={d}\n          stroke={colour}\n          strokeWidth={TETRASTICK_FULL_THICKNESS}\n          strokeLinecap=\"round\"\n          fill=\"none\"\n        />\n      );\n      elements.push(path);\n    });\n\n    return elements;\n  };\n\n  return (\n    <svg viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`}>\n      {drawHorizontalGridLines()}\n      {drawVerticalGridLines()}\n      {drawTetraSticks()}\n    </svg>\n  );\n};\n","import { EmptyPuzzle, IDemo, sameCoords } from \"types\";\nimport { range } from \"utils\";\nimport { InternalRow } from \"./internal-row\";\nimport { allHorizontals, allJunctions, allVerticals } from \"./locations\";\nimport { piecesWithVariations } from \"./pieces-with-variations\";\nimport { makeThumbnailSolution } from \"./thumbnail\";\n\nexport class Demo implements IDemo<EmptyPuzzle, InternalRow> {\n  buildInternalRows(\n    _puzzle: EmptyPuzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    return this.allPossiblePiecePlacements(5).filter(\n      this.isValidPiecePlacement\n    );\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const pieceColumns = this.makePieceColumns(internalRow);\n    const horizontalsColumns = this.makeHorizontalsColumns(internalRow);\n    const vertialsColumns = this.makeVerticalsColumns(internalRow);\n    const junctionsColumns = this.makeJunctionsColumns(internalRow);\n    return pieceColumns\n      .concat(horizontalsColumns)\n      .concat(vertialsColumns)\n      .concat(junctionsColumns);\n  }\n\n  getNumPrimaryColumns(_puzzle: EmptyPuzzle): number | undefined {\n    const numPieces = piecesWithVariations.length;\n    const numHorizontals = allHorizontals.length;\n    const numVerticals = allVerticals.length;\n    return numPieces + numHorizontals + numVerticals;\n  }\n\n  isValidPiecePlacement(internalRow: InternalRow): boolean {\n    const { location } = internalRow;\n\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row;\n      const col = location.col + horizontal.col;\n      const coords = { row, col };\n      if (!allHorizontals.some((h) => sameCoords(h, coords))) return false;\n    }\n\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row;\n      const col = location.col + vertical.col;\n      const coords = { row, col };\n      if (!allVerticals.some((v) => sameCoords(v, coords))) return false;\n    }\n\n    return true;\n  }\n\n  allPossiblePiecePlacements(numFixedPieces: number): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n    const { solutionInternalRows } = makeThumbnailSolution();\n    const fixedInternalRows = solutionInternalRows.slice(0, numFixedPieces);\n\n    for (const pieceWithVariations of piecesWithVariations) {\n      const fixedInternalRow = fixedInternalRows.find(\n        (fir) =>\n          fir.label === pieceWithVariations.label &&\n          fir.variation.reflected ===\n            pieceWithVariations.variations[0].reflected\n      );\n\n      if (fixedInternalRow) {\n        internalRows.push(fixedInternalRow);\n        continue;\n      }\n\n      const allLocationsInBoundingSquare = range(9).flatMap((row) =>\n        range(9).map((col) => ({ row, col }))\n      );\n\n      for (const variation of pieceWithVariations.variations) {\n        for (const location of allLocationsInBoundingSquare) {\n          const label = pieceWithVariations.label;\n          const internalRow = { label, variation, location };\n          internalRows.push(internalRow);\n        }\n      }\n    }\n\n    return internalRows;\n  }\n\n  makePieceColumns(internalRow: InternalRow): number[] {\n    const columns = Array(piecesWithVariations.length).fill(0);\n    const index = piecesWithVariations.findIndex(\n      (pwv) =>\n        pwv.label === internalRow.label &&\n        pwv.variations[0].reflected === internalRow.variation.reflected\n    );\n    columns[index] = 1;\n    return columns;\n  }\n\n  makeHorizontalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow;\n    const columns = Array(allHorizontals.length).fill(0);\n    for (const horizontal of internalRow.variation.horizontals) {\n      const row = location.row + horizontal.row;\n      const col = location.col + horizontal.col;\n      const coords = { row, col };\n      const index = allHorizontals.findIndex((h) => sameCoords(h, coords));\n      if (index >= 0) {\n        columns[index] = 1;\n      }\n    }\n    return columns;\n  }\n\n  makeVerticalsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow;\n    const columns = Array(allVerticals.length).fill(0);\n    for (const vertical of internalRow.variation.verticals) {\n      const row = location.row + vertical.row;\n      const col = location.col + vertical.col;\n      const coords = { row, col };\n      const index = allVerticals.findIndex((v) => sameCoords(v, coords));\n      if (index >= 0) {\n        columns[index] = 1;\n      }\n    }\n    return columns;\n  }\n\n  makeJunctionsColumns(internalRow: InternalRow): number[] {\n    const { location } = internalRow;\n    const columns = Array(allJunctions.length).fill(0);\n    for (const junction of internalRow.variation.junctions) {\n      const row = location.row + junction.row;\n      const col = location.col + junction.col;\n      const coords = { row, col };\n      const index = allJunctions.findIndex((j) => sameCoords(j, coords));\n      if (index >= 0) {\n        columns[index] = 1;\n      }\n    }\n    return columns;\n  }\n}\n","import { Coords, goDown, goLeft, goRight, goUp, IDemo } from \"types\";\nimport { except, range } from \"utils\";\nimport { InternalRow } from \"./internal-row\";\nimport { Puzzle } from \"./puzzle\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n\n    for (const room of puzzle.rooms) {\n      for (const initialValue of room.initialValues) {\n        const { cell, value } = initialValue;\n        const isInitialValue = true;\n        const internalRow = { puzzle, cell, value, isInitialValue, room };\n        internalRows.push(internalRow);\n      }\n\n      const givenCells = room.initialValues.map(({ cell }) => cell);\n      const givenValues = room.initialValues.map(({ value }) => value);\n      const cellsToSolve = except(room.cells, givenCells);\n      const values = range(room.cells.length).map((n) => n + 1);\n      const valuesToSolve = except(values, givenValues);\n\n      for (const cell of cellsToSolve) {\n        for (const value of valuesToSolve) {\n          const isInitialValue = false;\n          const internalRow = { puzzle, cell, value, isInitialValue, room };\n          internalRows.push(internalRow);\n        }\n      }\n    }\n\n    return internalRows;\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const locationColumns = this.makeLocationColumns(internalRow);\n    const roomColumns = this.makeRoomColumns(internalRow);\n    const rippleColumns = this.makeRippleColumns(internalRow);\n    return locationColumns.concat(roomColumns).concat(rippleColumns);\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    const { size } = puzzle;\n    return size * size * 2;\n  }\n\n  makeLocationColumns(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size;\n    const columns = Array(size * size).fill(0);\n    const { row, col } = internalRow.cell;\n    const index = row * size + col;\n    columns[index] = 1;\n    return columns;\n  }\n\n  makeRoomColumns(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size;\n    const columns = Array(size * size).fill(0);\n    const index = internalRow.room.startIndex + internalRow.value - 1;\n    columns[index] = 1;\n    return columns;\n  }\n\n  makeRippleColumns(internalRow: InternalRow): number[] {\n    const { size, maxValue } = internalRow.puzzle;\n    const arrayOfArrays: number[][] = range(maxValue * 4).map(() =>\n      Array(size * size).fill(0)\n    );\n    const baseIndex = (internalRow.value - 1) * 4;\n\n    const setRippleColumnBits = (\n      baseIndexOffset: number,\n      transformCoords: (coords: Coords) => Coords\n    ): void => {\n      const rippleCells = this.getRippleCells(internalRow, transformCoords);\n      const array = arrayOfArrays[baseIndex + baseIndexOffset];\n      for (const cell of rippleCells) {\n        const index = cell.row * size + cell.col;\n        array[index] = 1;\n      }\n    };\n\n    setRippleColumnBits(0, goUp);\n    setRippleColumnBits(1, goDown);\n    setRippleColumnBits(2, goLeft);\n    setRippleColumnBits(3, goRight);\n\n    return arrayOfArrays.flat();\n  }\n\n  getRippleCells(\n    internalRow: InternalRow,\n    transformCoords: (coords: Coords) => Coords\n  ): Coords[] {\n    const size = internalRow.puzzle.size;\n    let cell = internalRow.cell;\n    const cells: Coords[] = [cell];\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of range(internalRow.value)) {\n      cell = transformCoords(cell);\n      const { row, col } = cell;\n      if (row >= 0 && row < size && col >= 0 && col < size) {\n        cells.push({ row, col });\n      }\n    }\n\n    return cells;\n  }\n}\n","import { Coords, sameCoords, goUp, goDown, goLeft, goRight } from \"types\";\nimport { range } from \"utils\";\nimport { ColourPair } from \"./colour-pair\";\nimport { Puzzle } from \"./puzzle\";\n\nexport const findPaths = (\n  puzzle: Puzzle,\n  colourPair: ColourPair\n): Coords[][] => {\n  const start = colourPair.start;\n  const goal = colourPair.end;\n  const currentPath = [start];\n  const paths: Coords[][] = [];\n  const maxDirectionChanges = puzzle.colourPairs.length;\n\n  findPathsInternal(\n    puzzle,\n    currentPath,\n    paths,\n    start,\n    goal,\n    maxDirectionChanges\n  );\n\n  return paths;\n};\n\n// Inspired by this: https://stackoverflow.com/a/22464491\nconst findPathsInternal = (\n  puzzle: Puzzle,\n  currentPath: Coords[],\n  paths: Coords[][],\n  node: Coords,\n  goal: Coords,\n  maxDirectionChanges: number\n): void => {\n  for (const nextNode of neighbours(puzzle, node, goal)) {\n    if (sameCoords(nextNode, goal)) {\n      const path = [...currentPath, nextNode];\n      if (countDirectionChanges(path) <= maxDirectionChanges) {\n        paths.push(path);\n      }\n    } else {\n      const index = currentPath.findIndex((p) => sameCoords(p, nextNode));\n      if (index < 0) {\n        currentPath.push(nextNode);\n        if (countDirectionChanges(currentPath) <= maxDirectionChanges) {\n          findPathsInternal(\n            puzzle,\n            currentPath,\n            paths,\n            nextNode,\n            goal,\n            maxDirectionChanges\n          );\n        }\n        currentPath.pop();\n      }\n    }\n  }\n};\n\nconst neighbours = (puzzle: Puzzle, node: Coords, goal: Coords): Coords[] => {\n  const dots = puzzle.colourPairs.flatMap((cp) => [cp.start, cp.end]);\n  const isDot = (n: Coords) => dots.findIndex((d) => sameCoords(d, n)) >= 0;\n\n  const ns = [goUp(node), goDown(node), goLeft(node), goRight(node)];\n\n  const isWithinPuzzle = (n: Coords) =>\n    n.row >= 0 && n.row < puzzle.size && n.col >= 0 && n.col < puzzle.size;\n\n  const isEmptyLocationOrGoal = (n: Coords) => !isDot(n) || sameCoords(n, goal);\n\n  return ns.filter(isWithinPuzzle).filter(isEmptyLocationOrGoal);\n};\n\nconst countDirectionChanges = (path: Coords[]): number => {\n  if (path.length < 3) return 0;\n  let count = 0;\n  for (const index of range(path.length).slice(1).slice(0, -1)) {\n    const p1 = path[index - 1];\n    const p3 = path[index + 1];\n    const rowDiff = Math.abs(p3.row - p1.row);\n    const colDiff = Math.abs(p3.col - p1.col);\n    if (rowDiff !== 0 && colDiff !== 0) count++;\n  }\n  return count;\n};\n","import { IDemo } from \"types\";\nimport { InternalRow } from \"./internal-row\";\nimport { Puzzle } from \"./puzzle\";\nimport { findPaths } from \"./path-finder\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n    for (const colourPair of puzzle.colourPairs) {\n      const paths = findPaths(puzzle, colourPair);\n      for (const coordsList of paths) {\n        const internalRow = { puzzle, colourPair, coordsList };\n        internalRows.push(internalRow);\n      }\n    }\n    return internalRows;\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size;\n    const columns = Array(size * size).fill(0);\n    for (const coords of internalRow.coordsList) {\n      const index = coords.row * size + coords.col;\n      columns[index] = 1;\n    }\n    return columns;\n  }\n\n  getNumPrimaryColumns(_puzzle: Puzzle): number | undefined {\n    return undefined;\n  }\n}\n","import { sameCoordsList } from \"types\";\nimport { Coords } from \"types\";\nimport { RunType } from \"./run-type\";\n\nexport type Run = {\n  runType: RunType;\n  coordsList: Coords[];\n  sum: number;\n};\n\nexport const sameRun = (run1: Run, run2: Run): boolean => {\n  return (\n    run1.runType === run2.runType &&\n    run1.sum === run2.sum &&\n    sameCoordsList(run1.coordsList, run2.coordsList)\n  );\n};\n","// https://www.chadgolden.com/blog/finding-all-the-permutations-of-an-array-in-c-sharp\n\nexport const doPermute = (nums: number[]): number[][] => {\n  const permutations: number[][] = [];\n  doPermuteInternal(nums, 0, nums.length - 1, permutations);\n  return permutations;\n};\n\nconst doPermuteInternal = (\n  nums: number[],\n  start: number,\n  end: number,\n  list: number[][]\n): void => {\n  if (start === end) {\n    list.push(nums.slice());\n  } else {\n    for (let i = start; i <= end; i++) {\n      swap(nums, start, i);\n      doPermuteInternal(nums, start + 1, end, list);\n      swap(nums, start, i);\n    }\n  }\n};\n\nconst swap = (nums: number[], index1: number, index2: number): void => {\n  const temp = nums[index1];\n  nums[index1] = nums[index2];\n  nums[index2] = temp;\n};\n","export enum RunGroupType {\n  Horizontal,\n  Vertical,\n}\n","import { Coords, IDemo, sameCoords } from \"types\";\nimport { except, range, sum } from \"utils\";\nimport { InternalRow } from \"./internal-row\";\nimport { Run, sameRun } from \"./run\";\nimport { Puzzle } from \"./puzzle\";\nimport { RunType } from \"./run-type\";\nimport { doPermute } from \"./permutations\";\n\nconst DIGITS = range(9).map((n) => n + 1);\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n\n    const createInternalRowsFor = (runs: Run[]): void => {\n      for (const run of runs) {\n        for (const setOfValues of this.findSetsOfValues(run)) {\n          for (const values of doPermute(setOfValues)) {\n            const internalRow = { puzzle, run, values };\n            internalRows.push(internalRow);\n          }\n        }\n      }\n    };\n\n    createInternalRowsFor(puzzle.horizontalRuns);\n    createInternalRowsFor(puzzle.verticalRuns);\n\n    return internalRows;\n  }\n\n  // Return sets of values where each set of values:\n  // - has length run.CoordsList.Length\n  // - sums to run.Sum\n  // - contains only values 1..9\n  // - does not have any duplicated values\n  // e.g. for run length 3 and sum 10, valid sets of values would be [1,4,5], [2,3,5], [1,3,6], etc\n  findSetsOfValues(run: Run): number[][] {\n    const setsOfValues: number[][] = [];\n\n    const helper = (\n      n: number,\n      useds: number[][],\n      setOfValues: number[]\n    ): void => {\n      const remainingDigits = except(DIGITS, useds.flat());\n      const used: number[] = [];\n      useds.push(used);\n      for (const digit of remainingDigits) {\n        setOfValues.push(digit);\n        used.push(digit);\n        if (n > 1) {\n          helper(n - 1, useds, setOfValues);\n        } else {\n          if (sum(setOfValues) === run.sum) {\n            setsOfValues.push(setOfValues.slice());\n          }\n        }\n        setOfValues.pop();\n      }\n      useds.pop();\n    };\n\n    const runLength = run.coordsList.length;\n    helper(runLength, [], []);\n\n    return setsOfValues;\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, run, values } = internalRow;\n    const horizontalRunColumns = this.makeHorizontalRunColumns(puzzle, run);\n    const verticalRunColumns = this.makeVerticalRunColumns(puzzle, run);\n    const horizontalRunValueColumns = this.makeHorizontalRunValueColumns(\n      puzzle,\n      run,\n      values\n    );\n    const verticalRunValueColumns = this.makeVerticalRunValueColumns(\n      puzzle,\n      run,\n      values\n    );\n    return horizontalRunColumns\n      .concat(verticalRunColumns)\n      .concat(horizontalRunValueColumns)\n      .concat(verticalRunValueColumns);\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRuns.length + puzzle.verticalRuns.length;\n  }\n\n  makeHorizontalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.horizontalRuns.length).fill(0);\n    if (run.runType === RunType.Horizontal) {\n      const index = this.findHorizontalRunIndex(puzzle, run);\n      columns[index] = 1;\n    }\n    return columns;\n  }\n\n  makeVerticalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.verticalRuns.length).fill(0);\n    if (run.runType === RunType.Vertical) {\n      const index = this.findVerticalRunIndex(puzzle, run);\n      columns[index] = 1;\n    }\n    return columns;\n  }\n\n  makeHorizontalRunValueColumns(\n    puzzle: Puzzle,\n    run: Run,\n    values: number[]\n  ): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0);\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index];\n      const encodedValue =\n        run.runType === RunType.Horizontal\n          ? this.encodeValueNormal(value)\n          : this.encodeValueInverse(value);\n      const unknown = run.coordsList[index];\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown);\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] =\n          encodedValue[encodedValueIndex];\n      }\n    }\n    return columns;\n  }\n\n  makeVerticalRunValueColumns(\n    puzzle: Puzzle,\n    run: Run,\n    values: number[]\n  ): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0);\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index];\n      const encodedValue =\n        run.runType === RunType.Vertical\n          ? this.encodeValueNormal(value)\n          : this.encodeValueInverse(value);\n      const unknown = run.coordsList[index];\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown);\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] =\n          encodedValue[encodedValueIndex];\n      }\n    }\n    return columns;\n  }\n\n  encodeValueNormal(value: number): number[] {\n    const columns = Array(9).fill(0);\n    const index = value - 1;\n    columns[index] = 1;\n    return columns;\n  }\n\n  encodeValueInverse(value: number): number[] {\n    const columns = Array(9).fill(1);\n    const index = value - 1;\n    columns[index] = 0;\n    return columns;\n  }\n\n  findHorizontalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.horizontalRuns.findIndex((r) => sameRun(r, run));\n  }\n\n  findVerticalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.verticalRuns.findIndex((r) => sameRun(r, run));\n  }\n\n  findUnknownIndex(puzzle: Puzzle, unknown: Coords): number {\n    return puzzle.unknowns.findIndex((u) => sameCoords(u, unknown));\n  }\n}\n","import { Coords, IDemo, sameCoords } from \"types\";\nimport { except, range, sum } from \"utils\";\nimport { Puzzle } from \"./puzzle\";\nimport { InternalRow } from \"./internal-row\";\nimport { RunGroup } from \"./run-group\";\nimport { RunGroupType } from \"./run-group-type\";\nimport { HorizontalRunGroup } from \"./horizontal-run-group\";\nimport { VerticalRunGroup } from \"./vertical-run-group\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    checkForCancellation: () => boolean\n  ): InternalRow[] {\n    type StartingPositionData = {\n      startingPosition: number;\n      runLength: number;\n    };\n\n    const size = puzzle.size;\n    const internalRows: InternalRow[] = [];\n\n    const buildInternalRowsForRunGroup = (runGroup: RunGroup): void => {\n      const workingSetOfStartingPositions: StartingPositionData[] = [];\n\n      const recursivelyFindSetsOfStartingPositions = (\n        startPosition: number,\n        remainingLengths: number[]\n      ): void => {\n        if (internalRows.length % 1000 === 0) {\n          if (checkForCancellation()) return;\n        }\n\n        if (remainingLengths.length === 0) {\n          if (\n            workingSetOfStartingPositions.length === runGroup.lengths.length\n          ) {\n            const setOfStartingPositions = workingSetOfStartingPositions\n              .slice()\n              .reverse();\n            const coordsLists: Coords[][] = [];\n            for (const startingPositionData of setOfStartingPositions) {\n              const coordsList: Coords[] = [];\n              for (const startingPosition of range(\n                startingPositionData.runLength\n              ).map((x) => x + startingPositionData.startingPosition)) {\n                const coords = this.makeRunGroupCoords(\n                  runGroup,\n                  startingPosition\n                );\n                coordsList.push(coords);\n              }\n              coordsLists.push(coordsList);\n            }\n            const internalRow = { puzzle, runGroup, coordsLists };\n            internalRows.push(internalRow);\n          }\n          return;\n        }\n\n        const runLength = remainingLengths[0];\n        const newRemainingLengths = remainingLengths.slice(1);\n        const sumOfRemainingLengths = sum(newRemainingLengths);\n        const requiredGaps = newRemainingLengths.length;\n        const lastValidStartPosition =\n          size - sumOfRemainingLengths - requiredGaps - runLength;\n        const numValidStartPositions =\n          lastValidStartPosition - startPosition + 1;\n        const validStartPositions = range(numValidStartPositions).map(\n          (x) => x + startPosition\n        );\n\n        for (const validStartPosition of validStartPositions) {\n          const pair = { startingPosition: validStartPosition, runLength };\n          workingSetOfStartingPositions.push(pair);\n\n          const newStartPosition = validStartPosition + runLength + 1;\n          recursivelyFindSetsOfStartingPositions(\n            newStartPosition,\n            newRemainingLengths\n          );\n\n          workingSetOfStartingPositions.pop();\n        }\n      };\n\n      recursivelyFindSetsOfStartingPositions(0, runGroup.lengths);\n    };\n\n    for (const horizontalRunGroup of puzzle.horizontalRunGroups) {\n      buildInternalRowsForRunGroup(horizontalRunGroup);\n    }\n\n    for (const verticalRunGroup of puzzle.verticalRunGroups) {\n      buildInternalRowsForRunGroup(verticalRunGroup);\n    }\n\n    return internalRows;\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRunGroups.length + puzzle.verticalRunGroups.length;\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, runGroup, coordsLists } = internalRow;\n    const rowColumns = this.makeRowColumns(puzzle, runGroup);\n    const colColumns = this.makeColColumns(puzzle, runGroup);\n    const horizontalBlockColumns = this.makeBlockColumns(\n      puzzle,\n      RunGroupType.Horizontal,\n      runGroup,\n      coordsLists\n    );\n    const verticalBlockColumns = this.makeBlockColumns(\n      puzzle,\n      RunGroupType.Vertical,\n      runGroup,\n      coordsLists\n    );\n    return rowColumns\n      .concat(colColumns)\n      .concat(horizontalBlockColumns)\n      .concat(verticalBlockColumns);\n  }\n\n  makeRowColumns(puzzle: Puzzle, runGroup: RunGroup): number[] {\n    const columns = Array(puzzle.horizontalRunGroups.length).fill(0);\n    if (runGroup.runGroupType === RunGroupType.Horizontal) {\n      const horizontalRunGroup = runGroup as HorizontalRunGroup;\n      columns[horizontalRunGroup.row] = 1;\n    }\n    return columns;\n  }\n\n  makeColColumns(puzzle: Puzzle, runGroup: RunGroup): number[] {\n    const columns = Array(puzzle.verticalRunGroups.length).fill(0);\n    if (runGroup.runGroupType === RunGroupType.Vertical) {\n      const verticalRunGroup = runGroup as VerticalRunGroup;\n      columns[verticalRunGroup.col] = 1;\n    }\n    return columns;\n  }\n\n  makeBlockColumns(\n    puzzle: Puzzle,\n    runGroupType: RunGroupType,\n    runGroup: RunGroup,\n    coordsLists: Coords[][]\n  ): number[] {\n    const size = puzzle.size;\n    const columns = Array(size * size * 2).fill(0);\n    const selectedBlockCoords = coordsLists.flat();\n\n    if (runGroup.runGroupType === runGroupType) {\n      const allBlockCoords = range(size).map((otherValue) =>\n        this.makeRunGroupCoords(runGroup, otherValue)\n      );\n      const unselectedBlockCoords = except(\n        allBlockCoords,\n        selectedBlockCoords,\n        sameCoords\n      );\n      for (const coords of selectedBlockCoords) {\n        this.markOn(columns, size, coords);\n      }\n      for (const coords of unselectedBlockCoords) {\n        this.markOff(columns, size, coords);\n      }\n    } else {\n      for (const coords of selectedBlockCoords) {\n        this.markOff(columns, size, coords);\n      }\n    }\n\n    return columns;\n  }\n\n  private static ON_INDEX = 0;\n  private static OFF_INDEX = 1;\n\n  markOn(columns: number[], size: number, coords: Coords): void {\n    const baseIndex = (coords.row * size + coords.col) * 2;\n    columns[baseIndex + Demo.ON_INDEX] = 1;\n  }\n\n  markOff(columns: number[], size: number, coords: Coords): void {\n    const baseIndex = (coords.row * size + coords.col) * 2;\n    columns[baseIndex + Demo.OFF_INDEX] = 1;\n  }\n\n  makeRunGroupCoords(runGroup: RunGroup, otherValue: number): Coords {\n    if (runGroup.runGroupType === RunGroupType.Horizontal) {\n      const horizontalRunGroup = runGroup as HorizontalRunGroup;\n      return { row: horizontalRunGroup.row, col: otherValue };\n    }\n    if (runGroup.runGroupType === RunGroupType.Vertical) {\n      const verticalRunGroup = runGroup as VerticalRunGroup;\n      return { row: otherValue, col: verticalRunGroup.col };\n    }\n    throw new Error(\"[makeRunGroupCoords] unknown RunGroupType\");\n  }\n}\n","export enum ClueType {\n  Across,\n  Down,\n}\n","import { Coords, IDemo, sameCoords } from \"types\";\nimport { range } from \"utils\";\nimport { ClueType } from \"./clue-type\";\nimport { InternalRow } from \"./internal-row\";\nimport { Puzzle } from \"./puzzle\";\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(\n    puzzle: Puzzle,\n    _checkForCancellation: () => boolean\n  ): InternalRow[] {\n    const internalRows: InternalRow[] = [];\n\n    for (const clue of puzzle.clues) {\n      for (const candidate of clue.candidates) {\n        const internalRow = { puzzle, clue, candidate };\n        internalRows.push(internalRow);\n      }\n    }\n\n    return internalRows;\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    return this.makeColumns(internalRow);\n  }\n\n  getNumPrimaryColumns(_puzzle: Puzzle): number | undefined {\n    return undefined;\n  }\n\n  makeColumns(internalRow: InternalRow): number[] {\n    const crossCheckingSquares = internalRow.puzzle.crossCheckingSquares;\n    const clue = internalRow.clue;\n    const columns = Array(crossCheckingSquares.length * 26).fill(0);\n\n    const findCrossCheckingSquareIndex = (coords: Coords): number => {\n      return crossCheckingSquares.findIndex((crossCheckingSquare) =>\n        sameCoords(crossCheckingSquare, coords)\n      );\n    };\n\n    for (const index of range(clue.coordsList.length)) {\n      const coords = clue.coordsList[index];\n      const crossCheckingSquareIndex = findCrossCheckingSquareIndex(coords);\n      if (crossCheckingSquareIndex >= 0) {\n        const letter = internalRow.candidate[index];\n        const encodedLetterColumns = this.encodeLetter(letter, clue.clueType);\n        const baseIndex = crossCheckingSquareIndex * 26;\n        for (const encodedLetterIndex of range(encodedLetterColumns.length)) {\n          columns[baseIndex + encodedLetterIndex] =\n            encodedLetterColumns[encodedLetterIndex];\n        }\n      }\n    }\n\n    return columns;\n  }\n\n  encodeLetter(letter: string, clueType: ClueType): number[] {\n    const upperLetter = letter.toLocaleUpperCase();\n    const index = upperLetter.charCodeAt(0) - \"A\".charCodeAt(0);\n    const [onValue, offValue] = clueType === ClueType.Across ? [1, 0] : [0, 1];\n    const columns = Array(26).fill(offValue);\n    columns[index] = onValue;\n    return columns;\n  }\n}\n","// To fix: Unexpected use of 'self'.\n/* eslint-disable no-restricted-globals */\n\nimport * as dlxlib from \"dlxlib/dlx\";\nimport { Mode, IDemo, UIToWorkerMessage, UIToWorkerSolveMessage } from \"types\";\nimport { checkStopToken } from \"./stop-token\";\nimport { timeIt } from \"./time-it\";\n\nimport { Demo as SudokuDemo } from \"demos/sudoku/demo\";\nimport { Demo as PentominoesDemo } from \"demos/pentominoes/demo\";\nimport { Demo as DraughtboardPuzzleDemo } from \"demos/draughtboard-puzzle/demo\";\nimport { Demo as NQueensDemo } from \"demos/n-queens/demo\";\nimport { Demo as TetraSticksDemo } from \"demos/tetrasticks/demo\";\nimport { Demo as AztecDiamondDemo } from \"demos/aztec-diamond/demo\";\nimport { Demo as RippleEffectDemo } from \"demos/ripple-effect/demo\";\nimport { Demo as FlowFreeDemo } from \"demos/flow-free/demo\";\nimport { Demo as KakuroDemo } from \"demos/kakuro/demo\";\nimport { Demo as NonogramDemo } from \"demos/nonogram/demo\";\nimport { Demo as CrosswordDemo } from \"demos/crossword/demo\";\n\ntype DemoConstructor = new () => IDemo<unknown, unknown>;\n\nconst map = new Map<string, DemoConstructor>([\n  [\"sudoku\", SudokuDemo],\n  [\"pentominoes\", PentominoesDemo],\n  [\"draughtboard-puzzle\", DraughtboardPuzzleDemo],\n  [\"n-queens\", NQueensDemo],\n  [\"tetrasticks\", TetraSticksDemo],\n  [\"aztec-diamond\", AztecDiamondDemo],\n  [\"ripple-effect\", RippleEffectDemo],\n  [\"flow-free\", FlowFreeDemo],\n  [\"kakuro\", KakuroDemo],\n  [\"nonogram\", NonogramDemo],\n  [\"crossword\", CrosswordDemo],\n]);\n\n// To fix: 'worker.ts' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module.ts(1208)\nexport {};\n\ntype SearchStepEvent = {\n  partialSolution: number[];\n  stepIndex: number;\n};\n\ntype SolutionFoundEvent = {\n  solution: number[];\n  solutionIndex: number;\n};\n\nconst onSolve = (\n  stopToken: string,\n  shortName: string,\n  puzzle: unknown,\n  mode: Mode\n) => {\n  const checkForCancellation = (sendMessage = false) => {\n    const cancelled = checkStopToken(stopToken);\n    if (cancelled && sendMessage) {\n      console.log(\"[worker onSolve]\", \"cancelled!\");\n      self.postMessage({ type: \"cancelled\" });\n    }\n    return cancelled;\n  };\n\n  console.log(\"[worker onSolve]\");\n  const demoConstructor = map.get(shortName);\n  if (!demoConstructor) {\n    self.postMessage({\n      type: \"error\",\n      message: `unknown demo short name, \"${shortName}\"`,\n    });\n    return;\n  }\n\n  const demo = new demoConstructor();\n\n  console.log(\"[worker onSolve]\", \"building internal rows...\");\n  const internalRows = timeIt(\"build internal rows\", () =>\n    demo.buildInternalRows(puzzle, checkForCancellation)\n  );\n  console.log(\"[worker onSolve]\", \"internalRows.length:\", internalRows.length);\n  if (checkForCancellation(true)) return;\n\n  console.log(\"[worker onSolve]\", \"building matrix...\");\n  const matrix = timeIt(\"build matrix\", () => {\n    const matrix: Uint8Array[] = [];\n    for (let index = 0; index < internalRows.length; index++) {\n      if (index % 1000 === 0) {\n        if (checkForCancellation()) {\n          break;\n        }\n      }\n      const internalRow = internalRows[index];\n      const matrixRow = demo.internalRowToMatrixRow(internalRow);\n      matrix.push(Uint8Array.from(matrixRow));\n    }\n    return matrix;\n  });\n  const rowCount = matrix.length;\n  const colCount = matrix[0]?.length ?? 0;\n  console.log(\"[worker onSolve]\", \"matrix size:\", `${rowCount}x${colCount}`);\n  if (checkForCancellation(true)) return;\n\n  const numSolutions = 1;\n  const numPrimaryColumns = demo.getNumPrimaryColumns(puzzle);\n\n  console.log(\"[worker onSolve]\", \"numPrimaryColumns:\", numPrimaryColumns);\n\n  const options: dlxlib.Options = {\n    numSolutions,\n    numPrimaryColumns,\n    checkForCancellation,\n  };\n\n  let searchStepCount = 0;\n\n  const onStep = (event: SearchStepEvent) => {\n    searchStepCount++;\n    if (searchStepCount % 100 === 0) {\n      console.log(\"[worker onStep]\", \"searchStepCount:\", searchStepCount);\n    }\n    if (mode === Mode.SearchSteps) {\n      const partialSolution = event.partialSolution;\n      const solutionInternalRows = partialSolution.map(\n        (index) => internalRows[index]\n      );\n      self.postMessage({ type: \"searchStep\", solutionInternalRows });\n    }\n  };\n\n  const onSolution = (event: SolutionFoundEvent) => {\n    console.log(\n      \"[worker onSolution]\",\n      \"solutionIndex:\",\n      event.solutionIndex,\n      \"row count:\",\n      event.solution.length\n    );\n    const solution = event.solution;\n    const solutionInternalRows = solution.map((index) => internalRows[index]);\n    self.postMessage({ type: \"solutionFound\", solutionInternalRows });\n  };\n\n  const dlx = new dlxlib.Dlx();\n  dlx.addListener(\"step\", onStep);\n  dlx.addListener(\"solution\", onSolution);\n\n  console.log(\"[worker onSolve]\", \"solving matrix...\");\n  const solutions = timeIt(\"solve matrix\", () => dlx.solve(matrix, options));\n  console.log(\"[worker onSolve]\", \"searchStepCount:\", searchStepCount);\n  console.log(\"[worker onSolve]\", \"solutions.length:\", solutions.length);\n  if (checkForCancellation(true)) return;\n\n  self.postMessage({ type: \"finished\", numSolutionsFound: solutions.length });\n};\n\nself.onmessage = (ev: MessageEvent<UIToWorkerMessage>) => {\n  try {\n    console.log(\"[worker onmessage]\", \"ev.data.type:\", ev.data.type);\n    if (ev.data.type === \"solve\") {\n      const message = ev.data as UIToWorkerSolveMessage;\n      const { stopToken, shortName, puzzle, mode } = message;\n      timeIt(\"onSolve\", () => onSolve(stopToken, shortName, puzzle, mode));\n      return;\n    }\n\n    if (ev.data.type === \"close\") {\n      self.close();\n      return;\n    }\n  } catch (error) {\n    console.error(\"error:\", error);\n    if (error instanceof Error) {\n      self.postMessage({ type: \"error\", errorMessage: error.message });\n    } else {\n      self.postMessage({ type: \"error\", errorMessage: String(error) });\n    }\n  }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [625], function() { return __webpack_require__(1907); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"b56eb7ce\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/dlxlib-demos/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t907: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdlxlib_demos\"] = self[\"webpackChunkdlxlib_demos\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(625).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DataObject","listHeader","rowIndex","up","down","left","right","this","addDataObject","dataObject","fn","loop","propName","next","ColumnObject","previousColumnObject","nextColumnObject","numberOfRows","columnObject","appendToColumn","unlinkFromColumn","relinkIntoColumn","search","Dlx","checkOptions","options","undefined","numSolutions","Number","isInteger","Error","numPrimaryColumns","matrix","MAX_SAFE_INTEGER","solutions","iterator","solutionGenerator","index","iteratorResult","done","push","value","root","buildInternalStructure","searchState","SearchState","EventEmitter","length","colIndexToListHeader","Map","cancelled","forEach","row","checkForCancellation","firstDataObjectInThisRow","col","colIndex","appendColumnHeader","set","get","appendToRow","byAscendingRowIndices","rowIndex1","rowIndex2","checkForCancellationFrequency","getStepIndex","raiseSearchStepEvent","isEmpty","currentSolution","raiseSolutionFoundEvent","slice","sort","c","chooseColumnWithFewestRows","coverColumn","r","pushRowIndex","loopRight","j","loopLeft","uncoverColumn","popRowIndex","chosenColumn","loopNext","column","unlinkColumnHeader","loopDown","i","unlinkDataObject","loopUp","relinkDataObject","relinkColumnHeader","dlx","stepIndex","solutionIndex","pop","listenerCount","e","partialSolution","emit","solution","range","n","Array","from","keys","sum","ns","reduce","acc","maxBy","xs","selector","map","Math","max","defaultSameness","x1","x2","except","xs1","xs2","isSame","filter","some","CurrentState","Mode","reverseString","s","reverse","join","goUp","coords","goDown","goLeft","goRight","sameCoords","coords1","coords2","coordsComparer","rowDiff","colDiff","checkStopToken","stopToken","xhr","XMLHttpRequest","open","send","timeIt","label","startTime","performance","now","result","elapsedTimeS","console","log","toLocaleString","Orientation","Demo","puzzle","_checkForCancellation","flatMap","initialValue","initialValues","find","iv","_buildInternalRowsForInitialValue","_buildInternalRowsForCoords","isInitialValue","internalRow","box","_rowColToBox","zeroBasedValue","posColumns","_oneHot","rowColumns","colColumns","boxColumns","concat","major","minor","columns","fill","floor","_puzzle","Colour","rotateCW","pattern","rowCount","colCount","rowIndices","transposed","reflect","toCoordsList","coordsList","piecesMap","pieces","reflectVariationCandidate","vc","reflected","makeVariation","orientation","piecesWithVariations","piece","north","North","northReflected","east","East","eastReflected","south","South","southReflected","west","West","allVariationCandidates","representations","Set","uniqueVariationCandidates","representation","has","add","variations","allLocations","allPossiblePiecePlacements","isValidPiecePlacement","pieceColumns","makePieceColumns","locationColumns","makeLocationColumns","variation","location","internalRows","fixedPieceLabels","pieceWithVariations","includes","findIndex","pwv","indices","indicesToExclude","_","toSquares","squares","colour","Black","White","square","size","diagonalColumnCount","diagonal1Columns","diagonal2Columns","diagonal1","diagonal2","lineSegments","polyLines","parsePolyLineDescriptions","polyLineDescriptions","split","trim","Boolean","parsePolyLineDescription","polyLineDescription","coordsString","lineSegmentDescriptions","horizontals","verticals","junctions","bits","bit","type","parsePiece","getDimensions","width","h","height","v","newHorizontals","newVerticals","newJunctions","newPolyLines","polyLine","rotateOrientationCW","allVariations","uniqueVariations","sortedHorizontals","sortedVerticals","hs","vs","normalisedRepresentation","horizontalsColumns","makeHorizontalsColumns","vertialsColumns","makeVerticalsColumns","junctionsColumns","makeJunctionsColumns","numPieces","pieceToOmit","horizontal","vertical","piecesInPlay","getPiecesInPlay","pip","junction","allHorizontals","centreRelativeRow","centreRelativeCol","abs","allVerticals","allJunctions","h1","h2","RunType","twoSidedPiecesMap","oneSidedPiecesMap","twoSidedPieces","oneSidedPieces","makeVariations","wantReflected","baseVariation","makeUnreflectedVariations","makeThumbnailSolution","solutionInternalRows","makeSolution","makeSolutionInternalRow","numFixedPieces","fixedInternalRows","fixedInternalRow","fir","allLocationsInBoundingSquare","rooms","room","cell","givenCells","givenValues","cellsToSolve","cells","valuesToSolve","roomColumns","makeRoomColumns","rippleColumns","makeRippleColumns","startIndex","maxValue","arrayOfArrays","baseIndex","setRippleColumnBits","baseIndexOffset","transformCoords","rippleCells","getRippleCells","array","flat","findPaths","colourPair","start","goal","end","currentPath","paths","maxDirectionChanges","colourPairs","findPathsInternal","node","nextNode","path","countDirectionChanges","p","neighbours","dots","cp","d","isDot","count","p1","p3","sameRun","run1","run2","runType","coordsList1","coordsList2","sameCoordsList","RunGroupType","doPermute","nums","permutations","doPermuteInternal","list","swap","index1","index2","temp","DIGITS","createInternalRowsFor","runs","run","findSetsOfValues","setOfValues","values","horizontalRuns","verticalRuns","setsOfValues","helper","useds","remainingDigits","used","digit","horizontalRunColumns","makeHorizontalRunColumns","verticalRunColumns","makeVerticalRunColumns","horizontalRunValueColumns","makeHorizontalRunValueColumns","verticalRunValueColumns","makeVerticalRunValueColumns","Horizontal","findHorizontalRunIndex","Vertical","findVerticalRunIndex","unknowns","encodedValue","encodeValueNormal","encodeValueInverse","unknown","unknownIndex","findUnknownIndex","encodedValueIndex","u","ClueType","buildInternalRowsForRunGroup","runGroup","workingSetOfStartingPositions","recursivelyFindSetsOfStartingPositions","startPosition","remainingLengths","runLength","newRemainingLengths","sumOfRemainingLengths","requiredGaps","validStartPositions","x","validStartPosition","pair","startingPosition","lengths","setOfStartingPositions","coordsLists","startingPositionData","makeRunGroupCoords","horizontalRunGroups","verticalRunGroups","makeRowColumns","makeColColumns","horizontalBlockColumns","makeBlockColumns","verticalBlockColumns","runGroupType","selectedBlockCoords","unselectedBlockCoords","otherValue","markOn","markOff","ON_INDEX","OFF_INDEX","clues","clue","candidates","candidate","makeColumns","crossCheckingSquares","findCrossCheckingSquareIndex","crossCheckingSquare","crossCheckingSquareIndex","letter","encodedLetterColumns","encodeLetter","clueType","encodedLetterIndex","toLocaleUpperCase","charCodeAt","Across","onValue","offValue","SudokuDemo","PentominoesDemo","DraughtboardPuzzleDemo","NQueensDemo","TetraSticksDemo","AztecDiamondDemo","RippleEffectDemo","FlowFreeDemo","KakuroDemo","NonogramDemo","CrosswordDemo","self","onmessage","ev","data","message","shortName","mode","sendMessage","postMessage","demoConstructor","demo","buildInternalRows","matrixRow","internalRowToMatrixRow","Uint8Array","getNumPrimaryColumns","searchStepCount","dlxlib","addListener","event","SearchSteps","solve","numSolutionsFound","onSolve","close","error","errorMessage","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","Infinity","fulfilled","Object","every","key","splice","getter","__esModule","a","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","promises","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}