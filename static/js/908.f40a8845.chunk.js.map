{"version":3,"file":"static/js/908.f40a8845.chunk.js","mappings":"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","sources":["dlxlib/dataObject.ts","dlxlib/columnObject.ts","dlxlib/dlx.ts","utils.ts","types.ts","demos/sudoku/demo.ts","demos/sudoku/puzzles.ts","demos/kakuro/run-type.ts","demos/n-queens/demo.ts","demos/flow-free/path-finder.ts","demos/flow-free/demo.ts","demos/flow-free/drawing.tsx","demos/flow-free/puzzles.ts","demos/kakuro/drawing.tsx","demos/kakuro/puzzles.ts","demos/kakuro/run.ts","demos/kakuro/permutations.ts","demos/kakuro/demo.ts","worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { ColumnObject } from \"./columnObject\"\n\nexport class DataObject {\n\n  public up: DataObject\n  public down: DataObject\n  public left: DataObject\n  public right: DataObject\n\n  public constructor(public listHeader?: ColumnObject, public rowIndex?: number) {\n    this.up = this\n    this.down = this\n    this.left = this\n    this.right = this\n    listHeader?.addDataObject(this)\n  }\n\n  public appendToRow(dataObject: DataObject) {\n    this.left.right = dataObject\n    dataObject.right = this\n    dataObject.left = this.left\n    this.left = dataObject\n  }\n\n  public appendToColumn(dataObject: DataObject) {\n    this.up.down = dataObject\n    dataObject.down = this\n    dataObject.up = this.up\n    this.up = dataObject\n  }\n\n  public unlinkFromColumn() {\n    this.down.up = this.up\n    this.up.down = this.down\n  }\n\n  public relinkIntoColumn() {\n    this.down.up = this\n    this.up.down = this\n  }\n\n  public loopUp(fn: (dataObject: DataObject) => void) { this.loop(fn, \"up\") }\n  public loopDown(fn: (dataObject: DataObject) => void) { this.loop(fn, \"down\") }\n  public loopLeft(fn: (dataObject: DataObject) => void) { this.loop(fn, \"left\") }\n  public loopRight(fn: (dataObject: DataObject) => void) { this.loop(fn, \"right\") }\n\n  private loop(\n    fn: (dataObject: DataObject) => void,\n    propName: \"up\" | \"down\" | \"left\" | \"right\"\n  ) {\n    for (let next = this[propName]; next !== this; next = next[propName]) {\n      fn(next)\n    }\n  }\n}\n","import { DataObject } from \"./dataObject\"\n\nexport class ColumnObject extends DataObject {\n\n  public previousColumnObject: ColumnObject\n  public nextColumnObject: ColumnObject\n  public numberOfRows: number\n\n  public constructor() {\n    super()\n    this.previousColumnObject = this\n    this.nextColumnObject = this\n    this.numberOfRows = 0\n  }\n\n  public appendColumnHeader(columnObject: ColumnObject) {\n    this.previousColumnObject.nextColumnObject = columnObject\n    columnObject.nextColumnObject = this\n    columnObject.previousColumnObject = this.previousColumnObject\n    this.previousColumnObject = columnObject\n  }\n\n  public unlinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this.previousColumnObject\n    this.previousColumnObject.nextColumnObject = this.nextColumnObject\n  }\n\n  public relinkColumnHeader() {\n    this.nextColumnObject.previousColumnObject = this\n    this.previousColumnObject.nextColumnObject = this\n  }\n\n  public addDataObject(dataObject: DataObject) {\n    this.appendToColumn(dataObject)\n    this.numberOfRows++\n  }\n\n  public unlinkDataObject(dataObject: DataObject) {\n    dataObject.unlinkFromColumn()\n    this.numberOfRows--\n  }\n\n  public relinkDataObject(dataObject: DataObject) {\n    dataObject.relinkIntoColumn()\n    this.numberOfRows++\n  }\n\n  public loopNext(fn: (columnObject: ColumnObject) => void) {\n    for (let next = this.nextColumnObject; next !== this; next = next.nextColumnObject) {\n      fn(next)\n    }\n  }\n}\n","import EventEmitter from \"events\"\nimport { DataObject } from \"./dataObject\"\nimport { ColumnObject } from \"./columnObject\"\n\nexport type MatrixValue = any\nexport type MatrixRow = MatrixValue[]\nexport type Matrix = MatrixRow[]\n\nexport type Solution = number[]\nexport type PartialSolution = number[]\n\nexport type Options = {\n  numSolutions?: number\n  numPrimaryColumns?: number\n}\n\nexport function solve(matrix: Matrix, options: Options) {\n  return new Dlx().solve(matrix, options)\n}\n\nexport class Dlx extends EventEmitter {\n\n  public constructor() {\n    super()\n  }\n\n  public solve(matrix: Matrix, options?: Options): Solution[] {\n    this.checkOptions(options)\n    const numSolutions = options?.numSolutions ?? Number.MAX_SAFE_INTEGER\n    const solutions = []\n    const iterator = this.solutionGenerator(matrix, options)\n    for (let index = 0; index < numSolutions; index++) {\n      const iteratorResult = iterator.next()\n      if (iteratorResult.done) break\n      solutions.push(iteratorResult.value)\n    }\n    return solutions\n  }\n\n  public * solutionGenerator(matrix: Matrix, options?: Options): Generator<Solution> {\n    this.checkOptions(options)\n    const root = buildInternalStructure(matrix, options)\n    const searchState = new SearchState(this, root)\n    yield* search(searchState)\n  }\n\n  private checkOptions = (options?: Options): void => {\n    if (options?.numSolutions !== undefined) {\n      if (!Number.isInteger(options.numSolutions)) {\n        throw new Error(\"options.numSolutions must be an integer\")\n      }\n      if (options.numSolutions < 0) {\n        throw new Error(\"options.numSolutions can't be negative - don't be silly\")\n      }\n    }\n\n    if (options?.numPrimaryColumns !== undefined) {\n      if (!Number.isInteger(options.numPrimaryColumns)) {\n        throw new Error(\"options.numPrimaryColumns must be an integer\")\n      }\n      if (options.numPrimaryColumns < 0) {\n        throw new Error(\"options.numPrimaryColumns can't be negative - don't be silly\")\n      }\n    }\n  }\n}\n\nconst buildInternalStructure = (matrix: Matrix, options?: Options) => {\n\n  const numPrimaryColumns = options?.numPrimaryColumns ?? matrix[0].length\n\n  const root = new ColumnObject()\n  const colIndexToListHeader = new Map()\n\n  matrix.forEach((row: MatrixRow, rowIndex: number) => {\n    let firstDataObjectInThisRow: DataObject | undefined = undefined\n    row.forEach((col, colIndex: number) => {\n      if (rowIndex === 0) {\n        const listHeader = new ColumnObject()\n        if (colIndex < numPrimaryColumns) {\n          root.appendColumnHeader(listHeader)\n        }\n        colIndexToListHeader.set(colIndex, listHeader)\n      }\n      if (col) {\n        const listHeader = colIndexToListHeader.get(colIndex)\n        const dataObject = new DataObject(listHeader, rowIndex)\n        if (firstDataObjectInThisRow)\n          firstDataObjectInThisRow.appendToRow(dataObject)\n        else\n          firstDataObjectInThisRow = dataObject\n      }\n    })\n  })\n\n  return root\n}\n\nconst byAscendingRowIndices = (rowIndex1: number, rowIndex2: number) =>\n  rowIndex1 - rowIndex2\n\nfunction* search(searchState: SearchState): Generator<Solution> {\n\n  searchState.raiseSearchStepEvent()\n\n  if (searchState.isEmpty()) {\n    if (searchState.currentSolution.length) {\n      searchState.raiseSolutionFoundEvent()\n      yield searchState.currentSolution.slice().sort(byAscendingRowIndices)\n    }\n    return\n  }\n\n  const c = chooseColumnWithFewestRows(searchState)\n  coverColumn(c)\n  for (let r = c.down; r !== c; r = r.down) {\n    searchState.pushRowIndex(r.rowIndex!)\n    r.loopRight(j => coverColumn(j.listHeader!))\n    yield* search(searchState)\n    r.loopLeft(j => uncoverColumn(j.listHeader!))\n    searchState.popRowIndex()\n  }\n  uncoverColumn(c)\n}\n\nconst chooseColumnWithFewestRows = (searchState: SearchState) => {\n  let chosenColumn: ColumnObject | undefined = undefined\n  searchState.root.loopNext(column => {\n    if (!chosenColumn || column.numberOfRows < chosenColumn.numberOfRows) {\n      chosenColumn = column\n    }\n  })\n  return chosenColumn!\n}\n\nconst coverColumn = (c: ColumnObject) => {\n  c.unlinkColumnHeader()\n  c.loopDown(i => i.loopRight(j => j.listHeader!.unlinkDataObject(j)))\n}\n\nconst uncoverColumn = (c: ColumnObject) => {\n  c.loopUp(i => i.loopLeft(j => j.listHeader!.relinkDataObject(j)))\n  c.relinkColumnHeader()\n}\n\nclass SearchState {\n\n  public currentSolution: number[] = []\n  private stepIndex: number = 0\n  private solutionIndex: number = 0\n\n  public constructor(private dlx: Dlx, public root: ColumnObject) {\n  }\n\n  public isEmpty() {\n    return this.root.nextColumnObject === this.root\n  }\n\n  public pushRowIndex(rowIndex: number) {\n    this.currentSolution.push(rowIndex)\n  }\n\n  public popRowIndex() {\n    this.currentSolution.pop()\n  }\n\n  public raiseSearchStepEvent() {\n    if (this.dlx.listenerCount(\"step\") > 0 && this.currentSolution.length) {\n      const partialSolution: PartialSolution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices)\n      const e = {\n        partialSolution,\n        stepIndex: this.stepIndex++\n      }\n      this.dlx.emit(\"step\", e)\n    }\n  }\n\n  public raiseSolutionFoundEvent() {\n    if (this.dlx.listenerCount(\"solution\") > 0) {\n      const solution: Solution = this.currentSolution\n        .slice()\n        .sort(byAscendingRowIndices)\n      const e = {\n        solution,\n        solutionIndex: this.solutionIndex++\n      }\n      this.dlx.emit(\"solution\", e)\n    }\n  }\n}\n","export const range = (n: number) => Array.from(Array(n).keys())\nexport const sum = (ns: number[]): number => ns.reduce((acc, n) => acc + n, 0)\nexport function first<T>(xs: T[]) { return xs[0] }\nexport function last<T>(xs: T[]) { return xs[xs.length - 1] }\n","import { range } from \"utils\"\n\nexport type AvailableDemo = {\n  name: string,\n  shortName: string,\n  Thumbnail: React.FC,\n}\n\nexport type DrawingProps<TPuzzle, TInternalRow> = {\n  puzzle: TPuzzle,\n  solutionInternalRows: TInternalRow[]\n}\n\nexport interface IDemo<TPuzzle, TInternalRow> {\n  buildInternalRows(puzzle: TPuzzle): TInternalRow[]\n  internalRowToMatrixRow(internalRow: TInternalRow): number[]\n  getNumPrimaryColumns(puzzle: TPuzzle): number | undefined\n}\n\nexport type Coords = {\n  row: number,\n  col: number\n}\n\nexport const goUp = (coords: Coords): Coords => ({ row: coords.row - 1, col: coords.col })\nexport const goDown = (coords: Coords): Coords => ({ row: coords.row + 1, col: coords.col })\nexport const goLeft = (coords: Coords): Coords => ({ row: coords.row, col: coords.col - 1 })\nexport const goRight = (coords: Coords): Coords => ({ row: coords.row, col: coords.col + 1 })\n\nexport const sameCoords = (coords1: Coords, coords2: Coords): boolean =>\n  coords1.row === coords2.row && coords1.col === coords2.col\n\nexport const sameCoordsList = (coordsList1: Coords[], coordsList2: Coords[]): boolean => {\n  if (coordsList1.length !== coordsList2.length) return false\n  for (const index of range(coordsList1.length)) {\n    const coords1 = coordsList1[index]\n    const coords2 = coordsList2[index]\n    if (!sameCoords(coords1, coords2)) return false\n  }\n  return true\n}\n\nexport enum CurrentState {\n  Clean,\n  Solving,\n  Dirty\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { InitialValue } from \"./initial-value\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const allCoords = range(9).flatMap(row => range(9).map(col => ({ row, col })))\n    return allCoords.flatMap(coords => {\n      const initialValue = puzzle.initialValues.find(iv => sameCoords(iv.coords, coords))\n      return initialValue\n        ? this._buildInternalRowsForInitialValue(initialValue)\n        : this._buildInternalRowsForCoords(coords)\n    })\n  }\n\n  _buildInternalRowsForInitialValue(initialValue: InitialValue): InternalRow[] {\n    return [{ ...initialValue, isInitialValue: true }]\n  }\n\n  _buildInternalRowsForCoords(coords: Coords): InternalRow[] {\n    return range(9).map(n => n + 1).map(value => ({\n      coords,\n      value,\n      isInitialValue: false\n    }))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords\n    const box = this._rowColToBox(row, col);\n    const zeroBasedValue = internalRow.value - 1\n    const posColumns = this._oneHot(row, col);\n    const rowColumns = this._oneHot(row, zeroBasedValue);\n    const colColumns = this._oneHot(col, zeroBasedValue);\n    const boxColumns = this._oneHot(box, zeroBasedValue);\n    return posColumns\n      .concat(rowColumns)\n      .concat(colColumns)\n      .concat(boxColumns)\n  }\n\n  _oneHot(major: number, minor: number): number[] {\n    const columns = Array(81).fill(0)\n    columns[major * 9 + minor] = 1\n    return columns\n  }\n\n  _rowColToBox(row: number, col: number): number {\n    return Math.floor(row - (row % 3) + (col / 3))\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n}\n","import { InitialValue } from \"./initial-value\"\nimport { Puzzle } from \"./puzzle\"\nimport { range } from \"utils\"\n\nconst parseGrid = (grid: string[]): InitialValue[] =>\n  grid.flatMap((gridRow, row) =>\n    range(gridRow.length).flatMap((col) => {\n      const ch = gridRow[col]\n      const value = Number(ch)\n      if (Number.isInteger(value) && value >= 1 && value <= 9) {\n        const coords = { row, col }\n        const initialValue = { coords, value }\n        return [initialValue]\n      }\n      return []\n    }))\n\nexport const puzzles: Puzzle[] = [\n  {\n    name: \"Daily Telegraph 27744\",\n    initialValues: parseGrid([\n      \"6 4 9 7 3\",\n      \"  3    6 \",\n      \"       18\",\n      \"   18   9\",\n      \"     43  \",\n      \"7   39   \",\n      \" 7       \",\n      \" 4    8  \",\n      \"9 8 6 4 5\"\n    ])\n  }\n]\n","export enum RunType {\n  Horizontal,\n  Vertical\n}\n","import { IDemo } from \"types\"\nimport { range } from \"utils\"\nimport { Puzzle } from \"./puzzle\"\nimport { InternalRow } from \"./internal-row\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const allLocations = range(puzzle.size).flatMap(row =>\n      range(puzzle.size).map(col =>\n        ({ row, col })))\n    return allLocations.map(coords => ({ puzzle, coords }))\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.size * 2\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { row, col } = internalRow.coords\n    const size = internalRow.puzzle.size\n    const diagonalColumnCount = size + size - 3\n\n    const rowColumns = Array(size).fill(0)\n    const colColumns = Array(size).fill(0)\n    const diagonal1Columns = Array(diagonalColumnCount).fill(0)\n    const diagonal2Columns = Array(diagonalColumnCount).fill(0)\n\n    rowColumns[row] = 1\n    colColumns[col] = 1\n\n    const diagonal1 = row + col - 1\n    if (diagonal1 >= 0 && diagonal1 < diagonalColumnCount) diagonal1Columns[diagonal1] = 1\n\n    const diagonal2 = size - 1 - col + row - 1\n    if (diagonal2 >= 0 && diagonal2 < diagonalColumnCount) diagonal2Columns[diagonal2] = 1\n\n    return rowColumns\n      .concat(colColumns)\n      .concat(diagonal1Columns)\n      .concat(diagonal2Columns)\n  }\n}\n","import { Coords, sameCoords, goUp, goDown, goLeft, goRight } from \"types\"\nimport { range } from \"utils\"\nimport { ColourPair } from \"./colour-pair\"\nimport { Puzzle } from \"./puzzle\"\n\nexport const findPaths = (puzzle: Puzzle, colourPair: ColourPair): Coords[][] => {\n  const start = colourPair.start\n  const goal = colourPair.end\n  const currentPath = [start]\n  const paths: Coords[][] = []\n  const maxDirectionChanges = puzzle.colourPairs.length\n\n  findPathsInternal(puzzle, currentPath, paths, start, goal, maxDirectionChanges)\n\n  return paths\n}\n\n// Inspired by this: https://stackoverflow.com/a/22464491\nconst findPathsInternal = (\n  puzzle: Puzzle,\n  currentPath: Coords[],\n  paths: Coords[][],\n  node: Coords,\n  goal: Coords,\n  maxDirectionChanges: number\n): void => {\n  for (const nextNode of neighbours(puzzle, node, goal)) {\n    if (sameCoords(nextNode, goal)) {\n      const path = [...currentPath, nextNode]\n      if (countDirectionChanges(path) <= maxDirectionChanges) {\n        paths.push(path)\n      }\n    } else {\n      const index = currentPath.findIndex(p => sameCoords(p, nextNode))\n      if (index < 0) {\n        currentPath.push(nextNode)\n        if (countDirectionChanges(currentPath) <= maxDirectionChanges) {\n          findPathsInternal(puzzle, currentPath, paths, nextNode, goal, maxDirectionChanges)\n        }\n        currentPath.pop()\n      }\n    }\n  }\n}\n\nconst neighbours = (puzzle: Puzzle, node: Coords, goal: Coords): Coords[] => {\n\n  const dots = puzzle.colourPairs.flatMap(cp => [cp.start, cp.end])\n  const isDot = (n: Coords) => dots.findIndex(d => sameCoords(d, n)) >= 0\n\n  const ns = [\n    goUp(node),\n    goDown(node),\n    goLeft(node),\n    goRight(node)\n  ]\n\n  const isWithinPuzzle = (n: Coords) => (\n    n.row >= 0 && n.row < puzzle.size &&\n    n.col >= 0 && n.col < puzzle.size\n  )\n\n  const isEmptyLocationOrGoal = (n: Coords) =>\n    !isDot(n) || sameCoords(n, goal)\n\n  return ns\n    .filter(isWithinPuzzle)\n    .filter(isEmptyLocationOrGoal)\n}\n\nconst countDirectionChanges = (path: Coords[]): number => {\n  if (path.length < 3) return 0\n  let count = 0\n  for (const index of range(path.length).slice(1).slice(0, -1)) {\n    const p1 = path[index - 1]\n    const p3 = path[index + 1]\n    const rowDiff = Math.abs(p3.row - p1.row)\n    const colDiff = Math.abs(p3.col - p1.col)\n    if (rowDiff !== 0 && colDiff !== 0) count++\n  }\n  return count\n}\n","import { IDemo } from \"types\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\nimport { findPaths } from \"./path-finder\"\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = []\n    for (const colourPair of puzzle.colourPairs) {\n      const paths = findPaths(puzzle, colourPair)\n      for (const coordsList of paths) {\n        const internalRow = { puzzle, colourPair, coordsList }\n        internalRows.push(internalRow)\n      }\n    }\n    return internalRows\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const size = internalRow.puzzle.size\n    const columns = Array(size * size).fill(0)\n    for (const coords of internalRow.coordsList) {\n      const index = coords.row * size + coords.col\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return undefined\n  }\n}\n","import { Coords, DrawingProps } from \"types\"\nimport { range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Puzzle } from \"./puzzle\"\n\nconst VIEWBOX_WIDTH = 100\nconst VIEWBOX_HEIGHT = 100\n\nconst dotColours = new Map<string, string>([\n  [\"A\", \"red\"],\n  [\"B\", \"green\"],\n  [\"C\", \"blue\"],\n  [\"D\", \"yellow\"],\n  [\"E\", \"orange\"],\n  [\"F\", \"cyan\"],\n  [\"G\", \"magenta\"],\n  [\"H\", \"brown\"],\n  [\"I\", \"purple\"],\n  [\"J\", \"white\"],\n  [\"K\", \"grey\"],\n  [\"L\", \"limegreen\"]\n])\n\nconst labelColours = new Map<string, string>([\n  [\"A\", \"white\"],\n  [\"B\", \"white\"],\n  [\"C\", \"white\"],\n  [\"D\", \"black\"],\n  [\"E\", \"black\"],\n  [\"F\", \"black\"],\n  [\"G\", \"white\"],\n  [\"H\", \"white\"],\n  [\"I\", \"white\"],\n  [\"J\", \"black\"],\n  [\"K\", \"black\"],\n  [\"L\", \"black\"]\n])\n\nexport const Drawing: React.FC<DrawingProps<Puzzle, InternalRow>> = ({ puzzle, solutionInternalRows }) => {\n\n  const GRID_LINE_FULL_THICKNESS = 1 / 4\n  const GRID_LINE_HALF_THICKNESS = GRID_LINE_FULL_THICKNESS / 2\n  const GRID_LINE_COLOUR = \"yellow\"\n  const SQUARE_WIDTH = (VIEWBOX_WIDTH - GRID_LINE_FULL_THICKNESS) / puzzle.size\n  const SQUARE_HEIGHT = (VIEWBOX_HEIGHT - GRID_LINE_FULL_THICKNESS) / puzzle.size\n\n  const calculateX = (col: number) => col * SQUARE_WIDTH + GRID_LINE_HALF_THICKNESS\n  const calculateY = (row: number) => row * SQUARE_HEIGHT + GRID_LINE_HALF_THICKNESS\n\n  const drawBackground = (): JSX.Element => {\n    return <rect x={0} y={0} width={VIEWBOX_WIDTH} height={VIEWBOX_HEIGHT} fill=\"black\" />\n  }\n\n  const drawHorizontalGridLines = (): JSX.Element[] => {\n    const rows = range(puzzle.size + 1)\n    return rows.map(row => {\n      const y = calculateY(row)\n      return (\n        <line\n          key={`horizontal-grid-line-${row}`}\n          x1={0}\n          y1={y}\n          x2={VIEWBOX_WIDTH}\n          y2={y}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      )\n    })\n  }\n\n  const drawVerticalGridLines = (): JSX.Element[] => {\n    const cols = range(puzzle.size + 1)\n    return cols.map(col => {\n      const x = calculateX(col)\n      return (\n        <line\n          key={`vertical-grid-line-${col}`}\n          x1={x}\n          y1={0}\n          x2={x}\n          y2={VIEWBOX_HEIGHT}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      )\n    })\n  }\n\n  const drawColourPairDots = (): JSX.Element[] => {\n    return puzzle.colourPairs.flatMap(colourPair => [\n      drawDot(colourPair.label, colourPair.start),\n      drawDot(colourPair.label, colourPair.end),\n    ])\n  }\n\n  const drawDot = (label: string, coords: Coords): JSX.Element => {\n    const { row, col } = coords\n    const cx = calculateX(col) + SQUARE_WIDTH / 2\n    const cy = calculateY(row) + SQUARE_HEIGHT / 2\n    const r = SQUARE_WIDTH * 0.35\n    const fill = dotColours.get(label) ?? \"white\"\n\n    return (\n      <circle\n        key={`dot-${row}-${col}`}\n        cx={cx}\n        cy={cy}\n        r={r}\n        fill={fill}\n      />\n    )\n  }\n\n  const drawColourPairLabels = (): JSX.Element[] => {\n    return puzzle.colourPairs.flatMap(colourPair => [\n      drawLabel(colourPair.label, colourPair.start),\n      drawLabel(colourPair.label, colourPair.end)\n    ])\n  }\n\n  const drawLabel = (label: string, coords: Coords): JSX.Element => {\n    const { row, col } = coords\n    const cx = calculateX(col) + SQUARE_WIDTH / 2\n    const cy = calculateY(row) + SQUARE_WIDTH / 2\n    const fill = labelColours.get(label) ?? \"white\"\n    const fontSize = \"8px\"\n\n    return (\n      <text\n        key={`label-${row}-${col}`}\n        x={cx}\n        y={cy}\n        fill={fill}\n        fontSize={fontSize}\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n      >\n        {label}\n      </text>\n    )\n  }\n\n  const drawPipes = (): JSX.Element[] => {\n    return solutionInternalRows.map(internalRow => {\n      return drawPipe(internalRow)\n    })\n  }\n\n  const makePathData = (points: number[][]): string => {\n    const [firstPoint, ...remainingPoints] = points\n    const pathCommands: string[] = []\n    pathCommands.push(`M${firstPoint[0]},${firstPoint[1]}`)\n    for (const point of remainingPoints) {\n      pathCommands.push(`L${point[0]},${point[1]}`)\n    }\n    return pathCommands.join(\" \")\n  }\n\n  const drawPipe = (internalRow: InternalRow): JSX.Element => {\n\n    const coordsToCentreOfSquare = (coords: Coords): number[] => {\n      const x = calculateX(coords.col) + SQUARE_WIDTH / 2\n      const y = calculateY(coords.row) + SQUARE_HEIGHT / 2\n      return [x, y]\n    }\n\n    const d = makePathData(internalRow.coordsList.map(coordsToCentreOfSquare))\n    const label = internalRow.colourPair.label\n    const colour = dotColours.get(label) ?? \"white\"\n\n    return (\n      <path\n        key={`path-${label}`}\n        d={d}\n        stroke={colour}\n        strokeWidth={SQUARE_WIDTH / 4}\n        strokeLinejoin=\"round\"\n        fill=\"none\"\n      />\n    )\n  }\n\n  return (\n    <svg viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`}>\n      {drawBackground()}\n      {drawHorizontalGridLines()}\n      {drawVerticalGridLines()}\n      {drawColourPairDots()}\n      {drawPipes()}\n      {drawColourPairLabels()}\n    </svg>\n  )\n}\n","import { Coords } from \"types\";\nimport { range } from \"utils\";\nimport { ColourPair } from \"./colour-pair\";\nimport { Puzzle } from \"./puzzle\";\n\nconst parsePuzzle = (name: string, grid: string[]): Puzzle => {\n  const size = grid.length\n  const dict = new Map<string, Coords[]>()\n\n  for (const row of range(size)) {\n    for (const col of range(size)) {\n      const ch = grid[row][col]\n      if (/[A-Z]/.test(ch)) {\n        const coords = { row, col }\n        if (dict.has(ch)) {\n          dict.get(ch)?.push(coords)\n        } else {\n          dict.set(ch, [coords])\n        }\n      }\n    }\n  }\n\n  const colourPairs: ColourPair[] = []\n\n  for (const [label, coordsList] of dict) {\n    if (coordsList.length === 2) {\n      const [start, end] = coordsList\n      const colourPair = { label, start, end }\n      colourPairs.push(colourPair)\n    }\n  }\n\n  return { name, size, colourPairs }\n}\n\nexport const puzzles = [\n  parsePuzzle(\n    \"Puzzle 1\",\n    [\n      \"C--AE\",\n      \"---D-\",\n      \"--D--\",\n      \"-AE-B\",\n      \"-CB--\"\n    ]\n  )\n]\n","import { Coords, DrawingProps } from \"types\"\nimport { range } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Clue } from './clue'\nimport { Puzzle } from \"./puzzle\"\nimport { RunType } from \"./run-type\"\n\nconst VIEWBOX_WIDTH = 100\nconst VIEWBOX_HEIGHT = 100\nconst GRID_LINE_FULL_THICKNESS = 1 / 4\nconst GRID_LINE_HALF_THICKNESS = GRID_LINE_FULL_THICKNESS / 2\nconst GRID_LINE_COLOUR = \"black\"\nconst SQUARE_WIDTH = (VIEWBOX_WIDTH - GRID_LINE_FULL_THICKNESS) / 10\nconst SQUARE_HEIGHT = (VIEWBOX_HEIGHT - GRID_LINE_FULL_THICKNESS) / 10\n\nconst calculateX = (col: number) => col * SQUARE_WIDTH + GRID_LINE_HALF_THICKNESS\nconst calculateY = (row: number) => row * SQUARE_HEIGHT + GRID_LINE_HALF_THICKNESS\n\nexport const Drawing: React.FC<DrawingProps<Puzzle, InternalRow>> = ({ puzzle, solutionInternalRows }) => {\n\n  const drawBackground = (): JSX.Element => {\n    return <rect\n      x={0}\n      y={0}\n      width={VIEWBOX_WIDTH}\n      height={VIEWBOX_HEIGHT}\n      fill=\"white\"\n    />\n  }\n\n  const drawHorizontalGridLines = (): JSX.Element[] => {\n    const rows = range(10 + 1)\n    return rows.map(row => {\n      const y = calculateY(row)\n      return (\n        <line\n          key={`horizontal-grid-line-${row}`}\n          x1={0}\n          y1={y}\n          x2={VIEWBOX_WIDTH}\n          y2={y}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      )\n    })\n  }\n\n  const drawVerticalGridLines = (): JSX.Element[] => {\n    const cols = range(10 + 1)\n    return cols.map(col => {\n      const x = calculateX(col)\n      return (\n        <line\n          key={`vertical-grid-line-${col}`}\n          x1={x}\n          y1={0}\n          x2={x}\n          y2={VIEWBOX_HEIGHT}\n          strokeWidth={GRID_LINE_FULL_THICKNESS}\n          stroke={GRID_LINE_COLOUR}\n        />\n      )\n    })\n  }\n\n  const drawBlocks = (): JSX.Element[] => {\n    return puzzle.blocks.map(drawBlock)\n  }\n\n  const drawBlock = (block: Coords): JSX.Element => {\n    const { row, col } = block\n    const x = calculateX(col)\n    const y = calculateY(row)\n    return (\n      <rect\n        key={`block-${row}-${col}`}\n        x={x}\n        y={y}\n        width={SQUARE_WIDTH}\n        height={SQUARE_HEIGHT}\n        fill=\"black\"\n      />\n    )\n  }\n\n  const drawClues = (): JSX.Element[] => {\n    return puzzle.clues.flatMap(clue => drawClue(clue))\n  }\n\n  const drawClue = (clue: Clue): JSX.Element[] => {\n    const acrossElements = clue.acrossSum !== undefined ? drawAcrossClue(clue.coords, clue.acrossSum) : []\n    const downElements = clue.downSum !== undefined ? drawDownClue(clue.coords, clue.downSum) : []\n    return acrossElements.concat(downElements)\n  }\n\n  const makePathData = (points: number[][]): string => {\n    const [firstPoint, ...remainingPoints] = points\n    const pathCommands: string[] = []\n    pathCommands.push(`M${firstPoint[0]},${firstPoint[1]}`)\n    for (const point of remainingPoints) {\n      pathCommands.push(`L${point[0]},${point[1]}`)\n    }\n    pathCommands.push(\"Z\")\n    return pathCommands.join(\" \")\n  }\n\n  const drawAcrossClue = (coords: Coords, sum: number): JSX.Element[] => {\n    const { row, col } = coords\n\n    const px = calculateX(col)\n    const py = calculateY(row)\n    const p1 = [px + GRID_LINE_FULL_THICKNESS, py]\n    const p2 = [px + SQUARE_WIDTH * 0.85, py]\n    const p3 = [px + SQUARE_WIDTH, py + SQUARE_HEIGHT / 4]\n    const p4 = [p2[0], py + SQUARE_HEIGHT / 2]\n    const p5 = [px + SQUARE_WIDTH / 2 + GRID_LINE_FULL_THICKNESS, py + SQUARE_HEIGHT / 2]\n    const path = (\n      <path\n        key={`across-path-${row}-${col}`}\n        d={makePathData([p1, p2, p3, p4, p5])}\n        fill=\"white\"\n      />\n    )\n\n    const x = calculateX(col) + (SQUARE_WIDTH * 0.75)\n    const y = calculateY(row) + (SQUARE_HEIGHT * 0.25)\n    const fontSize = \"3\"\n    const text = (\n      <text\n        key={`across-sum-${row}-${col}`}\n        x={x}\n        y={y}\n        fill=\"black\"\n        fontSize={fontSize}\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n      >\n        {sum}\n      </text>\n    )\n    return [path, text]\n  }\n\n  const drawDownClue = (coords: Coords, sum: number): JSX.Element[] => {\n    const { row, col } = coords\n\n    const px = calculateX(col)\n    const py = calculateY(row)\n    const p1 = [px, py + GRID_LINE_FULL_THICKNESS]\n    const p2 = [px, py + SQUARE_HEIGHT * 0.85]\n    const p3 = [px + SQUARE_WIDTH / 4, py + SQUARE_HEIGHT]\n    const p4 = [px + SQUARE_WIDTH / 2, p2[1]]\n    const p5 = [px + SQUARE_WIDTH / 2, py + SQUARE_HEIGHT / 2 + GRID_LINE_FULL_THICKNESS]\n    const path = (\n      <path\n        key={`down-path-${row}-${col}`}\n        d={makePathData([p1, p2, p3, p4, p5])}\n        fill=\"white\"\n      />\n    )\n\n    const x = calculateX(col) + (SQUARE_WIDTH * 0.25)\n    const y = calculateY(row) + (SQUARE_HEIGHT * 0.75)\n    const fontSize = \"3\"\n    const text = (\n      <text\n        key={`down-sum-${row}-${col}`}\n        x={x}\n        y={y}\n        fill=\"black\"\n        fontSize={fontSize}\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n      >\n        {sum}\n      </text>\n    )\n    return [path, text]\n  }\n\n  const drawHorizontalRuns = (): JSX.Element[] => {\n    return solutionInternalRows\n      .filter(internalRow => internalRow.run.runType === RunType.Horizontal)\n      .flatMap(drawHorizontalRun)\n  }\n\n  const drawHorizontalRun = (internalRow: InternalRow): JSX.Element[] => {\n    return range(internalRow.run.coordsList.length).map(index => {\n      const coords = internalRow.run.coordsList[index]\n      const value = internalRow.values[index]\n      return drawValue(coords, value)\n    })\n  }\n\n  const drawValue = (coords: Coords, value: number): JSX.Element => {\n    const { row, col } = coords\n    const cx = calculateX(col) + SQUARE_WIDTH / 2\n    const cy = calculateY(row) + SQUARE_WIDTH / 2\n    const fill = \"black\"\n    const fontSize = \"8px\"\n\n    return (\n      <text\n        key={`value-${row}-${col}`}\n        x={cx}\n        y={cy}\n        fill={fill}\n        fontSize={fontSize}\n        textAnchor=\"middle\"\n        dominantBaseline=\"middle\"\n      >\n        {value}\n      </text>\n    )\n  }\n\n  return (\n    <svg viewBox={`0 0 ${VIEWBOX_WIDTH} ${VIEWBOX_HEIGHT}`}>\n      {drawBackground()}\n      {drawHorizontalGridLines()}\n      {drawVerticalGridLines()}\n      {drawBlocks()}\n      {drawClues()}\n      {drawHorizontalRuns()}\n    </svg>\n  )\n}\n","import { Coords, goDown, goRight, sameCoords } from \"types\"\nimport { range } from \"utils\"\nimport { Clue } from \"./clue\"\nimport { Puzzle } from \"./puzzle\"\nimport { Run } from \"./run\"\nimport { RunType } from \"./run-type\"\n\nconst makeLabelDict = (size: number, grid: string[]): Map<string, Coords> => {\n  const dict = new Map<string, Coords>()\n  for (const row of range(size)) {\n    for (const col of range(size)) {\n      const ch = grid[row][col]\n      if (/[A-Za-z]/.test(ch)) {\n        dict.set(ch, { row, col })\n      }\n    }\n  }\n  return dict\n}\n\nconst findBlocks = (size: number, grid: string[]): Coords[] => {\n  const blocks: Coords[] = []\n  for (const row of range(size)) {\n    for (const col of range(size)) {\n      const ch = grid[row][col]\n      if (/[A-Za-z-]/.test(ch)) {\n        blocks.push({ row, col })\n      }\n    }\n  }\n  return blocks\n}\n\nconst findUnknowns = (size: number, grid: string[]): Coords[] => {\n  const unknowns: Coords[] = []\n  for (const row of range(size)) {\n    for (const col of range(size)) {\n      const ch = grid[row][col]\n      if (ch === \".\") {\n        unknowns.push({ row, col })\n      }\n    }\n  }\n  return unknowns\n}\n\nconst findRun = (unknowns: Coords[], startingPoint: Coords, advance: (coords: Coords) => Coords): Coords[] => {\n  const run: Coords[] = []\n  let currentCoords = startingPoint\n  const isInUnknowns = (coords: Coords) => unknowns.findIndex(unknown => sameCoords(unknown, coords)) >= 0\n  for (; ;) {\n    currentCoords = advance(currentCoords)\n    if (!isInUnknowns(currentCoords)) break\n    run.push(currentCoords)\n  }\n  return run\n}\n\nconst findHorizontalRuns = (unknowns: Coords[], clues: Clue[]): Run[] => {\n  return clues\n    .filter(clue => clue.acrossSum !== undefined)\n    .map(clue => {\n      const coordsList = findRun(unknowns, clue.coords, goRight)\n      return { runType: RunType.Horizontal, coordsList, sum: clue.acrossSum! }\n    })\n}\n\nconst findVerticalRuns = (unknowns: Coords[], clues: Clue[]): Run[] => {\n  return clues\n    .filter(clue => clue.downSum !== undefined)\n    .map(clue => {\n      const coordsList = findRun(unknowns, clue.coords, goDown)\n      return { runType: RunType.Vertical, coordsList, sum: clue.downSum! }\n    })\n}\n\nconst parseClues = (labelDict: Map<string, Coords>, cluesString: string): Clue[] => {\n  return cluesString\n    .split(/\\s/)\n    .map(s => s.trim())\n    .filter(Boolean)\n    .map(clueString => parseClue(labelDict, clueString))\n}\n\nconst parseClue = (labelDict: Map<string, Coords>, clueString: string): Clue => {\n  const bits = clueString.split(\":\").map(s => s.trim())\n  const label = bits[0]\n  const sumsString = bits[1]\n  const coords = labelDict.get(label)!\n\n  const parseSum = (sumString: string): number | undefined => {\n    const sum = Number(sumString)\n    return Number.isInteger(sum) ? sum : undefined\n  }\n\n  const sumsList = sumsString.split(\",\").map(s => s.trim())\n  const acrossSum = parseSum(sumsList[0] ?? \"\")\n  const downSum = parseSum(sumsList[1] ?? \"\")\n\n  return { coords, acrossSum, downSum }\n}\n\nconst parsePuzzle = (grid: string[], cluesString: string): Puzzle => {\n  const size = grid.length\n  const blocks = findBlocks(size, grid)\n  const labelDict = makeLabelDict(size, grid)\n  const unknowns = findUnknowns(size, grid)\n  const clues = parseClues(labelDict, cluesString)\n  const horizontalRuns = findHorizontalRuns(unknowns, clues)\n  const verticalRuns = findVerticalRuns(unknowns, clues)\n  return { size, blocks, clues, unknowns, horizontalRuns, verticalRuns }\n}\n\nexport const puzzles = [\n  parsePuzzle(\n    [\n      \"--AB-CD-EF\",\n      \"-G..H..I..\",\n      \"J...K.....\",\n      \"L....M...-\",\n      \"N..O....PQ\",\n      \"R..S...T..\",\n      \"--U....V..\",\n      \"-W...X....\",\n      \"Y.....Z...\",\n      \"a..b..c..-\"\n    ],\n    `\n      A:-,19 B:-,18 C:-,14 D:-,35 E:-,22 F:-,17\n      G:16,15 H:9,- I:16,24\n      J:7,- K:35,31\n      L:29,- M:24,11\n      N:3,- O:21,- P:-,26 Q:-,16\n      R:4,- S:17,9 T:7,-\n      U:11,17 V:17,6\n      W:21,7 X:12,8\n      Y:25,- Z:9,-\n      a:4,- b:4,- c:4,-\n    `\n  )\n]\n","import { sameCoordsList } from \"types\"\nimport { Coords } from \"types\"\nimport { RunType } from \"./run-type\"\n\nexport type Run = {\n  runType: RunType,\n  coordsList: Coords[],\n  sum: number\n}\n\nexport const sameRun = (run1: Run, run2: Run): boolean => {\n  return (\n    run1.runType === run2.runType &&\n    run1.sum === run2.sum &&\n    sameCoordsList(run1.coordsList, run2.coordsList)\n  )\n}\n","// https://www.chadgolden.com/blog/finding-all-the-permutations-of-an-array-in-c-sharp\n\nexport const doPermute = (nums: number[]): number[][] => {\n  const permutations: number[][] = []\n  doPermuteInternal(nums, 0, nums.length - 1, permutations)\n  return permutations\n}\n\nconst doPermuteInternal = (nums: number[], start: number, end: number, list: number[][]): void => {\n  if (start === end) {\n    list.push(nums.slice())\n  } else {\n    for (let i = start; i <= end; i++) {\n      swap(nums, start, i)\n      doPermuteInternal(nums, start + 1, end, list)\n      swap(nums, start, i)\n    }\n  }\n}\n\nconst swap = (nums: number[], index1: number, index2: number): void => {\n  const temp = nums[index1]\n  nums[index1] = nums[index2]\n  nums[index2] = temp\n}\n","import { Coords, IDemo, sameCoords } from \"types\"\nimport { range, sum } from \"utils\"\nimport { InternalRow } from \"./internal-row\"\nimport { Run, sameRun } from \"./run\"\nimport { Puzzle } from \"./puzzle\"\nimport { RunType } from \"./run-type\"\nimport { doPermute } from \"./permutations\"\n\nconst DIGITS = range(9).map(n => n + 1)\n\nexport class Demo implements IDemo<Puzzle, InternalRow> {\n\n  buildInternalRows(puzzle: Puzzle): InternalRow[] {\n    const internalRows: InternalRow[] = []\n\n    const createInternalRowsFor = (runs: Run[]): void => {\n      for (const run of runs) {\n        for (const setOfValues of this.findSetsOfValues(run)) {\n          for (const values of doPermute(setOfValues)) {\n            const internalRow = { puzzle, run, values }\n            internalRows.push(internalRow)\n          }\n        }\n      }\n    }\n\n    createInternalRowsFor(puzzle.horizontalRuns)\n    createInternalRowsFor(puzzle.verticalRuns)\n\n    return internalRows\n  }\n\n  // Return sets of values where each set of values:\n  // - has length run.CoordsList.Length\n  // - sums to run.Sum\n  // - contains only values 1..9\n  // - does not have any duplicated values\n  // e.g. for run length 3 and sum 10, valid sets of values would be [1,4,5], [2,3,5], [1,3,6], etc\n  findSetsOfValues(run: Run): number[][] {\n    const setsOfValues: number[][] = []\n\n    const helper = (n: number, useds: number[][], setOfValues: number[]): void => {\n      const remainingDigits = this.digitsExcept(useds.flat())\n      const used: number[] = []\n      useds.push(used)\n      for (const digit of remainingDigits) {\n        setOfValues.push(digit)\n        used.push(digit)\n        if (n > 1) {\n          helper(n - 1, useds, setOfValues)\n        } else {\n          if (sum(setOfValues) === run.sum) {\n            setsOfValues.push(setOfValues.slice())\n          }\n        }\n        setOfValues.pop()\n      }\n      useds.pop()\n    }\n\n    const runLength = run.coordsList.length\n    helper(runLength, [], []);\n\n    return setsOfValues\n  }\n\n  digitsExcept(ds: number[]): number[] {\n    return DIGITS.filter(d => !ds.includes(d))\n  }\n\n  internalRowToMatrixRow(internalRow: InternalRow): number[] {\n    const { puzzle, run, values } = internalRow\n    const horizontalRunColumns = this.makeHorizontalRunColumns(puzzle, run)\n    const verticalRunColumns = this.makeVerticalRunColumns(puzzle, run)\n    const horizontalRunValueColumns = this.makeHorizontalRunValueColumns(puzzle, run, values)\n    const verticalRunValueColumns = this.makeVerticalRunValueColumns(puzzle, run, values)\n    return horizontalRunColumns\n      .concat(verticalRunColumns)\n      .concat(horizontalRunValueColumns)\n      .concat(verticalRunValueColumns)\n  }\n\n  getNumPrimaryColumns(puzzle: Puzzle): number | undefined {\n    return puzzle.horizontalRuns.length + puzzle.verticalRuns.length\n  }\n\n  makeHorizontalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.horizontalRuns.length).fill(0)\n    if (run.runType === RunType.Horizontal) {\n      const index = this.findHorizontalRunIndex(puzzle, run)\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  makeVerticalRunColumns(puzzle: Puzzle, run: Run): number[] {\n    const columns = Array(puzzle.verticalRuns.length).fill(0)\n    if (run.runType === RunType.Vertical) {\n      const index = this.findVerticalRunIndex(puzzle, run)\n      columns[index] = 1\n    }\n    return columns\n  }\n\n  makeHorizontalRunValueColumns(puzzle: Puzzle, run: Run, values: number[]): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0)\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index]\n      const encodedValue = run.runType === RunType.Horizontal\n        ? this.encodeValueNormal(value)\n        : this.encodeValueInverse(value)\n      const unknown = run.coordsList[index]\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown)\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] = encodedValue[encodedValueIndex]\n      }\n    }\n    return columns\n  }\n\n  makeVerticalRunValueColumns(puzzle: Puzzle, run: Run, values: number[]): number[] {\n    const columns = Array(puzzle.unknowns.length * 9).fill(0)\n    for (const index of range(run.coordsList.length)) {\n      const value = values[index]\n      const encodedValue = run.runType === RunType.Vertical\n        ? this.encodeValueNormal(value)\n        : this.encodeValueInverse(value)\n      const unknown = run.coordsList[index]\n      const unknownIndex = this.findUnknownIndex(puzzle, unknown)\n      for (const encodedValueIndex of range(9)) {\n        columns[unknownIndex * 9 + encodedValueIndex] = encodedValue[encodedValueIndex]\n      }\n    }\n    return columns\n  }\n\n  encodeValueNormal(value: number): number[] {\n    const columns = Array(9).fill(0)\n    const index = value - 1\n    columns[index] = 1\n    return columns\n  }\n\n  encodeValueInverse(value: number): number[] {\n    const columns = Array(9).fill(1)\n    const index = value - 1\n    columns[index] = 0\n    return columns\n  }\n\n  findHorizontalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.horizontalRuns.findIndex(r => sameRun(r, run))\n  }\n\n  findVerticalRunIndex(puzzle: Puzzle, run: Run): number {\n    return puzzle.verticalRuns.findIndex(r => sameRun(r, run))\n  }\n\n  findUnknownIndex(puzzle: Puzzle, unknown: Coords): number {\n    return puzzle.unknowns.findIndex(u => sameCoords(u, unknown))\n  }\n}\n","// Unexpected use of 'self'.\n/* eslint-disable no-restricted-globals */\n\nimport * as dlxlib from \"dlxlib/dlx\"\nimport * as Sudoku from \"demos/sudoku\"\nimport * as NQueens from \"demos/n-queens\"\nimport * as FlowFree from \"demos/flow-free\"\nimport * as Kakuro from \"demos/kakuro\"\n\nconst map = new Map<string, any>([\n  [\"sudoku\", Sudoku.Demo],\n  [\"n-queens\", NQueens.Demo],\n  [\"flow-free\", FlowFree.Demo],\n  [\"kakuro\", Kakuro.Demo]\n])\n\n// 'worker.ts' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module.ts(1208)\nexport { }\n\ntype SearchStepEvent = {\n  partialSolution: number[],\n  stepIndex: number\n}\n\ntype SolutionFoundEvent = {\n  solution: number[],\n  solutionIndex: number\n}\n\nconst onSolve = (shortName: string, puzzle: any) => {\n  const demoConstructor = map.get(shortName)\n  if (!demoConstructor) {\n    self.postMessage({ type: \"unknownDemo\" })\n    return\n  }\n  const demo = new demoConstructor()\n  const internalRows = demo.buildInternalRows(puzzle)\n  const matrix = internalRows.map((internalRow: any) => demo.internalRowToMatrixRow(internalRow))\n  const options: dlxlib.Options = {\n    numSolutions: 1,\n    numPrimaryColumns: demo.getNumPrimaryColumns(puzzle)\n  }\n\n  const onStep = (event: SearchStepEvent) => {\n    console.log(\"[worker onStep]\", \"stepIndex:\", event.stepIndex)\n    const partialSolution = event.partialSolution\n    const solutionInternalRows = partialSolution.map(index => internalRows[index])\n    self.postMessage({ type: \"searchStep\", solutionInternalRows })\n  }\n\n  const onSolution = (event: SolutionFoundEvent) => {\n    console.log(\"[worker onSolution]\", \"solutionIndex:\", event.solutionIndex)\n    const solution = event.solution\n    const solutionInternalRows = solution.map(index => internalRows[index])\n    self.postMessage({ type: \"solutionFound\", solutionInternalRows })\n  }\n\n  const dlx = new dlxlib.Dlx()\n  dlx.addListener(\"step\", onStep)\n  dlx.addListener(\"solution\", onSolution)\n  const solutions = dlx.solve(matrix, options)\n\n  self.postMessage({ type: \"finished\", numSolutionsFound: solutions.length })\n}\n\nself.onmessage = (ev: MessageEvent<any>) => {\n  try {\n    console.log(\"[worker onmessage]\", \"ev.data.type:\", ev.data.type)\n    if (ev.data.type === \"solve\") {\n      const { shortName, puzzle } = ev.data\n      onSolve(shortName, puzzle)\n      return\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      self.postMessage({ type: \"error\", message: error.message })\n    } else {\n      self.postMessage({ type: \"error\", message: String(error) })\n    }\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [282], function() { return __webpack_require__(5908); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"b043ec31\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/dlxlib-demos/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t908: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdlxlib_demos\"] = self[\"webpackChunkdlxlib_demos\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(282).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DataObject","listHeader","rowIndex","up","down","left","right","this","addDataObject","dataObject","fn","loop","propName","next","ColumnObject","previousColumnObject","nextColumnObject","numberOfRows","columnObject","appendToColumn","unlinkFromColumn","relinkIntoColumn","search","Dlx","checkOptions","options","undefined","numSolutions","Number","isInteger","Error","numPrimaryColumns","matrix","MAX_SAFE_INTEGER","solutions","iterator","solutionGenerator","index","iteratorResult","done","push","value","root","buildInternalStructure","searchState","SearchState","EventEmitter","length","colIndexToListHeader","Map","forEach","row","firstDataObjectInThisRow","col","colIndex","appendColumnHeader","set","get","appendToRow","byAscendingRowIndices","rowIndex1","rowIndex2","raiseSearchStepEvent","isEmpty","currentSolution","raiseSolutionFoundEvent","slice","sort","c","chooseColumnWithFewestRows","coverColumn","r","pushRowIndex","loopRight","j","loopLeft","uncoverColumn","popRowIndex","chosenColumn","loopNext","column","unlinkColumnHeader","loopDown","i","unlinkDataObject","loopUp","relinkDataObject","relinkColumnHeader","dlx","stepIndex","solutionIndex","pop","listenerCount","e","partialSolution","emit","solution","range","n","Array","from","keys","CurrentState","goDown","coords","goLeft","goRight","sameCoords","coords1","coords2","grid","RunType","Demo","puzzle","flatMap","map","initialValue","initialValues","find","iv","_buildInternalRowsForInitialValue","_buildInternalRowsForCoords","isInitialValue","internalRow","box","_rowColToBox","zeroBasedValue","posColumns","_oneHot","rowColumns","colColumns","boxColumns","concat","major","minor","columns","fill","Math","floor","gridRow","ch","size","diagonalColumnCount","diagonal1Columns","diagonal2Columns","diagonal1","diagonal2","findPaths","colourPair","start","goal","end","currentPath","paths","maxDirectionChanges","colourPairs","findPathsInternal","node","nextNode","path","countDirectionChanges","findIndex","p","neighbours","dots","cp","filter","d","isDot","count","p1","p3","rowDiff","abs","colDiff","internalRows","coordsList","name","dict","test","has","label","parsePuzzle","findRun","unknowns","startingPoint","advance","run","currentCoords","isInUnknowns","unknown","parseClue","labelDict","clueString","bits","split","s","trim","sumsString","parseSum","sumString","sum","sumsList","acrossSum","downSum","sameRun","cluesString","blocks","findBlocks","makeLabelDict","findUnknowns","clues","Boolean","parseClues","horizontalRuns","clue","runType","findHorizontalRuns","verticalRuns","findVerticalRuns","run1","run2","coordsList1","coordsList2","sameCoordsList","doPermute","nums","permutations","doPermuteInternal","list","swap","index1","index2","temp","DIGITS","createInternalRowsFor","runs","findSetsOfValues","setOfValues","values","setsOfValues","helper","useds","remainingDigits","digitsExcept","flat","used","digit","reduce","acc","ds","includes","horizontalRunColumns","makeHorizontalRunColumns","verticalRunColumns","makeVerticalRunColumns","horizontalRunValueColumns","makeHorizontalRunValueColumns","verticalRunValueColumns","makeVerticalRunValueColumns","findHorizontalRunIndex","findVerticalRunIndex","encodedValue","encodeValueNormal","encodeValueInverse","unknownIndex","findUnknownIndex","encodedValueIndex","u","Sudoku","NQueens","FlowFree","Kakuro","self","onmessage","ev","console","log","data","type","shortName","demoConstructor","demo","buildInternalRows","internalRowToMatrixRow","getNumPrimaryColumns","dlxlib","addListener","event","solutionInternalRows","postMessage","solve","numSolutionsFound","onSolve","error","message","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","x","__webpack_exports__","O","deferred","result","chunkIds","priority","notFulfilled","Infinity","fulfilled","Object","every","key","splice","getter","__esModule","a","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","promises","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}